#include "GenerateFunctions.h"
void mCommandFunctionEmpty() {
	context.end = 2;
	printf("function not implementation %X\n", context.lastCommandInfo.command);
	//*((uint8_t*)NULL) = 0;
}
//ADD
void handlerCommand16Code0000P66_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0000_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0001P66_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_ADD32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand16Code0001_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_ADD16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand16Code0002P66_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0002_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0003P66_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_ADD32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand16Code0003_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_ADD16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand16Code0004P66_RM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_ADD8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0004_RM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_ADD8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0005P66_RM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_ADD32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand16Code0005_RM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_ADD16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//Push
void handlerCommand16Code0006_RM() {
	LOG("%s","Push");
	uint8_t rg = 0x00;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(rg);
}
//Push
void handlerCommand16Code000E_RM() {
	LOG("%s","Push");
	uint8_t rg = 0x01;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(rg);
}
//Push
void handlerCommand16Code0016_RM() {
	LOG("%s","Push");
	uint8_t rg = 0x02;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(rg);
}
//Push
void handlerCommand16Code001E_RM() {
	LOG("%s","Push");
	uint8_t rg = 0x03;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(rg);
}
//Pop
void handlerCommand16Code0007_RM() {
	LOG("%s","Pop");
	uint8_t rg = 0x00;
	    SET_VALUE_IN_SEGMENT(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	    reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code000F_RM() {
	LOG("%s","Pop");
	uint8_t rg = 0x01;
	// 0f???
}
//Pop
void handlerCommand16Code0017_RM() {
	LOG("%s","Pop");
	uint8_t rg = 0x02;
	    SET_VALUE_IN_SEGMENT(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	    reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code001F_RM() {
	LOG("%s","Pop");
	uint8_t rg = 0x03;
	    SET_VALUE_IN_SEGMENT(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	    reg_SP_16u += 16 / 8;
}
//OR
void handlerCommand16Code0008P66_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code0008_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code0009P66_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_OR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand16Code0009_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_OR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand16Code000AP66_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code000A_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code000BP66_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_OR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand16Code000B_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_OR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand16Code000CP66_RM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_OR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code000C_RM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_OR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code000DP66_RM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_OR32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand16Code000D_RM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_OR16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand16Code0010P66_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0010_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0011P66_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
	lazyFlagType = t_ADC32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand16Code0011_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
	lazyFlagType = t_ADC16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand16Code0012P66_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0012_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0013P66_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
	lazyFlagType = t_ADC32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand16Code0013_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
	lazyFlagType = t_ADC16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand16Code0014P66_RM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) + oldcf;
	lazyFlagType = t_ADC8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0014_RM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) + oldcf;
	lazyFlagType = t_ADC8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0015P66_RM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32)) + oldcf;
	lazyFlagType = t_ADC32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand16Code0015_RM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16)) + oldcf;
	lazyFlagType = t_ADC16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand16Code0018P66_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code0018_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code0019P66_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
	lazyFlagType = t_SBB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand16Code0019_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
	lazyFlagType = t_SBB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand16Code001AP66_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code001A_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code001BP66_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
	lazyFlagType = t_SBB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand16Code001B_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
	lazyFlagType = t_SBB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand16Code001CP66_RM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) - oldcf;
	lazyFlagType = t_SBB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code001C_RM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) - oldcf;
	lazyFlagType = t_SBB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code001DP66_RM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) - oldcf;
	lazyFlagType = t_SBB32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand16Code001D_RM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) - oldcf;
	lazyFlagType = t_SBB16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand16Code0020P66_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0020_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0021P66_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_AND32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand16Code0021_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_AND16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand16Code0022P66_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0022_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0023P66_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_AND32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand16Code0023_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_AND16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand16Code0024P66_RM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_AND8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0024_RM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_AND8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0025P66_RM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_AND32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand16Code0025_RM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_AND16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand16Code0028P66_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code0028_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code0029P66_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_SUB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand16Code0029_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_SUB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand16Code002AP66_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code002A_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code002BP66_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_SUB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand16Code002B_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_SUB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand16Code002CP66_RM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_SUB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code002C_RM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_SUB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code002DP66_RM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_SUB32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand16Code002D_RM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_SUB16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand16Code0030P66_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0030_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0031P66_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_XOR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand16Code0031_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_XOR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand16Code0032P66_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0032_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0033P66_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_XOR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand16Code0033_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_XOR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand16Code0034P66_RM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_XOR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0034_RM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_XOR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0035P66_RM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_XOR32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand16Code0035_RM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_XOR16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//CMP
void handlerCommand16Code0038P66_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code0038_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code0039P66_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand16Code0039_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand16Code003AP66_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code003A_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code003BP66_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand16Code003B_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand16Code003CP66_RM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code003C_RM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code003DP66_RM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand16Code003D_RM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_CMP16;
}
//Inc
void handlerCommand16Code0040P66_RM() {
	LOG("%s","Inc");
	reg_0x00_32u += 1;
	LazyFlagResultContainer32 = reg_0x00_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0040_RM() {
	LOG("%s","Inc");
	reg_0x00_16u += 1;
	LazyFlagResultContainer16 = reg_0x00_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0041P66_RM() {
	LOG("%s","Inc");
	reg_0x01_32u += 1;
	LazyFlagResultContainer32 = reg_0x01_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0041_RM() {
	LOG("%s","Inc");
	reg_0x01_16u += 1;
	LazyFlagResultContainer16 = reg_0x01_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0042P66_RM() {
	LOG("%s","Inc");
	reg_0x02_32u += 1;
	LazyFlagResultContainer32 = reg_0x02_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0042_RM() {
	LOG("%s","Inc");
	reg_0x02_16u += 1;
	LazyFlagResultContainer16 = reg_0x02_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0043P66_RM() {
	LOG("%s","Inc");
	reg_0x03_32u += 1;
	LazyFlagResultContainer32 = reg_0x03_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0043_RM() {
	LOG("%s","Inc");
	reg_0x03_16u += 1;
	LazyFlagResultContainer16 = reg_0x03_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0044P66_RM() {
	LOG("%s","Inc");
	reg_0x04_32u += 1;
	LazyFlagResultContainer32 = reg_0x04_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0044_RM() {
	LOG("%s","Inc");
	reg_0x04_16u += 1;
	LazyFlagResultContainer16 = reg_0x04_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0045P66_RM() {
	LOG("%s","Inc");
	reg_0x05_32u += 1;
	LazyFlagResultContainer32 = reg_0x05_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0045_RM() {
	LOG("%s","Inc");
	reg_0x05_16u += 1;
	LazyFlagResultContainer16 = reg_0x05_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0046P66_RM() {
	LOG("%s","Inc");
	reg_0x06_32u += 1;
	LazyFlagResultContainer32 = reg_0x06_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0046_RM() {
	LOG("%s","Inc");
	reg_0x06_16u += 1;
	LazyFlagResultContainer16 = reg_0x06_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0047P66_RM() {
	LOG("%s","Inc");
	reg_0x07_32u += 1;
	LazyFlagResultContainer32 = reg_0x07_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0047_RM() {
	LOG("%s","Inc");
	reg_0x07_16u += 1;
	LazyFlagResultContainer16 = reg_0x07_16u;
	lazyFlagType = t_INC16;
}
//Dec
void handlerCommand16Code0048P66_RM() {
	LOG("%s","Dec");
	reg_0x00_32u -= 1;
	LazyFlagResultContainer32 = reg_0x00_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code0048_RM() {
	LOG("%s","Dec");
	reg_0x00_16u -= 1;
	LazyFlagResultContainer16 = reg_0x00_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code0049P66_RM() {
	LOG("%s","Dec");
	reg_0x01_32u -= 1;
	LazyFlagResultContainer32 = reg_0x01_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code0049_RM() {
	LOG("%s","Dec");
	reg_0x01_16u -= 1;
	LazyFlagResultContainer16 = reg_0x01_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004AP66_RM() {
	LOG("%s","Dec");
	reg_0x02_32u -= 1;
	LazyFlagResultContainer32 = reg_0x02_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004A_RM() {
	LOG("%s","Dec");
	reg_0x02_16u -= 1;
	LazyFlagResultContainer16 = reg_0x02_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004BP66_RM() {
	LOG("%s","Dec");
	reg_0x03_32u -= 1;
	LazyFlagResultContainer32 = reg_0x03_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004B_RM() {
	LOG("%s","Dec");
	reg_0x03_16u -= 1;
	LazyFlagResultContainer16 = reg_0x03_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004CP66_RM() {
	LOG("%s","Dec");
	reg_0x04_32u -= 1;
	LazyFlagResultContainer32 = reg_0x04_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004C_RM() {
	LOG("%s","Dec");
	reg_0x04_16u -= 1;
	LazyFlagResultContainer16 = reg_0x04_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004DP66_RM() {
	LOG("%s","Dec");
	reg_0x05_32u -= 1;
	LazyFlagResultContainer32 = reg_0x05_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004D_RM() {
	LOG("%s","Dec");
	reg_0x05_16u -= 1;
	LazyFlagResultContainer16 = reg_0x05_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004EP66_RM() {
	LOG("%s","Dec");
	reg_0x06_32u -= 1;
	LazyFlagResultContainer32 = reg_0x06_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004E_RM() {
	LOG("%s","Dec");
	reg_0x06_16u -= 1;
	LazyFlagResultContainer16 = reg_0x06_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004FP66_RM() {
	LOG("%s","Dec");
	reg_0x07_32u -= 1;
	LazyFlagResultContainer32 = reg_0x07_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004F_RM() {
	LOG("%s","Dec");
	reg_0x07_16u -= 1;
	LazyFlagResultContainer16 = reg_0x07_16u;
	lazyFlagType = t_DEC16;
}
//Push
void handlerCommand16Code0050P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0050P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint16_t value = reg_0x00_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0050P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0050_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint16_t value = reg_0x00_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0051P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0051P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint16_t value = reg_0x01_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0051P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0051_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint16_t value = reg_0x01_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0052P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0052P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint16_t value = reg_0x02_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0052P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0052_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint16_t value = reg_0x02_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0053P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0053P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint16_t value = reg_0x03_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0053P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0053_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint16_t value = reg_0x03_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0054P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0054P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint16_t value = reg_0x04_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0054P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0054_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint16_t value = reg_0x04_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0055P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0055P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint16_t value = reg_0x05_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0055P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0055_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint16_t value = reg_0x05_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0056P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0056P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint16_t value = reg_0x06_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0056P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0056_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint16_t value = reg_0x06_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0057P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0057P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint16_t value = reg_0x07_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0057P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0057_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint16_t value = reg_0x07_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Pop
void handlerCommand16Code0058P66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code0058P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code0058P66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code0058_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code0059P66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code0059P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code0059P66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code0059_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005AP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005AP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005AP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005A_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005BP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005BP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005BP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005B_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005CP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005CP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005CP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005C_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005DP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005DP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005DP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005D_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005EP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005EP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005EP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005E_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005FP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005FP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005FP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005F_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//PUSHA
void handlerCommand16Code0060P66_RM() {
	LOG("%s","PUSHA");
	uint32_t tmp = reg_SP_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_AX_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_CX_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_DX_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BX_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = tmp;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SI_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_DI_32u;
}
//PUSHA
void handlerCommand16Code0060_RM() {
	LOG("%s","PUSHA");
	uint16_t tmp = reg_SP_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_AX_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_CX_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_DX_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BX_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = tmp;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SI_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_DI_16u;
}
//POPA
void handlerCommand16Code0061P66_RM() {
	LOG("%s","POPA");
	reg_DI_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_SI_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_BP_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_SP_16u += 32 / 8;
	reg_BX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_DX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_CX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_AX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//POPA
void handlerCommand16Code0061_RM() {
	LOG("%s","POPA");
	reg_DI_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_SI_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_BP_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_SP_16u += 16 / 8;
	reg_BX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_DX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_CX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_AX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Push
void handlerCommand16Code0068P66P67_RM() {
	LOG("%s","Push");
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = read32u();
}
//Push
void handlerCommand16Code0068P67_RM() {
	LOG("%s","Push");
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = read16u();
}
//Push
void handlerCommand16Code0068P66_RM() {
	LOG("%s","Push");
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = read32u();
}
//Push
void handlerCommand16Code0068_RM() {
	LOG("%s","Push");
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = read16u();
}
//Mul
void handlerCommand16Code0069P66_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = read32();
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Mul
void handlerCommand16Code0069_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = read16();
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Push
void handlerCommand16Code006AP66P67_RM() {
	LOG("%s","Push");
	reg_SP_32u -= 32 / 8;
	*(int32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = (int32_t)read8();
}
//Push
void handlerCommand16Code006AP67_RM() {
	LOG("%s","Push");
	reg_SP_32u -= 16 / 8;
	*(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = (int16_t)read8();
}
//Push
void handlerCommand16Code006AP66_RM() {
	LOG("%s","Push");
	reg_SP_16u -= 32 / 8;
	*(int32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = (int32_t)read8();
}
//Push
void handlerCommand16Code006A_RM() {
	LOG("%s","Push");
	reg_SP_16u -= 16 / 8;
	*(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = (int16_t)read8();
}
//Mul
void handlerCommand16Code006B_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = (int16_t)read8();
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//J(cond)
void handlerCommand16Code0070_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x00 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0071_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x01 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0072_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x02 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0073_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x03 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0074_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x04 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0075_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x05 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0076_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x06 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0077_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x07 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0078_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x08 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0079_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x09 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007A_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0A {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007B_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0B {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007C_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0C {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007D_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0D {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007E_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0E {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007F_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0F {
		context.index += address;
	}
}
//Math
void handlerCommand16Code0080P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0080_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0081P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_ADD32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_OR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
			lazyFlagType = t_ADC32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
			lazyFlagType = t_SBB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_AND32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_SUB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_XOR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_CMP32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0081_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_ADD16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_OR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
			lazyFlagType = t_ADC16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
			lazyFlagType = t_SBB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_AND16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_SUB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_XOR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_CMP16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0082_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) + ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) | ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) + ((int8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) & ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) ^ ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0083P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) + ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_ADD32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) | ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_OR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) + ((int32_t)LazyFlagVarB32) + oldcf;
			lazyFlagType = t_ADC32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) - oldcf;
			lazyFlagType = t_SBB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) & ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_AND32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_SUB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) ^ ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_XOR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_CMP32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0083_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) + ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_ADD16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) | ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_OR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) + ((int16_t)LazyFlagVarB16) + oldcf;
			lazyFlagType = t_ADC16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) - oldcf;
			lazyFlagType = t_SBB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) & ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_AND16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_SUB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) ^ ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_XOR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_CMP16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//TEST
void handlerCommand16Code0084P66_RM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand16Code0084_RM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand16Code0085P66_RM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_TEST32;
}
//TEST
void handlerCommand16Code0085_RM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_TEST16;
}
//XCHG
void handlerCommand16Code0086P66_RM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t tmp = *(uint16_t*)target;
	*(uint16_t*)target = *(uint16_t*)source;
	*(uint16_t*)source = tmp;
}
//XCHG
void handlerCommand16Code0086_RM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t tmp = *(uint16_t*)target;
	*(uint16_t*)target = *(uint16_t*)source;
	*(uint16_t*)source = tmp;
}
//XCHG
void handlerCommand16Code0087P66_RM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t tmp = *(uint16_t*)target;
	*(uint16_t*)target = *(uint16_t*)source;
	*(uint16_t*)source = tmp;
}
//XCHG
void handlerCommand16Code0087_RM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t tmp = *(uint16_t*)target;
	*(uint16_t*)target = *(uint16_t*)source;
	*(uint16_t*)source = tmp;
}
//Move
void handlerCommand16Code0088P66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code0088_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code0089P66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code0089_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code008AP66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code008A_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code008BP66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code008B_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code008C_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t sr = readMiddle3Bit(mrmByte);
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readSegmentRegisterMRM;
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code008E_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t sr = readMiddle3Bit(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readSegmentRegisterMRM;
	*(uint16_t*)target = *(uint16_t*)source;
	recalculatePointerSegmentRegisterMRM
}
//Lea
void handlerCommand16Code008DP66P67_RM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint16_t target = effectiveAddressMRM16For16(mrmByte);
	*((uint32_t*)source) = (uint32_t)(target & 0xFFFFFFFF);
}
//Lea
void handlerCommand16Code008DP67_RM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t target = effectiveAddressMRM16For16(mrmByte);
	*((uint16_t*)source) = (uint16_t)(target & 0xFFFF);
}
//Lea
void handlerCommand16Code008DP66_RM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint16_t target = effectiveAddressMRM16For16(mrmByte);
	*((uint32_t*)source) = (uint32_t)(target & 0xFFFFFFFF);
}
//Lea
void handlerCommand16Code008D_RM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t target = effectiveAddressMRM16For16(mrmByte);
	*((uint16_t*)source) = (uint16_t)(target & 0xFFFF);
}
//Pop
void handlerCommand16Code008FP66P67_RM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			*(uint32_t*)target = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
			reg_SP_32u += 32 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand16Code008FP67_RM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			*(uint16_t*)target = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
			reg_SP_32u += 16 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand16Code008FP66_RM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			*(uint32_t*)target = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
			reg_SP_16u += 32 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand16Code008F_RM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			*(uint16_t*)target = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
			reg_SP_16u += 16 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//XCHG
void handlerCommand16Code0090P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x00;
	// NOP
}
//XCHG
void handlerCommand16Code0090_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x00;
	// NOP
}
//XCHG
void handlerCommand16Code0091P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x01;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x01_16u;
	reg_0x01_16u = tmp;
}
//XCHG
void handlerCommand16Code0091_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x01;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x01_16u;
	reg_0x01_16u = tmp;
}
//XCHG
void handlerCommand16Code0092P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x02;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x02_16u;
	reg_0x02_16u = tmp;
}
//XCHG
void handlerCommand16Code0092_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x02;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x02_16u;
	reg_0x02_16u = tmp;
}
//XCHG
void handlerCommand16Code0093P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x03;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x03_16u;
	reg_0x03_16u = tmp;
}
//XCHG
void handlerCommand16Code0093_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x03;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x03_16u;
	reg_0x03_16u = tmp;
}
//XCHG
void handlerCommand16Code0094P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x04;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x04_16u;
	reg_0x04_16u = tmp;
}
//XCHG
void handlerCommand16Code0094_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x04;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x04_16u;
	reg_0x04_16u = tmp;
}
//XCHG
void handlerCommand16Code0095P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x05;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x05_16u;
	reg_0x05_16u = tmp;
}
//XCHG
void handlerCommand16Code0095_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x05;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x05_16u;
	reg_0x05_16u = tmp;
}
//XCHG
void handlerCommand16Code0096P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x06;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x06_16u;
	reg_0x06_16u = tmp;
}
//XCHG
void handlerCommand16Code0096_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x06;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x06_16u;
	reg_0x06_16u = tmp;
}
//XCHG
void handlerCommand16Code0097P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x07;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x07_16u;
	reg_0x07_16u = tmp;
}
//XCHG
void handlerCommand16Code0097_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x07;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x07_16u;
	reg_0x07_16u = tmp;
}
//CBW
void handlerCommand16Code0098P66_RM() {
	LOG("%s","CBW");
	reg_AX_32 = reg_AX_16;
}
//CBW
void handlerCommand16Code0098_RM() {
	LOG("%s","CBW");
	reg_AX_16 = reg_AL_8;
}
//CBW
void handlerCommand16Code0099P66_RM() {
	LOG("%s","CBW");
	if (reg_AX_32 & 0x80000000) reg_DX_32=0xffffffff; else reg_DX_32=0;
}
//CBW
void handlerCommand16Code0099_RM() {
	LOG("%s","CBW");
	if (reg_AX_16 & 0x8000) reg_DX_16=0xffff;else reg_DX_16=0;
}
//Call
void handlerCommand16Code009A_RM() {
	LOG("%s","Call");
	uint16_t newIP = read16u();
	uint16_t newCS = read16u();
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
	SET_VALUE_IN_SEGMENT(SR_CS, newCS);
	context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
}
//PUSHF
void handlerCommand16Code009CP66_RM() {
	LOG("%s","PUSHF");
	FillFlags();
	reg_SP_16u -= 32 / 8;
	EncodeFlagsRegister();
	uint32_t value = reg_flags & 0xFCFFFF;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *((uint32_t*)&value);
}
//PUSHF
void handlerCommand16Code009C_RM() {
	LOG("%s","PUSHF");
	FillFlags();
	reg_SP_16u -= 16 / 8;
	EncodeFlagsRegister();
	uint32_t value = reg_flags & 0xFCFFFF;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *((uint16_t*)&value);
}
//POPF
void handlerCommand16Code009DP66_RM() {
	LOG("%s","POPF");
	lazyFlagType = t_UNKNOWN;
	*(uint32_t*)(&reg_flags) = (*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	reg_SP_16u += 32 / 8;
	DecodeFlagsRegister32();
}
//POPF
void handlerCommand16Code009D_RM() {
	LOG("%s","POPF");
	lazyFlagType = t_UNKNOWN;
	*(uint16_t*)(&reg_flags) = (*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	reg_SP_16u += 16 / 8;
	DecodeFlagsRegister16();
}
//Move
void handlerCommand16Code00A0P66P67_RM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A0P66_RM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A0P67_RM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A0_RM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A1P66P67_RM() {
	LOG("%s","Move");
	uint32_t* target = (uint32_t*)register32u(BR_AX);
	uint32_t* source = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code00A1P66_RM() {
	LOG("%s","Move");
	uint32_t* target = (uint32_t*)register32u(BR_AX);
	uint32_t* source = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code00A1P67_RM() {
	LOG("%s","Move");
	uint16_t* target = (uint16_t*)register16u(BR_AX);
	uint16_t* source = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code00A1_RM() {
	LOG("%s","Move");
	uint16_t* target = (uint16_t*)register16u(BR_AX);
	uint16_t* source = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code00A2P66P67_RM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A2P66_RM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A2P67_RM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A2_RM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A3P66P67_RM() {
	LOG("%s","Move");
	uint32_t* source = (uint32_t*)register32u(BR_AX);
	uint32_t* target = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code00A3P66_RM() {
	LOG("%s","Move");
	uint32_t* source = (uint32_t*)register32u(BR_AX);
	uint32_t* target = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code00A3P67_RM() {
	LOG("%s","Move");
	uint16_t* source = (uint16_t*)register16u(BR_AX);
	uint16_t* target = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code00A3_RM() {
	LOG("%s","Move");
	uint16_t* source = (uint16_t*)register16u(BR_AX);
	uint16_t* target = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint16_t*)target = *(uint16_t*)source;
}
//MOVS
void handlerCommand16Code00A4P66P67_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A4P66_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A4P67_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A4_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A5P66P67_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A5P66_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A5P67_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A5_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A6P66P67_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A6P66_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A6P67_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A6_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A7P66P67_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A7P66_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A7P67_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A7_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
		}
	}
}
//TEST
void handlerCommand16Code00A8P66_RM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand16Code00A8_RM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand16Code00A9P66_RM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_TEST32;
}
//TEST
void handlerCommand16Code00A9_RM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_TEST16;
}
//STOS
void handlerCommand16Code00AAP66P67_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00AAP66_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00AAP67_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00AA_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00ABP66P67_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
			reg_DI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
			reg_DI_32u += 32 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00ABP66_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
			reg_DI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
			reg_DI_16u += 32 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00ABP67_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
			reg_DI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
			reg_DI_32u += 16 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00AB_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
			reg_DI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
			reg_DI_16u += 16 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ACP66P67_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ACP66_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ACP67_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00AC_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ADP66P67_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 32 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ADP66_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 32 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ADP67_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 16 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00AD_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 16 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AEP66P67_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AEP66_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AEP67_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AE_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AFP66P67_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u += 32 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AFP66_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u += 32 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AFP67_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u += 16 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AF_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u += 16 / 8;
		}
	}
}
//Move
void handlerCommand16Code00B0P66_RM() {
	LOG("%s","Move");
	reg_0x00_8u = read8u();
}
//Move
void handlerCommand16Code00B0_RM() {
	LOG("%s","Move");
	reg_0x00_8u = read8u();
}
//Move
void handlerCommand16Code00B1P66_RM() {
	LOG("%s","Move");
	reg_0x01_8u = read8u();
}
//Move
void handlerCommand16Code00B1_RM() {
	LOG("%s","Move");
	reg_0x01_8u = read8u();
}
//Move
void handlerCommand16Code00B2P66_RM() {
	LOG("%s","Move");
	reg_0x02_8u = read8u();
}
//Move
void handlerCommand16Code00B2_RM() {
	LOG("%s","Move");
	reg_0x02_8u = read8u();
}
//Move
void handlerCommand16Code00B3P66_RM() {
	LOG("%s","Move");
	reg_0x03_8u = read8u();
}
//Move
void handlerCommand16Code00B3_RM() {
	LOG("%s","Move");
	reg_0x03_8u = read8u();
}
//Move
void handlerCommand16Code00B4P66_RM() {
	LOG("%s","Move");
	reg_0x04_8u = read8u();
}
//Move
void handlerCommand16Code00B4_RM() {
	LOG("%s","Move");
	reg_0x04_8u = read8u();
}
//Move
void handlerCommand16Code00B5P66_RM() {
	LOG("%s","Move");
	reg_0x05_8u = read8u();
}
//Move
void handlerCommand16Code00B5_RM() {
	LOG("%s","Move");
	reg_0x05_8u = read8u();
}
//Move
void handlerCommand16Code00B6P66_RM() {
	LOG("%s","Move");
	reg_0x06_8u = read8u();
}
//Move
void handlerCommand16Code00B6_RM() {
	LOG("%s","Move");
	reg_0x06_8u = read8u();
}
//Move
void handlerCommand16Code00B7P66_RM() {
	LOG("%s","Move");
	reg_0x07_8u = read8u();
}
//Move
void handlerCommand16Code00B7_RM() {
	LOG("%s","Move");
	reg_0x07_8u = read8u();
}
//Move
void handlerCommand16Code00B8P66_RM() {
	LOG("%s","Move");
	reg_0x00_32u = read32u();
}
//Move
void handlerCommand16Code00B8_RM() {
	LOG("%s","Move");
	reg_0x00_16u = read16u();
}
//Move
void handlerCommand16Code00B9P66_RM() {
	LOG("%s","Move");
	reg_0x01_32u = read32u();
}
//Move
void handlerCommand16Code00B9_RM() {
	LOG("%s","Move");
	reg_0x01_16u = read16u();
}
//Move
void handlerCommand16Code00BAP66_RM() {
	LOG("%s","Move");
	reg_0x02_32u = read32u();
}
//Move
void handlerCommand16Code00BA_RM() {
	LOG("%s","Move");
	reg_0x02_16u = read16u();
}
//Move
void handlerCommand16Code00BBP66_RM() {
	LOG("%s","Move");
	reg_0x03_32u = read32u();
}
//Move
void handlerCommand16Code00BB_RM() {
	LOG("%s","Move");
	reg_0x03_16u = read16u();
}
//Move
void handlerCommand16Code00BCP66_RM() {
	LOG("%s","Move");
	reg_0x04_32u = read32u();
}
//Move
void handlerCommand16Code00BC_RM() {
	LOG("%s","Move");
	reg_0x04_16u = read16u();
}
//Move
void handlerCommand16Code00BDP66_RM() {
	LOG("%s","Move");
	reg_0x05_32u = read32u();
}
//Move
void handlerCommand16Code00BD_RM() {
	LOG("%s","Move");
	reg_0x05_16u = read16u();
}
//Move
void handlerCommand16Code00BEP66_RM() {
	LOG("%s","Move");
	reg_0x06_32u = read32u();
}
//Move
void handlerCommand16Code00BE_RM() {
	LOG("%s","Move");
	reg_0x06_16u = read16u();
}
//Move
void handlerCommand16Code00BFP66_RM() {
	LOG("%s","Move");
	reg_0x07_32u = read32u();
}
//Move
void handlerCommand16Code00BF_RM() {
	LOG("%s","Move");
	reg_0x07_16u = read16u();
}
//Move bits
void handlerCommand16Code00C0P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00C0_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00C1P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00C1_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ret
void handlerCommand16Code00C2_RM() {
	LOG("%s","Ret");
	uint16_t stackValue = read16u();
	uint16_t* sp = register16u(BR_SP);
	context.index = GET_SEGMENT_POINTER(1) + *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (16 / 8);
	*sp += (stackValue * (16 / 16));
}
//Ret
void handlerCommand16Code00C3_RM() {
	LOG("%s","Ret");
	uint16_t* sp = register16u(BR_SP);
	context.index = GET_SEGMENT_POINTER(1) + *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (16 / 8);
}
//Load SR_ES
void handlerCommand16Code00C4_RM() {
	LOG("%s","Load SR_ES");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_ES, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//Load SR_DS
void handlerCommand16Code00C5_RM() {
	LOG("%s","Load SR_DS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_DS, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//Move
void handlerCommand16Code00C6P66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint8_t*)target = read8u();
}
//Move
void handlerCommand16Code00C6_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint8_t*)target = read8u();
}
//Move
void handlerCommand16Code00C7P66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint32_t*)target = read32u();
}
//Move
void handlerCommand16Code00C7_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = read16u();
}
//Enter
void handlerCommand16Code00C8P66P67_RM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	uint32_t tmp = reg_SP_32u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_32u = reg_BP_32u - 32 / 8;
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
		}
		reg_SP_32u -= 32 / 8;
		*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SP_32u;
	}
	reg_BP_32u = tmp;
	reg_SP_32u = reg_BP_32u - size;
}
//Enter
void handlerCommand16Code00C8P67_RM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	uint32_t tmp = reg_SP_32u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_32u = reg_BP_32u - 16 / 8;
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
		}
		reg_SP_32u -= 32 / 8;
		*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SP_32u;
	}
	reg_BP_32u = tmp;
	reg_SP_32u = reg_BP_32u - size;
}
//Enter
void handlerCommand16Code00C8P66_RM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	uint16_t tmp = reg_SP_16u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_16u = reg_BP_16u - 32 / 8;
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
		}
		reg_SP_16u -= 16 / 8;
		*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SP_16u;
	}
	reg_BP_16u = tmp;
	reg_SP_16u = reg_BP_16u - size;
}
//Enter
void handlerCommand16Code00C8_RM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	uint16_t tmp = reg_SP_16u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_16u = reg_BP_16u - 16 / 8;
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
		}
		reg_SP_16u -= 16 / 8;
		*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SP_16u;
	}
	reg_BP_16u = tmp;
	reg_SP_16u = reg_BP_16u - size;
}
//Leave
void handlerCommand16Code00C9P66P67_RM() {
	LOG("%s","Leave");
	reg_SP_32u = reg_BP_32u;
	reg_BP_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Leave
void handlerCommand16Code00C9P67_RM() {
	LOG("%s","Leave");
	reg_SP_32u = reg_BP_32u;
	reg_BP_32u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Leave
void handlerCommand16Code00C9P66_RM() {
	LOG("%s","Leave");
	reg_SP_16u = reg_BP_16u;
	reg_BP_16u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Leave
void handlerCommand16Code00C9_RM() {
	LOG("%s","Leave");
	reg_SP_16u = reg_BP_16u;
	reg_BP_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Ret
void handlerCommand16Code00CA_RM() {
	LOG("%s","Ret");
	uint16_t stackValue = read16u();
	uint16_t* sp = register16u(BR_SP);
	SET_VALUE_IN_SEGMENT(1, *(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp + 16 / 8));
	context.index = GET_SEGMENT_POINTER(1) + *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (16 / 8 + 2);
	*sp += (stackValue * (16 / 16));
}
//Ret
void handlerCommand16Code00CB_RM() {
	LOG("%s","Ret");
	uint16_t* sp = register16u(BR_SP);
	SET_VALUE_IN_SEGMENT(1, *(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp + 16 / 8));
	context.index = GET_SEGMENT_POINTER(1) + *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (16 / 8 + 2);
}
//Int
void handlerCommand16Code00CD_RM() {
	LOG("%s","Int");
	uint8_t *target = GET_REAL_MOD_MEMORY_POINTER(0) + (read8u() * (2 + 2));
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
	SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
	context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
}
//Move bits
void handlerCommand16Code00D0P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D0_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D1P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D1_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D2P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D2_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D3P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D3_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00D8_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 000, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 000, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 000, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 000, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 000, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 000, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00D9_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 001, OPB 000
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = *source;
			} else {
				// OPA 001, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 001, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 001, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				fpuRegControll = *(uint16_t*)readAddressMRM16For16(mrmByte);
			} else {
				fpuRegControll = *(uint16_t*)readAddressMRM16For16(mrmByte);
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegControll;
			} else {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegControll;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DA_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DB_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				fpuStackIndex = 7;
				fpuRegControll = 0x37F;
				fpuRegStatus = 0;
				fpuRegTag = 0xFFFF;
				fpuRegPointer = 0;
				fpuRegInstructionPointer = 0;
				fpuRegInstructionOpcode = 0;
			} else {
				fpuStackIndex = 7;
				fpuRegControll = 0x37F;
				fpuRegStatus = 0;
				fpuRegTag = 0xFFFF;
				fpuRegPointer = 0;
				fpuRegInstructionPointer = 0;
				fpuRegInstructionOpcode = 0;
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegControll;
			} else {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegControll;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DC_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 100, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 100, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 100, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 100, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 100, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 100, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DD_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegStatus;
			} else {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegStatus;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DE_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 110, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 110, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 110, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 110, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 110, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 110, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DF_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Loop
void handlerCommand16Code00E0_RM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_16 -= 1;
	FillFlags();
	if (reg_0x01_16 != 0 && GET_FLAG(ZF) == 0) {
		context.index += addr;
	}
}
//Loop
void handlerCommand16Code00E1_RM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_16 -= 1;
	FillFlags();
	if (reg_0x01_16 != 0 && GET_FLAG(ZF) == 1) {
		context.index += addr;
	}
}
//Loop
void handlerCommand16Code00E2_RM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_16 -= 1;
	if (reg_0x01_16 != 0) {
		context.index += addr;
	}
}
//Loop
void handlerCommand16Code00E3_RM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	if (reg_0x01_16 == 0) {
		context.index += addr;
	}
}
//In
void handlerCommand16Code00E4P66_RM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand16Code00E4_RM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand16Code00E5P66_RM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//In
void handlerCommand16Code00E5_RM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Out
void handlerCommand16Code00E6P66_RM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand16Code00E6_RM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand16Code00E7P66_RM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Out
void handlerCommand16Code00E7_RM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Call
void handlerCommand16Code00E8P66_RM() {
	LOG("%s","Call");
	uint16_t* sp = register16u(BR_SP);
	*sp -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index + 32 / 8 - GET_SEGMENT_POINTER(1));
	context.index += read32();
}
//Call
void handlerCommand16Code00E8_RM() {
	LOG("%s","Call");
	uint16_t* sp = register16u(BR_SP);
	*sp -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index + 16 / 8 - GET_SEGMENT_POINTER(1));
	context.index += read16();
}
//Jmp
void handlerCommand16Code00E9P66_RM() {
	LOG("%s","Jmp");
	context.index += read32();
}
//Jmp
void handlerCommand16Code00E9_RM() {
	LOG("%s","Jmp");
	context.index += read16();
}
//Jmp
void handlerCommand16Code00EB_RM() {
	LOG("%s","Jmp");
	context.index += read8();
}
//In
void handlerCommand16Code00ECP66_RM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand16Code00EC_RM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand16Code00EDP66_RM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//In
void handlerCommand16Code00ED_RM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Out
void handlerCommand16Code00EEP66_RM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand16Code00EE_RM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand16Code00EFP66_RM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Out
void handlerCommand16Code00EF_RM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//External call
void handlerCommand16Code00F1_RM() {
	LOG("%s","External call");
	uint16_t addr = read16u();
	FillFlags();
	context.functions[addr](addr);
}
//~CF
void handlerCommand16Code00F5_RM() {
	LOG("%s","~CF");
	SET_FLAG(CF, !GET_FLAG(CF));
}
//Math
void handlerCommand16Code00F6P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// TEST
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = read8();
			LazyFlagResultContainer8 = LazyFlagVarA8 & ((uint8_t)LazyFlagVarB8);
			lazyFlagType = t_TEST8;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// NOT
			*(int8_t*)target = ~(*(int8_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// NEG
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagResultContainer8 = 0 - LazyFlagVarA8;
			*(int8_t*)target = LazyFlagResultContainer8;
			lazyFlagType = t_NEG8;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			reg_AX_16u=((uint16_t)reg_AL_8u)*((uint16_t)(*(uint8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AL_8 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16));
			if (reg_AX_16 & 0xff00) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			reg_AX_16 = reg_AL_8 * (*((int8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF, reg_AL_8 == 0);
			SET_FLAG(SF, reg_AL_8 & 0x80);
			if ((reg_AX_16 & 0xff80)==0xff80 || (reg_AX_16 & 0xff80)==0x0000) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t val= *(uint8_t*)(target);
			uint16_t quo = reg_AX_16u / val;
			uint8_t rem = (uint8_t)(reg_AX_16 % val);
			uint8_t quo8 = (uint8_t)(quo&0xff);
			reg_AH_8u=rem;
			reg_AL_8u=quo8;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem]^parity_lookup[quo8]);
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			int16_t val= *(int8_t*)(target);
			int16_t quo= ((int16_t)reg_AX_16) / val;
			int8_t rem=(int8_t)((int16_t)reg_AX_16 % val);
			int8_t quo8s=(int8_t)(quo&0xff);
			reg_AH_8=(uint8_t)rem;
			reg_AL_8=(uint8_t)quo8s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem&0xff]^parity_lookup[quo8s&0xff]^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code00F6_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// TEST
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = read8();
			LazyFlagResultContainer8 = LazyFlagVarA8 & ((uint8_t)LazyFlagVarB8);
			lazyFlagType = t_TEST8;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// NOT
			*(int8_t*)target = ~(*(int8_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// NEG
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagResultContainer8 = 0 - LazyFlagVarA8;
			*(int8_t*)target = LazyFlagResultContainer8;
			lazyFlagType = t_NEG8;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			reg_AX_16u=((uint16_t)reg_AL_8u)*((uint16_t)(*(uint8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AL_8 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16));
			if (reg_AX_16 & 0xff00) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			reg_AX_16 = reg_AL_8 * (*((int8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF, reg_AL_8 == 0);
			SET_FLAG(SF, reg_AL_8 & 0x80);
			if ((reg_AX_16 & 0xff80)==0xff80 || (reg_AX_16 & 0xff80)==0x0000) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t val= *(uint8_t*)(target);
			uint16_t quo = reg_AX_16u / val;
			uint8_t rem = (uint8_t)(reg_AX_16 % val);
			uint8_t quo8 = (uint8_t)(quo&0xff);
			reg_AH_8u=rem;
			reg_AL_8u=quo8;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem]^parity_lookup[quo8]);
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			int16_t val= *(int8_t*)(target);
			int16_t quo= ((int16_t)reg_AX_16) / val;
			int8_t rem=(int8_t)((int16_t)reg_AX_16 % val);
			int8_t quo8s=(int8_t)(quo&0xff);
			reg_AH_8=(uint8_t)rem;
			reg_AL_8=(uint8_t)quo8s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem&0xff]^parity_lookup[quo8s&0xff]^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code00F7P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			// TEST
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = read32();
			LazyFlagResultContainer32 = LazyFlagVarA32 & ((uint32_t)LazyFlagVarB32);
			lazyFlagType = t_TEST32;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			// NOT
			*(int32_t*)target = ~(*(int32_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			// NEG
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagResultContainer32 = 0 - LazyFlagVarA32;
			*(int32_t*)target = LazyFlagResultContainer32;
			lazyFlagType = t_NEG32;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint64_t tempu=((uint64_t)reg_AX_32u)*((uint64_t)(*(uint32_t*)(target)));
			reg_AX_32=(uint32_t)(tempu);
			reg_DX_32=(uint32_t)(tempu >> 32);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_32 == 0);
			SET_FLAG(PF,PARITY32(reg_AX_32)^PARITY32(reg_DX_32));
			if (reg_DX_32) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			int64_t temps=((int64_t)(reg_AX_32))*((int64_t)(*(int32_t*)(target)));
			reg_AX_32=(uint32_t)(temps);
			reg_DX_32=(uint32_t)(temps >> 32);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_32 == 0);
			SET_FLAG(SF,reg_AX_32 & 0x80000000);
			if ((reg_AX_32==0xffffffff) && (reg_AX_32 & 0x80000000) ) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else if ( (reg_AX_32==0x00000000) && (reg_AX_32< 0x80000000) ) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint32_t val= *(uint32_t*)(target);
			uint64_t num=(((uint64_t)reg_DX_32u)<<32) | reg_AX_32u;
			uint64_t quo=num/val;
			uint32_t rem=(uint32_t)(num % val);
			uint32_t quo32=(uint32_t)(quo&0xffffffff);
			reg_DX_32u=rem;
			reg_AX_32u=quo32;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo32&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY32(rem)^PARITY32(quo32));
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			int64_t val=*(int32_t*)(target);
			int64_t num=(int64_t)((((uint64_t)reg_DX_32)<<(uint64_t)32)|(uint64_t)reg_AX_32);
			int64_t quo=num/val;
			int32_t rem=(int32_t)(num % val);
			int32_t quo32s=(int32_t)(quo&0xffffffff);
			reg_DX_32u=(uint32_t)rem;
			reg_AX_32u=(uint32_t)quo32s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo32s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY32((uint32_t)rem&0xffffffffu)^PARITY32((uint32_t)quo32s&0xffffffffu)^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code00F7_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			// TEST
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = read16();
			LazyFlagResultContainer16 = LazyFlagVarA16 & ((uint16_t)LazyFlagVarB16);
			lazyFlagType = t_TEST16;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			// NOT
			*(int16_t*)target = ~(*(int16_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			// NEG
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagResultContainer16 = 0 - LazyFlagVarA16;
			*(int16_t*)target = LazyFlagResultContainer16;
			lazyFlagType = t_NEG16;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint32_t tempu=((uint32_t)reg_AX_16u)*(uint32_t)(*(uint16_t*)(target));
			reg_AX_16=(uint16_t)(tempu);
			reg_DX_16=(uint16_t)(tempu >> 16);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_16 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16)^PARITY16(reg_DX_16));
			if (reg_DX_16) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			int32_t temps=reg_AX_16 * (*((int16_t*)target));
			reg_AX_16=(uint16_t)(temps);
			reg_DX_16=(uint16_t)(temps >> 16);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_16 == 0);
			SET_FLAG(SF,reg_AX_16 & 0x8000);
			if ((((uint32_t)temps & 0xffff8000)==0xffff8000 || ((uint32_t)temps & 0xffff8000)==0x0000)) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t val= *(uint16_t*)(target);
			uint32_t num=((uint32_t)reg_DX_16u<<16) | reg_AX_16u;
			uint32_t quo=num/val;
			uint16_t rem=(uint16_t)(num % val);
			uint16_t quo16=(uint16_t)(quo&0xffff);
			reg_DX_16u=rem;
			reg_AX_16u=quo16;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo16&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY16(rem)^PARITY16(quo16));
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			int32_t val=*(int16_t*)(target);
			int32_t num=(int32_t)(((uint32_t)reg_DX_16<<16u)|(unsigned int)reg_AX_16);
			int32_t quo=num/val;
			int16_t rem=(int16_t)(num % val);
			int16_t quo16s=(int16_t)(quo&0xffff);
			reg_DX_16u=(uint16_t)rem;
			reg_AX_16u=(uint16_t)quo16s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo16s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY16(rem&0xffff)^PARITY16(quo16s&0xffff)^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Flag CF set false
void handlerCommand16Code00F8_RM() {
	LOG("%s","Flag CF set false");
	SET_FLAG(CF, 0);
}
//Flag CF set true
void handlerCommand16Code00F9_RM() {
	LOG("%s","Flag CF set true");
	SET_FLAG(CF, 1);
}
//Flag IF set false
void handlerCommand16Code00FA_RM() {
	LOG("%s","Flag IF set false");
	SET_FLAG(IF, 0);
}
//Flag IF set true
void handlerCommand16Code00FB_RM() {
	LOG("%s","Flag IF set true");
	SET_FLAG(IF, 1);
}
//Flag DF set false
void handlerCommand16Code00FC_RM() {
	LOG("%s","Flag DF set false");
	SET_FLAG(DF, 0);
}
//Flag DF set true
void handlerCommand16Code00FD_RM() {
	LOG("%s","Flag DF set true");
	SET_FLAG(DF, 1);
}
//Inc/Dec
void handlerCommand16Code00FE_RM() {
	LOG("%s","Inc/Dec");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			(*(uint8_t*)target) += 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_INC8;
		}
		break;
		case 0x01: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			(*(uint8_t*)target) -= 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_DEC8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand16Code00FFP66P67_RM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			(*(uint32_t*)target)++;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_INC32;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			(*(uint32_t*)target)--;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_DEC32;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint16_t* sp = register16u(BR_SP);
			*sp -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint16_t newIP = *(uint16_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 16 / 8);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int32_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *(uint16_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand16Code00FFP67_RM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			(*(uint16_t*)target)++;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_INC16;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			(*(uint16_t*)target)--;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_DEC16;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t* sp = register16u(BR_SP);
			*sp -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t newIP = *(uint16_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 16 / 8);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int16_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *(uint16_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand16Code00FFP66_RM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			(*(uint32_t*)target)++;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_INC32;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			(*(uint32_t*)target)--;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_DEC32;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint16_t* sp = register16u(BR_SP);
			*sp -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint16_t newIP = *(uint16_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 16 / 8);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int32_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *(uint16_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand16Code00FF_RM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			(*(uint16_t*)target)++;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_INC16;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			(*(uint16_t*)target)--;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_DEC16;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t* sp = register16u(BR_SP);
			*sp -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t newIP = *(uint16_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 16 / 8);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int16_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *(uint16_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//???
void handlerCommand16Code0101_RM() {
	LOG("%s","???");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			*(uint16_t*)target = 0x0019;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//J(cond)
void handlerCommand16Code0180_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x00 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0181_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x01 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0182_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x02 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0183_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x03 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0184_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x04 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0185_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x05 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0186_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x06 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0187_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x07 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0188_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x08 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0189_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x09 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018A_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0A {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018B_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0B {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018C_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0C {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018D_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0D {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018E_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0E {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018F_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0F {
		context.index += address;
	}
}
//Math
void handlerCommand16Code0190P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x00;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x00 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0190_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x00;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x00 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0191P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x01;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x01 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0191_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x01;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x01 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0192P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x02;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x02 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0192_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x02;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x02 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0193P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x03;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x03 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0193_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x03;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x03 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0194P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x04;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x04 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0194_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x04;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x04 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0195P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x05;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x05 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0195_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x05;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x05 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0196P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x06;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x06 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0196_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x06;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x06 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0197P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x07;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x07 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0197_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x07;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x07 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0198P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x08;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x08 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0198_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x08;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x08 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0199P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x09;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x09 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0199_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x09;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x09 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019AP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0A;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0A ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019A_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0A;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0A ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019BP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0B;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0B ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019B_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0B;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0B ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019CP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0C;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0C ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019C_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0C;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0C ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019DP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0D;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0D ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019D_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0D;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0D ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019EP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0E;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0E ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019E_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0E;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0E ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019FP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0F;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0F ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019F_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0F;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0F ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//BT
void handlerCommand16Code01A3P66_RM() {
	LOG("%s","BT");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BT
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
}
//BT
void handlerCommand16Code01A3_RM() {
	LOG("%s","BT");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BT
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
}
//BTS
void handlerCommand16Code01ABP66_RM() {
	LOG("%s","BTS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTS
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
}
//BTS
void handlerCommand16Code01AB_RM() {
	LOG("%s","BTS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTS
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
}
//Mul
void handlerCommand16Code01AFP66_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = *(int32_t*)source;
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Mul
void handlerCommand16Code01AF_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = *(int16_t*)source;
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Load SR_SS
void handlerCommand16Code01B2_RM() {
	LOG("%s","Load SR_SS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_SS, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//BTR
void handlerCommand16Code01B3P66_RM() {
	LOG("%s","BTR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTR
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
}
//BTR
void handlerCommand16Code01B3_RM() {
	LOG("%s","BTR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTR
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
}
//Load SR_FS
void handlerCommand16Code01B4_RM() {
	LOG("%s","Load SR_FS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_FS, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//Load SR_GS
void handlerCommand16Code01B5_RM() {
	LOG("%s","Load SR_GS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_GS, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//MOVZX
void handlerCommand16Code01B6P66_RM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	*target = (uint32_t)*source;
}
//MOVZX
void handlerCommand16Code01B6_RM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint16_t* target = (uint16_t*)readRegisterMRM16(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	*target = (uint16_t)*source;
}
//MOVZX
void handlerCommand16Code01B7P66_RM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint16_t* source = (uint16_t*)readAddressMRM32For16(mrmByte);
	*target = (uint32_t)*source;
}
//MOVZX
void handlerCommand16Code01B7_RM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint16_t* source = (uint16_t*)readAddressMRM32For16(mrmByte);
	*target = (uint32_t)*source;
}
//Bit scan
void handlerCommand16Code01BAP66_RM() {
	LOG("%s","Bit scan");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BT
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTS
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTR
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTC
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			if (value) {
				(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
			} else {
				(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Bit scan
void handlerCommand16Code01BA_RM() {
	LOG("%s","Bit scan");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BT
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTS
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTR
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTC
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			if (value) {
				(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
			} else {
				(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//BTC
void handlerCommand16Code01BBP66_RM() {
	LOG("%s","BTC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTC
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	if (value) {
		(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
	} else {
		(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
	}
}
//BTC
void handlerCommand16Code01BB_RM() {
	LOG("%s","BTC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTC
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	if (value) {
		(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
	} else {
		(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
	}
}
//BFC
void handlerCommand16Code01BCP66_RM() {
	LOG("%s","BFC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	FillFlags();
	uint32_t value = *(uint32_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint32_t mask = 1;
	uint32_t len = 0;
	while ((mask & value) && (len < 32)) {
		value = value >> 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint32_t*)target = len;
}
//BFC
void handlerCommand16Code01BC_RM() {
	LOG("%s","BFC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	FillFlags();
	uint16_t value = *(uint16_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint16_t mask = 1;
	uint16_t len = 0;
	while ((mask & value) && (len < 16)) {
		value = value >> 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint16_t*)target = len;
}
//BSR
void handlerCommand16Code01BDP66_RM() {
	LOG("%s","BSR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	FillFlags();
	uint32_t value = *(uint32_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint32_t mask = 1 << (32 - 1);
	uint32_t len = 0;
	while ((mask & value) && (len < 32)) {
		value = value << 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint32_t*)target = len;
}
//BSR
void handlerCommand16Code01BD_RM() {
	LOG("%s","BSR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	FillFlags();
	uint16_t value = *(uint16_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint16_t mask = 1 << (16 - 1);
	uint16_t len = 0;
	while ((mask & value) && (len < 16)) {
		value = value << 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint16_t*)target = len;
}
//MOVSX
void handlerCommand16Code01BEP66_RM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int32_t* target = (int32_t*)readRegisterMRM32(mrmByte);
	int8_t* source = (int8_t*)readAddressMRM32For8(mrmByte);
	*target = (int32_t)*source;
}
//MOVSX
void handlerCommand16Code01BE_RM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int16_t* target = (int16_t*)readRegisterMRM16(mrmByte);
	int8_t* source = (int8_t*)readAddressMRM32For8(mrmByte);
	*target = (int16_t)*source;
}
//MOVSX
void handlerCommand16Code01BF_RM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int32_t* target = (int32_t*)readRegisterMRM32(mrmByte);
	int16_t* source = (int16_t*)readAddressMRM32For16(mrmByte);
	*target = (int32_t)*source;
}
//Swap
void handlerCommand16Code01C8_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01C9_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CA_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CB_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CC_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CD_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CE_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CF_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//ADD
void handlerCommand32Code0000P66_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0000_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0001P66_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_ADD16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand32Code0001_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_ADD32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand32Code0002P66_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0002_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0003P66_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_ADD16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand32Code0003_RM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_ADD32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand32Code0004P66_RM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_ADD8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0004_RM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_ADD8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0005P66_RM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_ADD16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand32Code0005_RM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_ADD32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//Push
void handlerCommand32Code0006_RM() {
	LOG("%s","Push");
	uint8_t rg = 0x00;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(rg);
}
//Push
void handlerCommand32Code000E_RM() {
	LOG("%s","Push");
	uint8_t rg = 0x01;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(rg);
}
//Push
void handlerCommand32Code0016_RM() {
	LOG("%s","Push");
	uint8_t rg = 0x02;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(rg);
}
//Push
void handlerCommand32Code001E_RM() {
	LOG("%s","Push");
	uint8_t rg = 0x03;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(rg);
}
//Pop
void handlerCommand32Code0007_RM() {
	LOG("%s","Pop");
	uint8_t rg = 0x00;
	    SET_VALUE_IN_SEGMENT(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	    reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code000F_RM() {
	LOG("%s","Pop");
	uint8_t rg = 0x01;
	// 0f???
}
//Pop
void handlerCommand32Code0017_RM() {
	LOG("%s","Pop");
	uint8_t rg = 0x02;
	    SET_VALUE_IN_SEGMENT(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	    reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code001F_RM() {
	LOG("%s","Pop");
	uint8_t rg = 0x03;
	    SET_VALUE_IN_SEGMENT(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	    reg_SP_32u += 16 / 8;
}
//OR
void handlerCommand32Code0008P66_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code0008_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code0009P66_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_OR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand32Code0009_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_OR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand32Code000AP66_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code000A_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code000BP66_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_OR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand32Code000B_RM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_OR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand32Code000CP66_RM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_OR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code000C_RM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_OR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code000DP66_RM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_OR16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand32Code000D_RM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_OR32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand32Code0010P66_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0010_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0011P66_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
	lazyFlagType = t_ADC16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand32Code0011_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
	lazyFlagType = t_ADC32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand32Code0012P66_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0012_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0013P66_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
	lazyFlagType = t_ADC16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand32Code0013_RM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
	lazyFlagType = t_ADC32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand32Code0014P66_RM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) + oldcf;
	lazyFlagType = t_ADC8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0014_RM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) + oldcf;
	lazyFlagType = t_ADC8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0015P66_RM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16)) + oldcf;
	lazyFlagType = t_ADC16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand32Code0015_RM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32)) + oldcf;
	lazyFlagType = t_ADC32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand32Code0018P66_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code0018_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code0019P66_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
	lazyFlagType = t_SBB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand32Code0019_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
	lazyFlagType = t_SBB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand32Code001AP66_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code001A_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code001BP66_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
	lazyFlagType = t_SBB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand32Code001B_RM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
	lazyFlagType = t_SBB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand32Code001CP66_RM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) - oldcf;
	lazyFlagType = t_SBB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code001C_RM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) - oldcf;
	lazyFlagType = t_SBB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code001DP66_RM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) - oldcf;
	lazyFlagType = t_SBB16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand32Code001D_RM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) - oldcf;
	lazyFlagType = t_SBB32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand32Code0020P66_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0020_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0021P66_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_AND16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand32Code0021_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_AND32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand32Code0022P66_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0022_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0023P66_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_AND16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand32Code0023_RM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_AND32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand32Code0024P66_RM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_AND8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0024_RM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_AND8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0025P66_RM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_AND16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand32Code0025_RM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_AND32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand32Code0028P66_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code0028_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code0029P66_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_SUB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand32Code0029_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_SUB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand32Code002AP66_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code002A_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code002BP66_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_SUB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand32Code002B_RM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_SUB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand32Code002CP66_RM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_SUB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code002C_RM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_SUB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code002DP66_RM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_SUB16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand32Code002D_RM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_SUB32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand32Code0030P66_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0030_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0031P66_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_XOR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand32Code0031_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_XOR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand32Code0032P66_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0032_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0033P66_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_XOR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand32Code0033_RM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_XOR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand32Code0034P66_RM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_XOR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0034_RM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_XOR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0035P66_RM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_XOR16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand32Code0035_RM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_XOR32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//CMP
void handlerCommand32Code0038P66_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code0038_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code0039P66_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand32Code0039_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand32Code003AP66_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code003A_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code003BP66_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand32Code003B_RM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand32Code003CP66_RM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code003C_RM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code003DP66_RM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand32Code003D_RM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_CMP32;
}
//Inc
void handlerCommand32Code0040P66_RM() {
	LOG("%s","Inc");
	reg_0x00_16u += 1;
	LazyFlagResultContainer16 = reg_0x00_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0040_RM() {
	LOG("%s","Inc");
	reg_0x00_32u += 1;
	LazyFlagResultContainer32 = reg_0x00_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0041P66_RM() {
	LOG("%s","Inc");
	reg_0x01_16u += 1;
	LazyFlagResultContainer16 = reg_0x01_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0041_RM() {
	LOG("%s","Inc");
	reg_0x01_32u += 1;
	LazyFlagResultContainer32 = reg_0x01_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0042P66_RM() {
	LOG("%s","Inc");
	reg_0x02_16u += 1;
	LazyFlagResultContainer16 = reg_0x02_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0042_RM() {
	LOG("%s","Inc");
	reg_0x02_32u += 1;
	LazyFlagResultContainer32 = reg_0x02_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0043P66_RM() {
	LOG("%s","Inc");
	reg_0x03_16u += 1;
	LazyFlagResultContainer16 = reg_0x03_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0043_RM() {
	LOG("%s","Inc");
	reg_0x03_32u += 1;
	LazyFlagResultContainer32 = reg_0x03_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0044P66_RM() {
	LOG("%s","Inc");
	reg_0x04_16u += 1;
	LazyFlagResultContainer16 = reg_0x04_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0044_RM() {
	LOG("%s","Inc");
	reg_0x04_32u += 1;
	LazyFlagResultContainer32 = reg_0x04_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0045P66_RM() {
	LOG("%s","Inc");
	reg_0x05_16u += 1;
	LazyFlagResultContainer16 = reg_0x05_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0045_RM() {
	LOG("%s","Inc");
	reg_0x05_32u += 1;
	LazyFlagResultContainer32 = reg_0x05_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0046P66_RM() {
	LOG("%s","Inc");
	reg_0x06_16u += 1;
	LazyFlagResultContainer16 = reg_0x06_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0046_RM() {
	LOG("%s","Inc");
	reg_0x06_32u += 1;
	LazyFlagResultContainer32 = reg_0x06_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0047P66_RM() {
	LOG("%s","Inc");
	reg_0x07_16u += 1;
	LazyFlagResultContainer16 = reg_0x07_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0047_RM() {
	LOG("%s","Inc");
	reg_0x07_32u += 1;
	LazyFlagResultContainer32 = reg_0x07_32u;
	lazyFlagType = t_INC32;
}
//Dec
void handlerCommand32Code0048P66_RM() {
	LOG("%s","Dec");
	reg_0x00_16u -= 1;
	LazyFlagResultContainer16 = reg_0x00_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code0048_RM() {
	LOG("%s","Dec");
	reg_0x00_32u -= 1;
	LazyFlagResultContainer32 = reg_0x00_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code0049P66_RM() {
	LOG("%s","Dec");
	reg_0x01_16u -= 1;
	LazyFlagResultContainer16 = reg_0x01_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code0049_RM() {
	LOG("%s","Dec");
	reg_0x01_32u -= 1;
	LazyFlagResultContainer32 = reg_0x01_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004AP66_RM() {
	LOG("%s","Dec");
	reg_0x02_16u -= 1;
	LazyFlagResultContainer16 = reg_0x02_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004A_RM() {
	LOG("%s","Dec");
	reg_0x02_32u -= 1;
	LazyFlagResultContainer32 = reg_0x02_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004BP66_RM() {
	LOG("%s","Dec");
	reg_0x03_16u -= 1;
	LazyFlagResultContainer16 = reg_0x03_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004B_RM() {
	LOG("%s","Dec");
	reg_0x03_32u -= 1;
	LazyFlagResultContainer32 = reg_0x03_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004CP66_RM() {
	LOG("%s","Dec");
	reg_0x04_16u -= 1;
	LazyFlagResultContainer16 = reg_0x04_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004C_RM() {
	LOG("%s","Dec");
	reg_0x04_32u -= 1;
	LazyFlagResultContainer32 = reg_0x04_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004DP66_RM() {
	LOG("%s","Dec");
	reg_0x05_16u -= 1;
	LazyFlagResultContainer16 = reg_0x05_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004D_RM() {
	LOG("%s","Dec");
	reg_0x05_32u -= 1;
	LazyFlagResultContainer32 = reg_0x05_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004EP66_RM() {
	LOG("%s","Dec");
	reg_0x06_16u -= 1;
	LazyFlagResultContainer16 = reg_0x06_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004E_RM() {
	LOG("%s","Dec");
	reg_0x06_32u -= 1;
	LazyFlagResultContainer32 = reg_0x06_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004FP66_RM() {
	LOG("%s","Dec");
	reg_0x07_16u -= 1;
	LazyFlagResultContainer16 = reg_0x07_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004F_RM() {
	LOG("%s","Dec");
	reg_0x07_32u -= 1;
	LazyFlagResultContainer32 = reg_0x07_32u;
	lazyFlagType = t_DEC32;
}
//Push
void handlerCommand32Code0050P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint16_t value = reg_0x00_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0050P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0050P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint16_t value = reg_0x00_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0050_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0051P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint16_t value = reg_0x01_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0051P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0051P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint16_t value = reg_0x01_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0051_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0052P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint16_t value = reg_0x02_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0052P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0052P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint16_t value = reg_0x02_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0052_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0053P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint16_t value = reg_0x03_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0053P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0053P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint16_t value = reg_0x03_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0053_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0054P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint16_t value = reg_0x04_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0054P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0054P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint16_t value = reg_0x04_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0054_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0055P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint16_t value = reg_0x05_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0055P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0055P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint16_t value = reg_0x05_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0055_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0056P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint16_t value = reg_0x06_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0056P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0056P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint16_t value = reg_0x06_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0056_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0057P66P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint16_t value = reg_0x07_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0057P67_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0057P66_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint16_t value = reg_0x07_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0057_RM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Pop
void handlerCommand32Code0058P66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code0058P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code0058P66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code0058_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code0059P66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code0059P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code0059P66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code0059_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005AP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005AP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005AP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005A_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005BP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005BP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005BP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005B_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005CP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005CP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005CP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005C_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005DP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005DP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005DP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005D_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005EP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005EP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005EP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005E_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005FP66P67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005FP67_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005FP66_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005F_RM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//PUSHA
void handlerCommand32Code0060P66_RM() {
	LOG("%s","PUSHA");
	uint16_t tmp = reg_SP_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_AX_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_CX_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_DX_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BX_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = tmp;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SI_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_DI_16u;
}
//PUSHA
void handlerCommand32Code0060_RM() {
	LOG("%s","PUSHA");
	uint32_t tmp = reg_SP_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_AX_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_CX_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_DX_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BX_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = tmp;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SI_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_DI_32u;
}
//POPA
void handlerCommand32Code0061P66_RM() {
	LOG("%s","POPA");
	reg_DI_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_SI_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_BP_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_SP_32u += 16 / 8;
	reg_BX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_DX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_CX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_AX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//POPA
void handlerCommand32Code0061_RM() {
	LOG("%s","POPA");
	reg_DI_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_SI_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_BP_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_SP_32u += 32 / 8;
	reg_BX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_DX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_CX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_AX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Push
void handlerCommand32Code0068P66P67_RM() {
	LOG("%s","Push");
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = read16u();
}
//Push
void handlerCommand32Code0068P67_RM() {
	LOG("%s","Push");
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = read32u();
}
//Push
void handlerCommand32Code0068P66_RM() {
	LOG("%s","Push");
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = read16u();
}
//Push
void handlerCommand32Code0068_RM() {
	LOG("%s","Push");
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = read32u();
}
//Mul
void handlerCommand32Code0069P66_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = read16();
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Mul
void handlerCommand32Code0069_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = read32();
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Push
void handlerCommand32Code006AP66P67_RM() {
	LOG("%s","Push");
	reg_SP_16u -= 16 / 8;
	*(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = (int16_t)read8();
}
//Push
void handlerCommand32Code006AP67_RM() {
	LOG("%s","Push");
	reg_SP_16u -= 32 / 8;
	*(int32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = (int32_t)read8();
}
//Push
void handlerCommand32Code006AP66_RM() {
	LOG("%s","Push");
	reg_SP_32u -= 16 / 8;
	*(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = (int16_t)read8();
}
//Push
void handlerCommand32Code006A_RM() {
	LOG("%s","Push");
	reg_SP_32u -= 32 / 8;
	*(int32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = (int32_t)read8();
}
//Mul
void handlerCommand32Code006B_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = (int32_t)read8();
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//J(cond)
void handlerCommand32Code0070_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x00 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0071_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x01 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0072_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x02 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0073_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x03 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0074_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x04 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0075_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x05 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0076_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x06 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0077_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x07 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0078_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x08 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0079_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x09 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007A_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0A {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007B_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0B {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007C_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0C {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007D_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0D {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007E_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0E {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007F_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0F {
		context.index += address;
	}
}
//Math
void handlerCommand32Code0080P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0080_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0081P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_ADD16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_OR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
			lazyFlagType = t_ADC16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
			lazyFlagType = t_SBB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_AND16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_SUB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_XOR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_CMP16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0081_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_ADD32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_OR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
			lazyFlagType = t_ADC32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
			lazyFlagType = t_SBB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_AND32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_SUB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_XOR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_CMP32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0082_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) + ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) | ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) + ((int8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) & ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) ^ ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0083P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) + ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_ADD16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) | ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_OR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) + ((int16_t)LazyFlagVarB16) + oldcf;
			lazyFlagType = t_ADC16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) - oldcf;
			lazyFlagType = t_SBB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) & ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_AND16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_SUB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) ^ ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_XOR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_CMP16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0083_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) + ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_ADD32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) | ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_OR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) + ((int32_t)LazyFlagVarB32) + oldcf;
			lazyFlagType = t_ADC32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) - oldcf;
			lazyFlagType = t_SBB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) & ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_AND32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_SUB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) ^ ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_XOR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_CMP32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//TEST
void handlerCommand32Code0084P66_RM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand32Code0084_RM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand32Code0085P66_RM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_TEST16;
}
//TEST
void handlerCommand32Code0085_RM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_TEST32;
}
//XCHG
void handlerCommand32Code0086P66_RM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t tmp = *(uint32_t*)target;
	*(uint32_t*)target = *(uint32_t*)source;
	*(uint32_t*)source = tmp;
}
//XCHG
void handlerCommand32Code0086_RM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t tmp = *(uint32_t*)target;
	*(uint32_t*)target = *(uint32_t*)source;
	*(uint32_t*)source = tmp;
}
//XCHG
void handlerCommand32Code0087P66_RM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t tmp = *(uint32_t*)target;
	*(uint32_t*)target = *(uint32_t*)source;
	*(uint32_t*)source = tmp;
}
//XCHG
void handlerCommand32Code0087_RM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t tmp = *(uint32_t*)target;
	*(uint32_t*)target = *(uint32_t*)source;
	*(uint32_t*)source = tmp;
}
//Move
void handlerCommand32Code0088P66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code0088_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code0089P66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code0089_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code008AP66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code008A_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code008BP66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code008B_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code008C_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t sr = readMiddle3Bit(mrmByte);
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readSegmentRegisterMRM;
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code008E_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t sr = readMiddle3Bit(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readSegmentRegisterMRM;
	*(uint16_t*)target = *(uint16_t*)source;
	recalculatePointerSegmentRegisterMRM
}
//Lea
void handlerCommand32Code008DP66P67_RM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint32_t target = effectiveAddressMRM32For32(mrmByte);
	*((uint16_t*)source) = (uint16_t)(target & 0xFFFF);
}
//Lea
void handlerCommand32Code008DP67_RM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t target = effectiveAddressMRM32For32(mrmByte);
	*((uint32_t*)source) = (uint32_t)(target & 0xFFFFFFFF);
}
//Lea
void handlerCommand32Code008DP66_RM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint32_t target = effectiveAddressMRM32For32(mrmByte);
	*((uint16_t*)source) = (uint16_t)(target & 0xFFFF);
}
//Lea
void handlerCommand32Code008D_RM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t target = effectiveAddressMRM32For32(mrmByte);
	*((uint32_t*)source) = (uint32_t)(target & 0xFFFFFFFF);
}
//Pop
void handlerCommand32Code008FP66P67_RM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			*(uint16_t*)target = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
			reg_SP_16u += 16 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand32Code008FP67_RM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			*(uint32_t*)target = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
			reg_SP_16u += 32 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand32Code008FP66_RM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			*(uint16_t*)target = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
			reg_SP_32u += 16 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand32Code008F_RM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			*(uint32_t*)target = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
			reg_SP_32u += 32 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//XCHG
void handlerCommand32Code0090P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x00;
	// NOP
}
//XCHG
void handlerCommand32Code0090_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x00;
	// NOP
}
//XCHG
void handlerCommand32Code0091P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x01;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x01_32u;
	reg_0x01_32u = tmp;
}
//XCHG
void handlerCommand32Code0091_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x01;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x01_32u;
	reg_0x01_32u = tmp;
}
//XCHG
void handlerCommand32Code0092P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x02;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x02_32u;
	reg_0x02_32u = tmp;
}
//XCHG
void handlerCommand32Code0092_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x02;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x02_32u;
	reg_0x02_32u = tmp;
}
//XCHG
void handlerCommand32Code0093P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x03;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x03_32u;
	reg_0x03_32u = tmp;
}
//XCHG
void handlerCommand32Code0093_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x03;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x03_32u;
	reg_0x03_32u = tmp;
}
//XCHG
void handlerCommand32Code0094P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x04;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x04_32u;
	reg_0x04_32u = tmp;
}
//XCHG
void handlerCommand32Code0094_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x04;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x04_32u;
	reg_0x04_32u = tmp;
}
//XCHG
void handlerCommand32Code0095P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x05;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x05_32u;
	reg_0x05_32u = tmp;
}
//XCHG
void handlerCommand32Code0095_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x05;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x05_32u;
	reg_0x05_32u = tmp;
}
//XCHG
void handlerCommand32Code0096P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x06;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x06_32u;
	reg_0x06_32u = tmp;
}
//XCHG
void handlerCommand32Code0096_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x06;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x06_32u;
	reg_0x06_32u = tmp;
}
//XCHG
void handlerCommand32Code0097P66_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x07;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x07_32u;
	reg_0x07_32u = tmp;
}
//XCHG
void handlerCommand32Code0097_RM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x07;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x07_32u;
	reg_0x07_32u = tmp;
}
//CBW
void handlerCommand32Code0098P66_RM() {
	LOG("%s","CBW");
	reg_AX_16 = reg_AL_8;
}
//CBW
void handlerCommand32Code0098_RM() {
	LOG("%s","CBW");
	reg_AX_32 = reg_AX_16;
}
//CBW
void handlerCommand32Code0099P66_RM() {
	LOG("%s","CBW");
	if (reg_AX_16 & 0x8000) reg_DX_16=0xffff;else reg_DX_16=0;
}
//CBW
void handlerCommand32Code0099_RM() {
	LOG("%s","CBW");
	if (reg_AX_32 & 0x80000000) reg_DX_32=0xffffffff; else reg_DX_32=0;
}
//Call
void handlerCommand32Code009A_RM() {
	LOG("%s","Call");
	uint32_t newIP = read32u();
	uint16_t newCS = read16u();
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
	SET_VALUE_IN_SEGMENT(SR_CS, newCS);
	context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
}
//PUSHF
void handlerCommand32Code009CP66_RM() {
	LOG("%s","PUSHF");
	FillFlags();
	reg_SP_32u -= 16 / 8;
	EncodeFlagsRegister();
	uint32_t value = reg_flags & 0xFCFFFF;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *((uint16_t*)&value);
}
//PUSHF
void handlerCommand32Code009C_RM() {
	LOG("%s","PUSHF");
	FillFlags();
	reg_SP_32u -= 32 / 8;
	EncodeFlagsRegister();
	uint32_t value = reg_flags & 0xFCFFFF;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *((uint32_t*)&value);
}
//POPF
void handlerCommand32Code009DP66_RM() {
	LOG("%s","POPF");
	lazyFlagType = t_UNKNOWN;
	*(uint16_t*)(&reg_flags) = (*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	reg_SP_32u += 16 / 8;
	DecodeFlagsRegister16();
}
//POPF
void handlerCommand32Code009D_RM() {
	LOG("%s","POPF");
	lazyFlagType = t_UNKNOWN;
	*(uint32_t*)(&reg_flags) = (*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	reg_SP_32u += 32 / 8;
	DecodeFlagsRegister32();
}
//Move
void handlerCommand32Code00A0P66P67_RM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A0P66_RM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A0P67_RM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A0_RM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A1P66P67_RM() {
	LOG("%s","Move");
	uint16_t* target = (uint16_t*)register16u(BR_AX);
	uint16_t* source = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code00A1P66_RM() {
	LOG("%s","Move");
	uint16_t* target = (uint16_t*)register16u(BR_AX);
	uint16_t* source = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code00A1P67_RM() {
	LOG("%s","Move");
	uint32_t* target = (uint32_t*)register32u(BR_AX);
	uint32_t* source = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code00A1_RM() {
	LOG("%s","Move");
	uint32_t* target = (uint32_t*)register32u(BR_AX);
	uint32_t* source = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code00A2P66P67_RM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A2P66_RM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A2P67_RM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A2_RM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A3P66P67_RM() {
	LOG("%s","Move");
	uint16_t* source = (uint16_t*)register16u(BR_AX);
	uint16_t* target = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code00A3P66_RM() {
	LOG("%s","Move");
	uint16_t* source = (uint16_t*)register16u(BR_AX);
	uint16_t* target = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code00A3P67_RM() {
	LOG("%s","Move");
	uint32_t* source = (uint32_t*)register32u(BR_AX);
	uint32_t* target = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code00A3_RM() {
	LOG("%s","Move");
	uint32_t* source = (uint32_t*)register32u(BR_AX);
	uint32_t* target = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint32_t*)target = *(uint32_t*)source;
}
//MOVS
void handlerCommand32Code00A4P66P67_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A4P66_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A4P67_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A4_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A5P66P67_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A5P66_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A5P67_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A5_RM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A6P66P67_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A6P66_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A6P67_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A6_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A7P66P67_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A7P66_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A7P67_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A7_RM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
		}
	}
}
//TEST
void handlerCommand32Code00A8P66_RM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand32Code00A8_RM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand32Code00A9P66_RM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_TEST16;
}
//TEST
void handlerCommand32Code00A9_RM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_TEST32;
}
//STOS
void handlerCommand32Code00AAP66P67_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00AAP66_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00AAP67_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00AA_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00ABP66P67_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
			reg_DI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
			reg_DI_16u += 16 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00ABP66_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
			reg_DI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
			reg_DI_32u += 16 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00ABP67_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
			reg_DI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
			reg_DI_16u += 32 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00AB_RM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
			reg_DI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
			reg_DI_32u += 32 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ACP66P67_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ACP66_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ACP67_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00AC_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ADP66P67_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 16 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ADP66_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 16 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ADP67_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 32 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00AD_RM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 32 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AEP66P67_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AEP66_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AEP67_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AE_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AFP66P67_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u += 16 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AFP66_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u += 16 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AFP67_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u += 32 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AF_RM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u += 32 / 8;
		}
	}
}
//Move
void handlerCommand32Code00B0P66_RM() {
	LOG("%s","Move");
	reg_0x00_8u = read8u();
}
//Move
void handlerCommand32Code00B0_RM() {
	LOG("%s","Move");
	reg_0x00_8u = read8u();
}
//Move
void handlerCommand32Code00B1P66_RM() {
	LOG("%s","Move");
	reg_0x01_8u = read8u();
}
//Move
void handlerCommand32Code00B1_RM() {
	LOG("%s","Move");
	reg_0x01_8u = read8u();
}
//Move
void handlerCommand32Code00B2P66_RM() {
	LOG("%s","Move");
	reg_0x02_8u = read8u();
}
//Move
void handlerCommand32Code00B2_RM() {
	LOG("%s","Move");
	reg_0x02_8u = read8u();
}
//Move
void handlerCommand32Code00B3P66_RM() {
	LOG("%s","Move");
	reg_0x03_8u = read8u();
}
//Move
void handlerCommand32Code00B3_RM() {
	LOG("%s","Move");
	reg_0x03_8u = read8u();
}
//Move
void handlerCommand32Code00B4P66_RM() {
	LOG("%s","Move");
	reg_0x04_8u = read8u();
}
//Move
void handlerCommand32Code00B4_RM() {
	LOG("%s","Move");
	reg_0x04_8u = read8u();
}
//Move
void handlerCommand32Code00B5P66_RM() {
	LOG("%s","Move");
	reg_0x05_8u = read8u();
}
//Move
void handlerCommand32Code00B5_RM() {
	LOG("%s","Move");
	reg_0x05_8u = read8u();
}
//Move
void handlerCommand32Code00B6P66_RM() {
	LOG("%s","Move");
	reg_0x06_8u = read8u();
}
//Move
void handlerCommand32Code00B6_RM() {
	LOG("%s","Move");
	reg_0x06_8u = read8u();
}
//Move
void handlerCommand32Code00B7P66_RM() {
	LOG("%s","Move");
	reg_0x07_8u = read8u();
}
//Move
void handlerCommand32Code00B7_RM() {
	LOG("%s","Move");
	reg_0x07_8u = read8u();
}
//Move
void handlerCommand32Code00B8P66_RM() {
	LOG("%s","Move");
	reg_0x00_16u = read16u();
}
//Move
void handlerCommand32Code00B8_RM() {
	LOG("%s","Move");
	reg_0x00_32u = read32u();
}
//Move
void handlerCommand32Code00B9P66_RM() {
	LOG("%s","Move");
	reg_0x01_16u = read16u();
}
//Move
void handlerCommand32Code00B9_RM() {
	LOG("%s","Move");
	reg_0x01_32u = read32u();
}
//Move
void handlerCommand32Code00BAP66_RM() {
	LOG("%s","Move");
	reg_0x02_16u = read16u();
}
//Move
void handlerCommand32Code00BA_RM() {
	LOG("%s","Move");
	reg_0x02_32u = read32u();
}
//Move
void handlerCommand32Code00BBP66_RM() {
	LOG("%s","Move");
	reg_0x03_16u = read16u();
}
//Move
void handlerCommand32Code00BB_RM() {
	LOG("%s","Move");
	reg_0x03_32u = read32u();
}
//Move
void handlerCommand32Code00BCP66_RM() {
	LOG("%s","Move");
	reg_0x04_16u = read16u();
}
//Move
void handlerCommand32Code00BC_RM() {
	LOG("%s","Move");
	reg_0x04_32u = read32u();
}
//Move
void handlerCommand32Code00BDP66_RM() {
	LOG("%s","Move");
	reg_0x05_16u = read16u();
}
//Move
void handlerCommand32Code00BD_RM() {
	LOG("%s","Move");
	reg_0x05_32u = read32u();
}
//Move
void handlerCommand32Code00BEP66_RM() {
	LOG("%s","Move");
	reg_0x06_16u = read16u();
}
//Move
void handlerCommand32Code00BE_RM() {
	LOG("%s","Move");
	reg_0x06_32u = read32u();
}
//Move
void handlerCommand32Code00BFP66_RM() {
	LOG("%s","Move");
	reg_0x07_16u = read16u();
}
//Move
void handlerCommand32Code00BF_RM() {
	LOG("%s","Move");
	reg_0x07_32u = read32u();
}
//Move bits
void handlerCommand32Code00C0P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00C0_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00C1P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00C1_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ret
void handlerCommand32Code00C2_RM() {
	LOG("%s","Ret");
	uint16_t stackValue = read16u();
	uint32_t* sp = register32u(BR_SP);
	context.index = GET_SEGMENT_POINTER(1) + *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (32 / 8);
	*sp += (stackValue * (32 / 16));
}
//Ret
void handlerCommand32Code00C3_RM() {
	LOG("%s","Ret");
	uint32_t* sp = register32u(BR_SP);
	context.index = GET_SEGMENT_POINTER(1) + *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (32 / 8);
}
//Load SR_ES
void handlerCommand32Code00C4_RM() {
	LOG("%s","Load SR_ES");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_ES, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//Load SR_DS
void handlerCommand32Code00C5_RM() {
	LOG("%s","Load SR_DS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_DS, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//Move
void handlerCommand32Code00C6P66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint8_t*)target = read8u();
}
//Move
void handlerCommand32Code00C6_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint8_t*)target = read8u();
}
//Move
void handlerCommand32Code00C7P66_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint16_t*)target = read16u();
}
//Move
void handlerCommand32Code00C7_RM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = read32u();
}
//Enter
void handlerCommand32Code00C8P66P67_RM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	uint16_t tmp = reg_SP_16u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_16u = reg_BP_16u - 16 / 8;
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
		}
		reg_SP_16u -= 16 / 8;
		*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SP_16u;
	}
	reg_BP_16u = tmp;
	reg_SP_16u = reg_BP_16u - size;
}
//Enter
void handlerCommand32Code00C8P67_RM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	uint16_t tmp = reg_SP_16u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_16u = reg_BP_16u - 32 / 8;
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
		}
		reg_SP_16u -= 16 / 8;
		*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SP_16u;
	}
	reg_BP_16u = tmp;
	reg_SP_16u = reg_BP_16u - size;
}
//Enter
void handlerCommand32Code00C8P66_RM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	uint32_t tmp = reg_SP_32u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_32u = reg_BP_32u - 16 / 8;
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
		}
		reg_SP_32u -= 32 / 8;
		*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SP_32u;
	}
	reg_BP_32u = tmp;
	reg_SP_32u = reg_BP_32u - size;
}
//Enter
void handlerCommand32Code00C8_RM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	uint32_t tmp = reg_SP_32u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_32u = reg_BP_32u - 32 / 8;
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
		}
		reg_SP_32u -= 32 / 8;
		*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SP_32u;
	}
	reg_BP_32u = tmp;
	reg_SP_32u = reg_BP_32u - size;
}
//Leave
void handlerCommand32Code00C9P66P67_RM() {
	LOG("%s","Leave");
	reg_SP_16u = reg_BP_16u;
	reg_BP_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Leave
void handlerCommand32Code00C9P67_RM() {
	LOG("%s","Leave");
	reg_SP_16u = reg_BP_16u;
	reg_BP_16u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Leave
void handlerCommand32Code00C9P66_RM() {
	LOG("%s","Leave");
	reg_SP_32u = reg_BP_32u;
	reg_BP_32u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Leave
void handlerCommand32Code00C9_RM() {
	LOG("%s","Leave");
	reg_SP_32u = reg_BP_32u;
	reg_BP_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Ret
void handlerCommand32Code00CA_RM() {
	LOG("%s","Ret");
	uint16_t stackValue = read16u();
	uint32_t* sp = register32u(BR_SP);
	SET_VALUE_IN_SEGMENT(1, *(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp + 32 / 8));
	context.index = GET_SEGMENT_POINTER(1) + *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (32 / 8 + 2);
	*sp += (stackValue * (32 / 16));
}
//Ret
void handlerCommand32Code00CB_RM() {
	LOG("%s","Ret");
	uint32_t* sp = register32u(BR_SP);
	SET_VALUE_IN_SEGMENT(1, *(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp + 32 / 8));
	context.index = GET_SEGMENT_POINTER(1) + *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (32 / 8 + 2);
}
//Int
void handlerCommand32Code00CD_RM() {
	LOG("%s","Int");
	uint8_t *target = GET_REAL_MOD_MEMORY_POINTER(0) + (read8u() * (2 + 2));
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
	SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
	context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
}
//Move bits
void handlerCommand32Code00D0P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D0_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D1P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D1_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D2P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D2_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D3P66_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D3_RM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00D8_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 000, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 000, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 000, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 000, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 000, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 000, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00D9_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 001, OPB 000
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = *source;
			} else {
				// OPA 001, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 001, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 001, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				fpuRegControll = *(uint16_t*)readAddressMRM32For16(mrmByte);
			} else {
				fpuRegControll = *(uint16_t*)readAddressMRM32For16(mrmByte);
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM32For16(mrmByte) = fpuRegControll;
			} else {
				*(uint16_t*)readAddressMRM32For16(mrmByte) = fpuRegControll;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DA_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DB_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				fpuStackIndex = 7;
				fpuRegControll = 0x37F;
				fpuRegStatus = 0;
				fpuRegTag = 0xFFFF;
				fpuRegPointer = 0;
				fpuRegInstructionPointer = 0;
				fpuRegInstructionOpcode = 0;
			} else {
				fpuStackIndex = 7;
				fpuRegControll = 0x37F;
				fpuRegStatus = 0;
				fpuRegTag = 0xFFFF;
				fpuRegPointer = 0;
				fpuRegInstructionPointer = 0;
				fpuRegInstructionOpcode = 0;
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM32For16(mrmByte) = fpuRegControll;
			} else {
				*(uint16_t*)readAddressMRM32For16(mrmByte) = fpuRegControll;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DC_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 100, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 100, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 100, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 100, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 100, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 100, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DD_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegStatus;
			} else {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegStatus;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DE_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 110, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 110, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 110, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 110, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 110, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 110, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DF_RM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Loop
void handlerCommand32Code00E0_RM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_32 -= 1;
	FillFlags();
	if (reg_0x01_32 != 0 && GET_FLAG(ZF) == 0) {
		context.index += addr;
	}
}
//Loop
void handlerCommand32Code00E1_RM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_32 -= 1;
	FillFlags();
	if (reg_0x01_32 != 0 && GET_FLAG(ZF) == 1) {
		context.index += addr;
	}
}
//Loop
void handlerCommand32Code00E2_RM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_32 -= 1;
	if (reg_0x01_32 != 0) {
		context.index += addr;
	}
}
//Loop
void handlerCommand32Code00E3_RM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	if (reg_0x01_32 == 0) {
		context.index += addr;
	}
}
//In
void handlerCommand32Code00E4P66_RM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand32Code00E4_RM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand32Code00E5P66_RM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//In
void handlerCommand32Code00E5_RM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Out
void handlerCommand32Code00E6P66_RM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand32Code00E6_RM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand32Code00E7P66_RM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Out
void handlerCommand32Code00E7_RM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Call
void handlerCommand32Code00E8P66_RM() {
	LOG("%s","Call");
	uint32_t* sp = register32u(BR_SP);
	*sp -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index + 16 / 8 - GET_SEGMENT_POINTER(1));
	context.index += read16();
}
//Call
void handlerCommand32Code00E8_RM() {
	LOG("%s","Call");
	uint32_t* sp = register32u(BR_SP);
	*sp -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index + 32 / 8 - GET_SEGMENT_POINTER(1));
	context.index += read32();
}
//Jmp
void handlerCommand32Code00E9P66_RM() {
	LOG("%s","Jmp");
	context.index += read16();
}
//Jmp
void handlerCommand32Code00E9_RM() {
	LOG("%s","Jmp");
	context.index += read32();
}
//Jmp
void handlerCommand32Code00EB_RM() {
	LOG("%s","Jmp");
	context.index += read8();
}
//In
void handlerCommand32Code00ECP66_RM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand32Code00EC_RM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand32Code00EDP66_RM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//In
void handlerCommand32Code00ED_RM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Out
void handlerCommand32Code00EEP66_RM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand32Code00EE_RM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand32Code00EFP66_RM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Out
void handlerCommand32Code00EF_RM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//External call
void handlerCommand32Code00F1_RM() {
	LOG("%s","External call");
	uint16_t addr = read16u();
	FillFlags();
	context.functions[addr](addr);
}
//~CF
void handlerCommand32Code00F5_RM() {
	LOG("%s","~CF");
	SET_FLAG(CF, !GET_FLAG(CF));
}
//Math
void handlerCommand32Code00F6P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// TEST
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = read8();
			LazyFlagResultContainer8 = LazyFlagVarA8 & ((uint8_t)LazyFlagVarB8);
			lazyFlagType = t_TEST8;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// NOT
			*(int8_t*)target = ~(*(int8_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// NEG
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagResultContainer8 = 0 - LazyFlagVarA8;
			*(int8_t*)target = LazyFlagResultContainer8;
			lazyFlagType = t_NEG8;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			reg_AX_16u=((uint16_t)reg_AL_8u)*((uint16_t)(*(uint8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AL_8 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16));
			if (reg_AX_16 & 0xff00) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			reg_AX_16 = reg_AL_8 * (*((int8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF, reg_AL_8 == 0);
			SET_FLAG(SF, reg_AL_8 & 0x80);
			if ((reg_AX_16 & 0xff80)==0xff80 || (reg_AX_16 & 0xff80)==0x0000) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t val= *(uint8_t*)(target);
			uint16_t quo = reg_AX_16u / val;
			uint8_t rem = (uint8_t)(reg_AX_16 % val);
			uint8_t quo8 = (uint8_t)(quo&0xff);
			reg_AH_8u=rem;
			reg_AL_8u=quo8;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem]^parity_lookup[quo8]);
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			int16_t val= *(int8_t*)(target);
			int16_t quo= ((int16_t)reg_AX_16) / val;
			int8_t rem=(int8_t)((int16_t)reg_AX_16 % val);
			int8_t quo8s=(int8_t)(quo&0xff);
			reg_AH_8=(uint8_t)rem;
			reg_AL_8=(uint8_t)quo8s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem&0xff]^parity_lookup[quo8s&0xff]^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code00F6_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// TEST
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = read8();
			LazyFlagResultContainer8 = LazyFlagVarA8 & ((uint8_t)LazyFlagVarB8);
			lazyFlagType = t_TEST8;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// NOT
			*(int8_t*)target = ~(*(int8_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// NEG
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagResultContainer8 = 0 - LazyFlagVarA8;
			*(int8_t*)target = LazyFlagResultContainer8;
			lazyFlagType = t_NEG8;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			reg_AX_16u=((uint16_t)reg_AL_8u)*((uint16_t)(*(uint8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AL_8 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16));
			if (reg_AX_16 & 0xff00) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			reg_AX_16 = reg_AL_8 * (*((int8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF, reg_AL_8 == 0);
			SET_FLAG(SF, reg_AL_8 & 0x80);
			if ((reg_AX_16 & 0xff80)==0xff80 || (reg_AX_16 & 0xff80)==0x0000) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t val= *(uint8_t*)(target);
			uint16_t quo = reg_AX_16u / val;
			uint8_t rem = (uint8_t)(reg_AX_16 % val);
			uint8_t quo8 = (uint8_t)(quo&0xff);
			reg_AH_8u=rem;
			reg_AL_8u=quo8;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem]^parity_lookup[quo8]);
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			int16_t val= *(int8_t*)(target);
			int16_t quo= ((int16_t)reg_AX_16) / val;
			int8_t rem=(int8_t)((int16_t)reg_AX_16 % val);
			int8_t quo8s=(int8_t)(quo&0xff);
			reg_AH_8=(uint8_t)rem;
			reg_AL_8=(uint8_t)quo8s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem&0xff]^parity_lookup[quo8s&0xff]^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code00F7P66_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			// TEST
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = read16();
			LazyFlagResultContainer16 = LazyFlagVarA16 & ((uint16_t)LazyFlagVarB16);
			lazyFlagType = t_TEST16;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			// NOT
			*(int16_t*)target = ~(*(int16_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			// NEG
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagResultContainer16 = 0 - LazyFlagVarA16;
			*(int16_t*)target = LazyFlagResultContainer16;
			lazyFlagType = t_NEG16;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t tempu=((uint32_t)reg_AX_16u)*(uint32_t)(*(uint16_t*)(target));
			reg_AX_16=(uint16_t)(tempu);
			reg_DX_16=(uint16_t)(tempu >> 16);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_16 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16)^PARITY16(reg_DX_16));
			if (reg_DX_16) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			int32_t temps=reg_AX_16 * (*((int16_t*)target));
			reg_AX_16=(uint16_t)(temps);
			reg_DX_16=(uint16_t)(temps >> 16);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_16 == 0);
			SET_FLAG(SF,reg_AX_16 & 0x8000);
			if ((((uint32_t)temps & 0xffff8000)==0xffff8000 || ((uint32_t)temps & 0xffff8000)==0x0000)) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint16_t val= *(uint16_t*)(target);
			uint32_t num=((uint32_t)reg_DX_16u<<16) | reg_AX_16u;
			uint32_t quo=num/val;
			uint16_t rem=(uint16_t)(num % val);
			uint16_t quo16=(uint16_t)(quo&0xffff);
			reg_DX_16u=rem;
			reg_AX_16u=quo16;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo16&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY16(rem)^PARITY16(quo16));
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			int32_t val=*(int16_t*)(target);
			int32_t num=(int32_t)(((uint32_t)reg_DX_16<<16u)|(unsigned int)reg_AX_16);
			int32_t quo=num/val;
			int16_t rem=(int16_t)(num % val);
			int16_t quo16s=(int16_t)(quo&0xffff);
			reg_DX_16u=(uint16_t)rem;
			reg_AX_16u=(uint16_t)quo16s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo16s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY16(rem&0xffff)^PARITY16(quo16s&0xffff)^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code00F7_RM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			// TEST
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = read32();
			LazyFlagResultContainer32 = LazyFlagVarA32 & ((uint32_t)LazyFlagVarB32);
			lazyFlagType = t_TEST32;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			// NOT
			*(int32_t*)target = ~(*(int32_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			// NEG
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagResultContainer32 = 0 - LazyFlagVarA32;
			*(int32_t*)target = LazyFlagResultContainer32;
			lazyFlagType = t_NEG32;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint64_t tempu=((uint64_t)reg_AX_32u)*((uint64_t)(*(uint32_t*)(target)));
			reg_AX_32=(uint32_t)(tempu);
			reg_DX_32=(uint32_t)(tempu >> 32);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_32 == 0);
			SET_FLAG(PF,PARITY32(reg_AX_32)^PARITY32(reg_DX_32));
			if (reg_DX_32) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			int64_t temps=((int64_t)(reg_AX_32))*((int64_t)(*(int32_t*)(target)));
			reg_AX_32=(uint32_t)(temps);
			reg_DX_32=(uint32_t)(temps >> 32);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_32 == 0);
			SET_FLAG(SF,reg_AX_32 & 0x80000000);
			if ((reg_AX_32==0xffffffff) && (reg_AX_32 & 0x80000000) ) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else if ( (reg_AX_32==0x00000000) && (reg_AX_32< 0x80000000) ) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t val= *(uint32_t*)(target);
			uint64_t num=(((uint64_t)reg_DX_32u)<<32) | reg_AX_32u;
			uint64_t quo=num/val;
			uint32_t rem=(uint32_t)(num % val);
			uint32_t quo32=(uint32_t)(quo&0xffffffff);
			reg_DX_32u=rem;
			reg_AX_32u=quo32;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo32&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY32(rem)^PARITY32(quo32));
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			int64_t val=*(int32_t*)(target);
			int64_t num=(int64_t)((((uint64_t)reg_DX_32)<<(uint64_t)32)|(uint64_t)reg_AX_32);
			int64_t quo=num/val;
			int32_t rem=(int32_t)(num % val);
			int32_t quo32s=(int32_t)(quo&0xffffffff);
			reg_DX_32u=(uint32_t)rem;
			reg_AX_32u=(uint32_t)quo32s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo32s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY32((uint32_t)rem&0xffffffffu)^PARITY32((uint32_t)quo32s&0xffffffffu)^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Flag CF set false
void handlerCommand32Code00F8_RM() {
	LOG("%s","Flag CF set false");
	SET_FLAG(CF, 0);
}
//Flag CF set true
void handlerCommand32Code00F9_RM() {
	LOG("%s","Flag CF set true");
	SET_FLAG(CF, 1);
}
//Flag IF set false
void handlerCommand32Code00FA_RM() {
	LOG("%s","Flag IF set false");
	SET_FLAG(IF, 0);
}
//Flag IF set true
void handlerCommand32Code00FB_RM() {
	LOG("%s","Flag IF set true");
	SET_FLAG(IF, 1);
}
//Flag DF set false
void handlerCommand32Code00FC_RM() {
	LOG("%s","Flag DF set false");
	SET_FLAG(DF, 0);
}
//Flag DF set true
void handlerCommand32Code00FD_RM() {
	LOG("%s","Flag DF set true");
	SET_FLAG(DF, 1);
}
//Inc/Dec
void handlerCommand32Code00FE_RM() {
	LOG("%s","Inc/Dec");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			(*(uint8_t*)target) += 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_INC8;
		}
		break;
		case 0x01: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			(*(uint8_t*)target) -= 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_DEC8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand32Code00FFP66P67_RM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			(*(uint16_t*)target)++;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_INC16;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			(*(uint16_t*)target)--;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_DEC16;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t* sp = register32u(BR_SP);
			*sp -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t newIP = *(uint32_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 32 / 8);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int16_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			reg_SP_16u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *(uint32_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand32Code00FFP67_RM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			(*(uint32_t*)target)++;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_INC32;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			(*(uint32_t*)target)--;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_DEC32;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t* sp = register32u(BR_SP);
			*sp -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t newIP = *(uint32_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 32 / 8);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int32_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			reg_SP_16u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *(uint32_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand32Code00FFP66_RM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			(*(uint16_t*)target)++;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_INC16;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			(*(uint16_t*)target)--;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_DEC16;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t* sp = register32u(BR_SP);
			*sp -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t newIP = *(uint32_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 32 / 8);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int16_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *(uint32_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand32Code00FF_RM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			(*(uint32_t*)target)++;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_INC32;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			(*(uint32_t*)target)--;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_DEC32;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t* sp = register32u(BR_SP);
			*sp -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t newIP = *(uint32_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 32 / 8);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int32_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			SET_VALUE_IN_SEGMENT(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *(uint32_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//???
void handlerCommand32Code0101_RM() {
	LOG("%s","???");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			*(uint16_t*)target = 0x0019;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//J(cond)
void handlerCommand32Code0180_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x00 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0181_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x01 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0182_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x02 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0183_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x03 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0184_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x04 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0185_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x05 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0186_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x06 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0187_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x07 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0188_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x08 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0189_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x09 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018A_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0A {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018B_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0B {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018C_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0C {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018D_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0D {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018E_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0E {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018F_RM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0F {
		context.index += address;
	}
}
//Math
void handlerCommand32Code0190P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x00;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x00 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0190_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x00;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x00 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0191P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x01;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x01 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0191_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x01;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x01 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0192P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x02;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x02 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0192_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x02;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x02 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0193P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x03;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x03 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0193_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x03;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x03 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0194P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x04;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x04 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0194_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x04;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x04 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0195P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x05;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x05 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0195_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x05;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x05 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0196P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x06;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x06 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0196_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x06;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x06 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0197P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x07;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x07 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0197_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x07;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x07 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0198P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x08;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x08 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0198_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x08;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x08 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0199P66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x09;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x09 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0199_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x09;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x09 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019AP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0A;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0A ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019A_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0A;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0A ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019BP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0B;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0B ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019B_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0B;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0B ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019CP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0C;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0C ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019C_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0C;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0C ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019DP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0D;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0D ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019D_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0D;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0D ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019EP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0E;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0E ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019E_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0E;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0E ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019FP66_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0F;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0F ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019F_RM() {
	LOG("%s","Math");
	uint8_t cond = 0x0F;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0F ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//BT
void handlerCommand32Code01A3P66_RM() {
	LOG("%s","BT");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BT
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
}
//BT
void handlerCommand32Code01A3_RM() {
	LOG("%s","BT");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BT
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
}
//BTS
void handlerCommand32Code01ABP66_RM() {
	LOG("%s","BTS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTS
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
}
//BTS
void handlerCommand32Code01AB_RM() {
	LOG("%s","BTS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTS
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
}
//Mul
void handlerCommand32Code01AFP66_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = *(int16_t*)source;
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Mul
void handlerCommand32Code01AF_RM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = *(int32_t*)source;
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Load SR_SS
void handlerCommand32Code01B2_RM() {
	LOG("%s","Load SR_SS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_SS, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//BTR
void handlerCommand32Code01B3P66_RM() {
	LOG("%s","BTR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTR
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
}
//BTR
void handlerCommand32Code01B3_RM() {
	LOG("%s","BTR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTR
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
}
//Load SR_FS
void handlerCommand32Code01B4_RM() {
	LOG("%s","Load SR_FS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_FS, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//Load SR_GS
void handlerCommand32Code01B5_RM() {
	LOG("%s","Load SR_GS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT(SR_GS, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//MOVZX
void handlerCommand32Code01B6P66_RM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint16_t* target = (uint16_t*)readRegisterMRM16(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	*target = (uint16_t)*source;
}
//MOVZX
void handlerCommand32Code01B6_RM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	*target = (uint32_t)*source;
}
//MOVZX
void handlerCommand32Code01B7P66_RM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint16_t* source = (uint16_t*)readAddressMRM32For16(mrmByte);
	*target = (uint32_t)*source;
}
//MOVZX
void handlerCommand32Code01B7_RM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint16_t* source = (uint16_t*)readAddressMRM32For16(mrmByte);
	*target = (uint32_t)*source;
}
//Bit scan
void handlerCommand32Code01BAP66_RM() {
	LOG("%s","Bit scan");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BT
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTS
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTR
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTC
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			if (value) {
				(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
			} else {
				(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Bit scan
void handlerCommand32Code01BA_RM() {
	LOG("%s","Bit scan");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BT
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTS
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTR
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTC
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			if (value) {
				(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
			} else {
				(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//BTC
void handlerCommand32Code01BBP66_RM() {
	LOG("%s","BTC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTC
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	if (value) {
		(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
	} else {
		(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
	}
}
//BTC
void handlerCommand32Code01BB_RM() {
	LOG("%s","BTC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTC
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	if (value) {
		(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
	} else {
		(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
	}
}
//BFC
void handlerCommand32Code01BCP66_RM() {
	LOG("%s","BFC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	FillFlags();
	uint16_t value = *(uint16_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint16_t mask = 1;
	uint16_t len = 0;
	while ((mask & value) && (len < 16)) {
		value = value >> 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint16_t*)target = len;
}
//BFC
void handlerCommand32Code01BC_RM() {
	LOG("%s","BFC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	FillFlags();
	uint32_t value = *(uint32_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint32_t mask = 1;
	uint32_t len = 0;
	while ((mask & value) && (len < 32)) {
		value = value >> 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint32_t*)target = len;
}
//BSR
void handlerCommand32Code01BDP66_RM() {
	LOG("%s","BSR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	FillFlags();
	uint16_t value = *(uint16_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint16_t mask = 1 << (16 - 1);
	uint16_t len = 0;
	while ((mask & value) && (len < 16)) {
		value = value << 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint16_t*)target = len;
}
//BSR
void handlerCommand32Code01BD_RM() {
	LOG("%s","BSR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	FillFlags();
	uint32_t value = *(uint32_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint32_t mask = 1 << (32 - 1);
	uint32_t len = 0;
	while ((mask & value) && (len < 32)) {
		value = value << 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint32_t*)target = len;
}
//MOVSX
void handlerCommand32Code01BEP66_RM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int16_t* target = (int16_t*)readRegisterMRM16(mrmByte);
	int8_t* source = (int8_t*)readAddressMRM32For8(mrmByte);
	*target = (int16_t)*source;
}
//MOVSX
void handlerCommand32Code01BE_RM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int32_t* target = (int32_t*)readRegisterMRM32(mrmByte);
	int8_t* source = (int8_t*)readAddressMRM32For8(mrmByte);
	*target = (int32_t)*source;
}
//MOVSX
void handlerCommand32Code01BF_RM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int32_t* target = (int32_t*)readRegisterMRM32(mrmByte);
	int16_t* source = (int16_t*)readAddressMRM32For16(mrmByte);
	*target = (int32_t)*source;
}
//Swap
void handlerCommand32Code01C8_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01C9_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CA_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CB_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CC_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CD_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CE_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CF_RM() {
	LOG("%s","Swap");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//ADD
void handlerCommand16Code0000P66_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0000_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0001P66_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_ADD32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand16Code0001_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_ADD16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand16Code0002P66_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0002_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0003P66_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_ADD32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand16Code0003_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_ADD16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand16Code0004P66_PM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_ADD8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0004_PM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_ADD8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand16Code0005P66_PM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_ADD32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand16Code0005_PM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_ADD16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//Push
void handlerCommand16Code0006_PM() {
	LOG("%s","Push");
	uint8_t rg = 0x00;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(rg);
}
//Push
void handlerCommand16Code000E_PM() {
	LOG("%s","Push");
	uint8_t rg = 0x01;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(rg);
}
//Push
void handlerCommand16Code0016_PM() {
	LOG("%s","Push");
	uint8_t rg = 0x02;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(rg);
}
//Push
void handlerCommand16Code001E_PM() {
	LOG("%s","Push");
	uint8_t rg = 0x03;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(rg);
}
//Pop
void handlerCommand16Code0007_PM() {
	LOG("%s","Pop");
	uint8_t rg = 0x00;
	    SET_VALUE_IN_SEGMENT_P(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	    reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code000F_PM() {
	LOG("%s","Pop");
	uint8_t rg = 0x01;
	// 0f???
}
//Pop
void handlerCommand16Code0017_PM() {
	LOG("%s","Pop");
	uint8_t rg = 0x02;
	    SET_VALUE_IN_SEGMENT_P(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	    reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code001F_PM() {
	LOG("%s","Pop");
	uint8_t rg = 0x03;
	    SET_VALUE_IN_SEGMENT_P(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	    reg_SP_16u += 16 / 8;
}
//OR
void handlerCommand16Code0008P66_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code0008_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code0009P66_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_OR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand16Code0009_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_OR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand16Code000AP66_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code000A_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code000BP66_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_OR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand16Code000B_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_OR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand16Code000CP66_PM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_OR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code000C_PM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_OR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand16Code000DP66_PM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_OR32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand16Code000D_PM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_OR16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand16Code0010P66_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0010_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0011P66_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
	lazyFlagType = t_ADC32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand16Code0011_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
	lazyFlagType = t_ADC16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand16Code0012P66_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0012_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0013P66_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
	lazyFlagType = t_ADC32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand16Code0013_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
	lazyFlagType = t_ADC16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand16Code0014P66_PM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) + oldcf;
	lazyFlagType = t_ADC8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0014_PM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) + oldcf;
	lazyFlagType = t_ADC8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand16Code0015P66_PM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32)) + oldcf;
	lazyFlagType = t_ADC32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand16Code0015_PM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16)) + oldcf;
	lazyFlagType = t_ADC16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand16Code0018P66_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code0018_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code0019P66_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
	lazyFlagType = t_SBB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand16Code0019_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
	lazyFlagType = t_SBB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand16Code001AP66_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code001A_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code001BP66_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
	lazyFlagType = t_SBB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand16Code001B_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
	lazyFlagType = t_SBB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand16Code001CP66_PM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) - oldcf;
	lazyFlagType = t_SBB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code001C_PM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) - oldcf;
	lazyFlagType = t_SBB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand16Code001DP66_PM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) - oldcf;
	lazyFlagType = t_SBB32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand16Code001D_PM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) - oldcf;
	lazyFlagType = t_SBB16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand16Code0020P66_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0020_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0021P66_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_AND32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand16Code0021_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_AND16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand16Code0022P66_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0022_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0023P66_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_AND32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand16Code0023_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_AND16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand16Code0024P66_PM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_AND8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0024_PM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_AND8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand16Code0025P66_PM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_AND32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand16Code0025_PM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_AND16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand16Code0028P66_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code0028_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code0029P66_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_SUB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand16Code0029_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_SUB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand16Code002AP66_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code002A_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code002BP66_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_SUB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand16Code002B_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_SUB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand16Code002CP66_PM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_SUB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code002C_PM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_SUB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand16Code002DP66_PM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_SUB32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand16Code002D_PM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_SUB16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand16Code0030P66_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0030_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0031P66_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_XOR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand16Code0031_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_XOR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand16Code0032P66_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0032_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0033P66_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_XOR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand16Code0033_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_XOR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand16Code0034P66_PM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_XOR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0034_PM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_XOR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand16Code0035P66_PM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_XOR32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand16Code0035_PM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_XOR16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//CMP
void handlerCommand16Code0038P66_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code0038_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code0039P66_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand16Code0039_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand16Code003AP66_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code003A_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code003BP66_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand16Code003B_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand16Code003CP66_PM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code003C_PM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand16Code003DP66_PM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand16Code003D_PM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_CMP16;
}
//Inc
void handlerCommand16Code0040P66_PM() {
	LOG("%s","Inc");
	reg_0x00_32u += 1;
	LazyFlagResultContainer32 = reg_0x00_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0040_PM() {
	LOG("%s","Inc");
	reg_0x00_16u += 1;
	LazyFlagResultContainer16 = reg_0x00_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0041P66_PM() {
	LOG("%s","Inc");
	reg_0x01_32u += 1;
	LazyFlagResultContainer32 = reg_0x01_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0041_PM() {
	LOG("%s","Inc");
	reg_0x01_16u += 1;
	LazyFlagResultContainer16 = reg_0x01_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0042P66_PM() {
	LOG("%s","Inc");
	reg_0x02_32u += 1;
	LazyFlagResultContainer32 = reg_0x02_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0042_PM() {
	LOG("%s","Inc");
	reg_0x02_16u += 1;
	LazyFlagResultContainer16 = reg_0x02_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0043P66_PM() {
	LOG("%s","Inc");
	reg_0x03_32u += 1;
	LazyFlagResultContainer32 = reg_0x03_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0043_PM() {
	LOG("%s","Inc");
	reg_0x03_16u += 1;
	LazyFlagResultContainer16 = reg_0x03_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0044P66_PM() {
	LOG("%s","Inc");
	reg_0x04_32u += 1;
	LazyFlagResultContainer32 = reg_0x04_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0044_PM() {
	LOG("%s","Inc");
	reg_0x04_16u += 1;
	LazyFlagResultContainer16 = reg_0x04_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0045P66_PM() {
	LOG("%s","Inc");
	reg_0x05_32u += 1;
	LazyFlagResultContainer32 = reg_0x05_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0045_PM() {
	LOG("%s","Inc");
	reg_0x05_16u += 1;
	LazyFlagResultContainer16 = reg_0x05_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0046P66_PM() {
	LOG("%s","Inc");
	reg_0x06_32u += 1;
	LazyFlagResultContainer32 = reg_0x06_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0046_PM() {
	LOG("%s","Inc");
	reg_0x06_16u += 1;
	LazyFlagResultContainer16 = reg_0x06_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand16Code0047P66_PM() {
	LOG("%s","Inc");
	reg_0x07_32u += 1;
	LazyFlagResultContainer32 = reg_0x07_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand16Code0047_PM() {
	LOG("%s","Inc");
	reg_0x07_16u += 1;
	LazyFlagResultContainer16 = reg_0x07_16u;
	lazyFlagType = t_INC16;
}
//Dec
void handlerCommand16Code0048P66_PM() {
	LOG("%s","Dec");
	reg_0x00_32u -= 1;
	LazyFlagResultContainer32 = reg_0x00_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code0048_PM() {
	LOG("%s","Dec");
	reg_0x00_16u -= 1;
	LazyFlagResultContainer16 = reg_0x00_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code0049P66_PM() {
	LOG("%s","Dec");
	reg_0x01_32u -= 1;
	LazyFlagResultContainer32 = reg_0x01_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code0049_PM() {
	LOG("%s","Dec");
	reg_0x01_16u -= 1;
	LazyFlagResultContainer16 = reg_0x01_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004AP66_PM() {
	LOG("%s","Dec");
	reg_0x02_32u -= 1;
	LazyFlagResultContainer32 = reg_0x02_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004A_PM() {
	LOG("%s","Dec");
	reg_0x02_16u -= 1;
	LazyFlagResultContainer16 = reg_0x02_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004BP66_PM() {
	LOG("%s","Dec");
	reg_0x03_32u -= 1;
	LazyFlagResultContainer32 = reg_0x03_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004B_PM() {
	LOG("%s","Dec");
	reg_0x03_16u -= 1;
	LazyFlagResultContainer16 = reg_0x03_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004CP66_PM() {
	LOG("%s","Dec");
	reg_0x04_32u -= 1;
	LazyFlagResultContainer32 = reg_0x04_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004C_PM() {
	LOG("%s","Dec");
	reg_0x04_16u -= 1;
	LazyFlagResultContainer16 = reg_0x04_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004DP66_PM() {
	LOG("%s","Dec");
	reg_0x05_32u -= 1;
	LazyFlagResultContainer32 = reg_0x05_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004D_PM() {
	LOG("%s","Dec");
	reg_0x05_16u -= 1;
	LazyFlagResultContainer16 = reg_0x05_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004EP66_PM() {
	LOG("%s","Dec");
	reg_0x06_32u -= 1;
	LazyFlagResultContainer32 = reg_0x06_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004E_PM() {
	LOG("%s","Dec");
	reg_0x06_16u -= 1;
	LazyFlagResultContainer16 = reg_0x06_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand16Code004FP66_PM() {
	LOG("%s","Dec");
	reg_0x07_32u -= 1;
	LazyFlagResultContainer32 = reg_0x07_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand16Code004F_PM() {
	LOG("%s","Dec");
	reg_0x07_16u -= 1;
	LazyFlagResultContainer16 = reg_0x07_16u;
	lazyFlagType = t_DEC16;
}
//Push
void handlerCommand16Code0050P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0050P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint16_t value = reg_0x00_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0050P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0050_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint16_t value = reg_0x00_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0051P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0051P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint16_t value = reg_0x01_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0051P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0051_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint16_t value = reg_0x01_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0052P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0052P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint16_t value = reg_0x02_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0052P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0052_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint16_t value = reg_0x02_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0053P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0053P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint16_t value = reg_0x03_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0053P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0053_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint16_t value = reg_0x03_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0054P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0054P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint16_t value = reg_0x04_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0054P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0054_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint16_t value = reg_0x04_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0055P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0055P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint16_t value = reg_0x05_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0055P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0055_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint16_t value = reg_0x05_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0056P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0056P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint16_t value = reg_0x06_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0056P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0056_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint16_t value = reg_0x06_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0057P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0057P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint16_t value = reg_0x07_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand16Code0057P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand16Code0057_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint16_t value = reg_0x07_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Pop
void handlerCommand16Code0058P66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code0058P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code0058P66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code0058_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code0059P66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code0059P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code0059P66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code0059_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005AP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005AP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005AP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005A_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005BP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005BP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005BP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005B_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005CP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005CP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005CP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005C_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005DP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005DP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005DP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005D_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005EP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005EP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005EP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005E_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand16Code005FP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand16Code005FP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand16Code005FP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand16Code005F_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//PUSHA
void handlerCommand16Code0060P66_PM() {
	LOG("%s","PUSHA");
	uint32_t tmp = reg_SP_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_AX_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_CX_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_DX_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BX_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = tmp;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SI_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_DI_32u;
}
//PUSHA
void handlerCommand16Code0060_PM() {
	LOG("%s","PUSHA");
	uint16_t tmp = reg_SP_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_AX_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_CX_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_DX_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BX_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = tmp;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SI_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_DI_16u;
}
//POPA
void handlerCommand16Code0061P66_PM() {
	LOG("%s","POPA");
	reg_DI_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_SI_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_BP_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_SP_16u += 32 / 8;
	reg_BX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_DX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_CX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
	reg_AX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//POPA
void handlerCommand16Code0061_PM() {
	LOG("%s","POPA");
	reg_DI_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_SI_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_BP_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_SP_16u += 16 / 8;
	reg_BX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_DX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_CX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
	reg_AX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Push
void handlerCommand16Code0068P66P67_PM() {
	LOG("%s","Push");
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = read32u();
}
//Push
void handlerCommand16Code0068P67_PM() {
	LOG("%s","Push");
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = read16u();
}
//Push
void handlerCommand16Code0068P66_PM() {
	LOG("%s","Push");
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = read32u();
}
//Push
void handlerCommand16Code0068_PM() {
	LOG("%s","Push");
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = read16u();
}
//Mul
void handlerCommand16Code0069P66_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = read32();
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Mul
void handlerCommand16Code0069_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = read16();
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Push
void handlerCommand16Code006AP66P67_PM() {
	LOG("%s","Push");
	reg_SP_32u -= 32 / 8;
	*(int32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = (int32_t)read8();
}
//Push
void handlerCommand16Code006AP67_PM() {
	LOG("%s","Push");
	reg_SP_32u -= 16 / 8;
	*(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = (int16_t)read8();
}
//Push
void handlerCommand16Code006AP66_PM() {
	LOG("%s","Push");
	reg_SP_16u -= 32 / 8;
	*(int32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = (int32_t)read8();
}
//Push
void handlerCommand16Code006A_PM() {
	LOG("%s","Push");
	reg_SP_16u -= 16 / 8;
	*(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = (int16_t)read8();
}
//Mul
void handlerCommand16Code006B_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = (int16_t)read8();
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//J(cond)
void handlerCommand16Code0070_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x00 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0071_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x01 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0072_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x02 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0073_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x03 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0074_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x04 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0075_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x05 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0076_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x06 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0077_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x07 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0078_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x08 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0079_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x09 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007A_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0A {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007B_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0B {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007C_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0C {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007D_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0D {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007E_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0E {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code007F_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0F {
		context.index += address;
	}
}
//Math
void handlerCommand16Code0080P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0080_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0081P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_ADD32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_OR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
			lazyFlagType = t_ADC32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
			lazyFlagType = t_SBB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_AND32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_SUB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_XOR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_CMP32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0081_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_ADD16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_OR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
			lazyFlagType = t_ADC16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
			lazyFlagType = t_SBB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_AND16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_SUB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_XOR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_CMP16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0082_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) + ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) | ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) + ((int8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) & ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) ^ ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0083P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) + ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_ADD32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) | ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_OR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) + ((int32_t)LazyFlagVarB32) + oldcf;
			lazyFlagType = t_ADC32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) - oldcf;
			lazyFlagType = t_SBB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) & ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_AND32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_SUB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) ^ ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_XOR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_CMP32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0083_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) + ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_ADD16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) | ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_OR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) + ((int16_t)LazyFlagVarB16) + oldcf;
			lazyFlagType = t_ADC16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) - oldcf;
			lazyFlagType = t_SBB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) & ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_AND16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_SUB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) ^ ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_XOR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_CMP16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//TEST
void handlerCommand16Code0084P66_PM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand16Code0084_PM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand16Code0085P66_PM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_TEST32;
}
//TEST
void handlerCommand16Code0085_PM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_TEST16;
}
//XCHG
void handlerCommand16Code0086P66_PM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t tmp = *(uint16_t*)target;
	*(uint16_t*)target = *(uint16_t*)source;
	*(uint16_t*)source = tmp;
}
//XCHG
void handlerCommand16Code0086_PM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t tmp = *(uint16_t*)target;
	*(uint16_t*)target = *(uint16_t*)source;
	*(uint16_t*)source = tmp;
}
//XCHG
void handlerCommand16Code0087P66_PM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t tmp = *(uint16_t*)target;
	*(uint16_t*)target = *(uint16_t*)source;
	*(uint16_t*)source = tmp;
}
//XCHG
void handlerCommand16Code0087_PM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t tmp = *(uint16_t*)target;
	*(uint16_t*)target = *(uint16_t*)source;
	*(uint16_t*)source = tmp;
}
//Move
void handlerCommand16Code0088P66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code0088_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code0089P66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code0089_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code008AP66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code008A_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code008BP66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code008B_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code008C_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t sr = readMiddle3Bit(mrmByte);
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readSegmentRegisterMRM;
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code008E_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t sr = readMiddle3Bit(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* target = (uint8_t*)readSegmentRegisterMRM;
	*(uint16_t*)target = *(uint16_t*)source;
	recalculatePointerSegmentRegisterMRM_P
}
//Lea
void handlerCommand16Code008DP66P67_PM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint16_t target = effectiveAddressMRM16For16(mrmByte);
	*((uint32_t*)source) = (uint32_t)(target & 0xFFFFFFFF);
}
//Lea
void handlerCommand16Code008DP67_PM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t target = effectiveAddressMRM16For16(mrmByte);
	*((uint16_t*)source) = (uint16_t)(target & 0xFFFF);
}
//Lea
void handlerCommand16Code008DP66_PM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint16_t target = effectiveAddressMRM16For16(mrmByte);
	*((uint32_t*)source) = (uint32_t)(target & 0xFFFFFFFF);
}
//Lea
void handlerCommand16Code008D_PM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t target = effectiveAddressMRM16For16(mrmByte);
	*((uint16_t*)source) = (uint16_t)(target & 0xFFFF);
}
//Pop
void handlerCommand16Code008FP66P67_PM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			*(uint32_t*)target = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
			reg_SP_32u += 32 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand16Code008FP67_PM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			*(uint16_t*)target = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
			reg_SP_32u += 16 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand16Code008FP66_PM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			*(uint32_t*)target = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
			reg_SP_16u += 32 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand16Code008F_PM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			*(uint16_t*)target = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
			reg_SP_16u += 16 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//XCHG
void handlerCommand16Code0090P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x00;
	// NOP
}
//XCHG
void handlerCommand16Code0090_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x00;
	// NOP
}
//XCHG
void handlerCommand16Code0091P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x01;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x01_16u;
	reg_0x01_16u = tmp;
}
//XCHG
void handlerCommand16Code0091_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x01;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x01_16u;
	reg_0x01_16u = tmp;
}
//XCHG
void handlerCommand16Code0092P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x02;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x02_16u;
	reg_0x02_16u = tmp;
}
//XCHG
void handlerCommand16Code0092_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x02;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x02_16u;
	reg_0x02_16u = tmp;
}
//XCHG
void handlerCommand16Code0093P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x03;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x03_16u;
	reg_0x03_16u = tmp;
}
//XCHG
void handlerCommand16Code0093_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x03;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x03_16u;
	reg_0x03_16u = tmp;
}
//XCHG
void handlerCommand16Code0094P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x04;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x04_16u;
	reg_0x04_16u = tmp;
}
//XCHG
void handlerCommand16Code0094_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x04;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x04_16u;
	reg_0x04_16u = tmp;
}
//XCHG
void handlerCommand16Code0095P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x05;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x05_16u;
	reg_0x05_16u = tmp;
}
//XCHG
void handlerCommand16Code0095_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x05;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x05_16u;
	reg_0x05_16u = tmp;
}
//XCHG
void handlerCommand16Code0096P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x06;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x06_16u;
	reg_0x06_16u = tmp;
}
//XCHG
void handlerCommand16Code0096_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x06;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x06_16u;
	reg_0x06_16u = tmp;
}
//XCHG
void handlerCommand16Code0097P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x07;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x07_16u;
	reg_0x07_16u = tmp;
}
//XCHG
void handlerCommand16Code0097_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x07;
	uint16_t tmp = reg_AX_16u;
	reg_AX_16u = reg_0x07_16u;
	reg_0x07_16u = tmp;
}
//CBW
void handlerCommand16Code0098P66_PM() {
	LOG("%s","CBW");
	reg_AX_32 = reg_AX_16;
}
//CBW
void handlerCommand16Code0098_PM() {
	LOG("%s","CBW");
	reg_AX_16 = reg_AL_8;
}
//CBW
void handlerCommand16Code0099P66_PM() {
	LOG("%s","CBW");
	if (reg_AX_32 & 0x80000000) reg_DX_32=0xffffffff; else reg_DX_32=0;
}
//CBW
void handlerCommand16Code0099_PM() {
	LOG("%s","CBW");
	if (reg_AX_16 & 0x8000) reg_DX_16=0xffff;else reg_DX_16=0;
}
//Call
void handlerCommand16Code009A_PM() {
	LOG("%s","Call");
	uint16_t newIP = read16u();
	uint16_t newCS = read16u();
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
	SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
	context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
}
//PUSHF
void handlerCommand16Code009CP66_PM() {
	LOG("%s","PUSHF");
	FillFlags();
	reg_SP_16u -= 32 / 8;
	EncodeFlagsRegister();
	uint32_t value = reg_flags & 0xFCFFFF;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *((uint32_t*)&value);
}
//PUSHF
void handlerCommand16Code009C_PM() {
	LOG("%s","PUSHF");
	FillFlags();
	reg_SP_16u -= 16 / 8;
	EncodeFlagsRegister();
	uint32_t value = reg_flags & 0xFCFFFF;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *((uint16_t*)&value);
}
//POPF
void handlerCommand16Code009DP66_PM() {
	LOG("%s","POPF");
	lazyFlagType = t_UNKNOWN;
	*(uint32_t*)(&reg_flags) = (*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	reg_SP_16u += 32 / 8;
	DecodeFlagsRegister32();
}
//POPF
void handlerCommand16Code009D_PM() {
	LOG("%s","POPF");
	lazyFlagType = t_UNKNOWN;
	*(uint16_t*)(&reg_flags) = (*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u));
	reg_SP_16u += 16 / 8;
	DecodeFlagsRegister16();
}
//Move
void handlerCommand16Code00A0P66P67_PM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A0P66_PM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A0P67_PM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A0_PM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A1P66P67_PM() {
	LOG("%s","Move");
	uint32_t* target = (uint32_t*)register32u(BR_AX);
	uint32_t* source = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code00A1P66_PM() {
	LOG("%s","Move");
	uint32_t* target = (uint32_t*)register32u(BR_AX);
	uint32_t* source = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code00A1P67_PM() {
	LOG("%s","Move");
	uint16_t* target = (uint16_t*)register16u(BR_AX);
	uint16_t* source = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code00A1_PM() {
	LOG("%s","Move");
	uint16_t* target = (uint16_t*)register16u(BR_AX);
	uint16_t* source = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code00A2P66P67_PM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A2P66_PM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A2P67_PM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A2_PM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand16Code00A3P66P67_PM() {
	LOG("%s","Move");
	uint32_t* source = (uint32_t*)register32u(BR_AX);
	uint32_t* target = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code00A3P66_PM() {
	LOG("%s","Move");
	uint32_t* source = (uint32_t*)register32u(BR_AX);
	uint32_t* target = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand16Code00A3P67_PM() {
	LOG("%s","Move");
	uint16_t* source = (uint16_t*)register16u(BR_AX);
	uint16_t* target = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand16Code00A3_PM() {
	LOG("%s","Move");
	uint16_t* source = (uint16_t*)register16u(BR_AX);
	uint16_t* target = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint16_t*)target = *(uint16_t*)source;
}
//MOVS
void handlerCommand16Code00A4P66P67_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A4P66_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A4P67_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A4_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A5P66P67_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A5P66_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A5P67_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
		}
	}
}
//MOVS
void handlerCommand16Code00A5_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A6P66P67_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A6P66_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A6P67_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A6_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A7P66P67_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A7P66_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A7P67_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
		}
	}
}
//CMPS
void handlerCommand16Code00A7_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
		}
	}
}
//TEST
void handlerCommand16Code00A8P66_PM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand16Code00A8_PM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand16Code00A9P66_PM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_TEST32;
}
//TEST
void handlerCommand16Code00A9_PM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_TEST16;
}
//STOS
void handlerCommand16Code00AAP66P67_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00AAP66_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00AAP67_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00AA_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00ABP66P67_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
			reg_DI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
			reg_DI_32u += 32 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00ABP66_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
			reg_DI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
			reg_DI_16u += 32 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00ABP67_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
			reg_DI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
			reg_DI_32u += 16 / 8;
		}
	}
}
//STOS
void handlerCommand16Code00AB_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
			reg_DI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
			reg_DI_16u += 16 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ACP66P67_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ACP66_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ACP67_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00AC_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ADP66P67_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 32 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ADP66_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 32 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00ADP67_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 16 / 8;
		}
	}
}
//LOADS
void handlerCommand16Code00AD_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 16 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AEP66P67_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AEP66_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AEP67_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AE_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AFP66P67_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u += 32 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AFP66_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u += 32 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AFP67_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u += 16 / 8;
		}
	}
}
//SCAS
void handlerCommand16Code00AF_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u += 16 / 8;
		}
	}
}
//Move
void handlerCommand16Code00B0P66_PM() {
	LOG("%s","Move");
	reg_0x00_8u = read8u();
}
//Move
void handlerCommand16Code00B0_PM() {
	LOG("%s","Move");
	reg_0x00_8u = read8u();
}
//Move
void handlerCommand16Code00B1P66_PM() {
	LOG("%s","Move");
	reg_0x01_8u = read8u();
}
//Move
void handlerCommand16Code00B1_PM() {
	LOG("%s","Move");
	reg_0x01_8u = read8u();
}
//Move
void handlerCommand16Code00B2P66_PM() {
	LOG("%s","Move");
	reg_0x02_8u = read8u();
}
//Move
void handlerCommand16Code00B2_PM() {
	LOG("%s","Move");
	reg_0x02_8u = read8u();
}
//Move
void handlerCommand16Code00B3P66_PM() {
	LOG("%s","Move");
	reg_0x03_8u = read8u();
}
//Move
void handlerCommand16Code00B3_PM() {
	LOG("%s","Move");
	reg_0x03_8u = read8u();
}
//Move
void handlerCommand16Code00B4P66_PM() {
	LOG("%s","Move");
	reg_0x04_8u = read8u();
}
//Move
void handlerCommand16Code00B4_PM() {
	LOG("%s","Move");
	reg_0x04_8u = read8u();
}
//Move
void handlerCommand16Code00B5P66_PM() {
	LOG("%s","Move");
	reg_0x05_8u = read8u();
}
//Move
void handlerCommand16Code00B5_PM() {
	LOG("%s","Move");
	reg_0x05_8u = read8u();
}
//Move
void handlerCommand16Code00B6P66_PM() {
	LOG("%s","Move");
	reg_0x06_8u = read8u();
}
//Move
void handlerCommand16Code00B6_PM() {
	LOG("%s","Move");
	reg_0x06_8u = read8u();
}
//Move
void handlerCommand16Code00B7P66_PM() {
	LOG("%s","Move");
	reg_0x07_8u = read8u();
}
//Move
void handlerCommand16Code00B7_PM() {
	LOG("%s","Move");
	reg_0x07_8u = read8u();
}
//Move
void handlerCommand16Code00B8P66_PM() {
	LOG("%s","Move");
	reg_0x00_32u = read32u();
}
//Move
void handlerCommand16Code00B8_PM() {
	LOG("%s","Move");
	reg_0x00_16u = read16u();
}
//Move
void handlerCommand16Code00B9P66_PM() {
	LOG("%s","Move");
	reg_0x01_32u = read32u();
}
//Move
void handlerCommand16Code00B9_PM() {
	LOG("%s","Move");
	reg_0x01_16u = read16u();
}
//Move
void handlerCommand16Code00BAP66_PM() {
	LOG("%s","Move");
	reg_0x02_32u = read32u();
}
//Move
void handlerCommand16Code00BA_PM() {
	LOG("%s","Move");
	reg_0x02_16u = read16u();
}
//Move
void handlerCommand16Code00BBP66_PM() {
	LOG("%s","Move");
	reg_0x03_32u = read32u();
}
//Move
void handlerCommand16Code00BB_PM() {
	LOG("%s","Move");
	reg_0x03_16u = read16u();
}
//Move
void handlerCommand16Code00BCP66_PM() {
	LOG("%s","Move");
	reg_0x04_32u = read32u();
}
//Move
void handlerCommand16Code00BC_PM() {
	LOG("%s","Move");
	reg_0x04_16u = read16u();
}
//Move
void handlerCommand16Code00BDP66_PM() {
	LOG("%s","Move");
	reg_0x05_32u = read32u();
}
//Move
void handlerCommand16Code00BD_PM() {
	LOG("%s","Move");
	reg_0x05_16u = read16u();
}
//Move
void handlerCommand16Code00BEP66_PM() {
	LOG("%s","Move");
	reg_0x06_32u = read32u();
}
//Move
void handlerCommand16Code00BE_PM() {
	LOG("%s","Move");
	reg_0x06_16u = read16u();
}
//Move
void handlerCommand16Code00BFP66_PM() {
	LOG("%s","Move");
	reg_0x07_32u = read32u();
}
//Move
void handlerCommand16Code00BF_PM() {
	LOG("%s","Move");
	reg_0x07_16u = read16u();
}
//Move bits
void handlerCommand16Code00C0P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00C0_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00C1P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00C1_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ret
void handlerCommand16Code00C2_PM() {
	LOG("%s","Ret");
	uint16_t stackValue = read16u();
	uint16_t* sp = register16u(BR_SP);
	context.index = GET_SEGMENT_POINTER(1) + *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (16 / 8);
	*sp += (stackValue * (16 / 16));
}
//Ret
void handlerCommand16Code00C3_PM() {
	LOG("%s","Ret");
	uint16_t* sp = register16u(BR_SP);
	context.index = GET_SEGMENT_POINTER(1) + *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (16 / 8);
}
//Load SR_ES
void handlerCommand16Code00C4_PM() {
	LOG("%s","Load SR_ES");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_ES, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//Load SR_DS
void handlerCommand16Code00C5_PM() {
	LOG("%s","Load SR_DS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_DS, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//Move
void handlerCommand16Code00C6P66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint8_t*)target = read8u();
}
//Move
void handlerCommand16Code00C6_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint8_t*)target = read8u();
}
//Move
void handlerCommand16Code00C7P66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint32_t*)target = read32u();
}
//Move
void handlerCommand16Code00C7_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = read16u();
}
//Enter
void handlerCommand16Code00C8P66P67_PM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	uint32_t tmp = reg_SP_32u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_32u = reg_BP_32u - 32 / 8;
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
		}
		reg_SP_32u -= 32 / 8;
		*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SP_32u;
	}
	reg_BP_32u = tmp;
	reg_SP_32u = reg_BP_32u - size;
}
//Enter
void handlerCommand16Code00C8P67_PM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	uint32_t tmp = reg_SP_32u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_32u = reg_BP_32u - 16 / 8;
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
		}
		reg_SP_32u -= 32 / 8;
		*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SP_32u;
	}
	reg_BP_32u = tmp;
	reg_SP_32u = reg_BP_32u - size;
}
//Enter
void handlerCommand16Code00C8P66_PM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	uint16_t tmp = reg_SP_16u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_16u = reg_BP_16u - 32 / 8;
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
		}
		reg_SP_16u -= 16 / 8;
		*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SP_16u;
	}
	reg_BP_16u = tmp;
	reg_SP_16u = reg_BP_16u - size;
}
//Enter
void handlerCommand16Code00C8_PM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	uint16_t tmp = reg_SP_16u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_16u = reg_BP_16u - 16 / 8;
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
		}
		reg_SP_16u -= 16 / 8;
		*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SP_16u;
	}
	reg_BP_16u = tmp;
	reg_SP_16u = reg_BP_16u - size;
}
//Leave
void handlerCommand16Code00C9P66P67_PM() {
	LOG("%s","Leave");
	reg_SP_32u = reg_BP_32u;
	reg_BP_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Leave
void handlerCommand16Code00C9P67_PM() {
	LOG("%s","Leave");
	reg_SP_32u = reg_BP_32u;
	reg_BP_32u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Leave
void handlerCommand16Code00C9P66_PM() {
	LOG("%s","Leave");
	reg_SP_16u = reg_BP_16u;
	reg_BP_16u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Leave
void handlerCommand16Code00C9_PM() {
	LOG("%s","Leave");
	reg_SP_16u = reg_BP_16u;
	reg_BP_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Ret
void handlerCommand16Code00CA_PM() {
	LOG("%s","Ret");
	uint16_t stackValue = read16u();
	uint16_t* sp = register16u(BR_SP);
	SET_VALUE_IN_SEGMENT_P(1, *(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp + 16 / 8));
	context.index = GET_SEGMENT_POINTER(1) + *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (16 / 8 + 2);
	*sp += (stackValue * (16 / 16));
}
//Ret
void handlerCommand16Code00CB_PM() {
	LOG("%s","Ret");
	uint16_t* sp = register16u(BR_SP);
	SET_VALUE_IN_SEGMENT_P(1, *(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp + 16 / 8));
	context.index = GET_SEGMENT_POINTER(1) + *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (16 / 8 + 2);
}
//Int
void handlerCommand16Code00CD_PM() {
	LOG("%s","Int");
	uint8_t *target = GET_REAL_MOD_MEMORY_POINTER(0) + (read8u() * (2 + 2));
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
	SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
	context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
}
//Move bits
void handlerCommand16Code00D0P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D0_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D1P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D1_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D2P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D2_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D3P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand16Code00D3_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00D8_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 000, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 000, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 000, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 000, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 000, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 000, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00D9_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 001, OPB 000
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = *source;
			} else {
				// OPA 001, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 001, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 001, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				float* valueB = (float*)readAddressMRM16For8(mrmByte);
				float* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				fpuRegControll = *(uint16_t*)readAddressMRM16For16(mrmByte);
			} else {
				fpuRegControll = *(uint16_t*)readAddressMRM16For16(mrmByte);
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegControll;
			} else {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegControll;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DA_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DB_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM16For8(mrmByte);
				int32_t* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				fpuStackIndex = 7;
				fpuRegControll = 0x37F;
				fpuRegStatus = 0;
				fpuRegTag = 0xFFFF;
				fpuRegPointer = 0;
				fpuRegInstructionPointer = 0;
				fpuRegInstructionOpcode = 0;
			} else {
				fpuStackIndex = 7;
				fpuRegControll = 0x37F;
				fpuRegStatus = 0;
				fpuRegTag = 0xFFFF;
				fpuRegPointer = 0;
				fpuRegInstructionPointer = 0;
				fpuRegInstructionOpcode = 0;
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegControll;
			} else {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegControll;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DC_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 100, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 100, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 100, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 100, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 100, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 100, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DD_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = (double*)readAddressMRM16For8(mrmByte);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegStatus;
			} else {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegStatus;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DE_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 110, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 110, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 110, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 110, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 110, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 110, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand16Code00DF_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM16For8(mrmByte);
				int16_t* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Loop
void handlerCommand16Code00E0_PM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_16 -= 1;
	FillFlags();
	if (reg_0x01_16 != 0 && GET_FLAG(ZF) == 0) {
		context.index += addr;
	}
}
//Loop
void handlerCommand16Code00E1_PM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_16 -= 1;
	FillFlags();
	if (reg_0x01_16 != 0 && GET_FLAG(ZF) == 1) {
		context.index += addr;
	}
}
//Loop
void handlerCommand16Code00E2_PM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_16 -= 1;
	if (reg_0x01_16 != 0) {
		context.index += addr;
	}
}
//Loop
void handlerCommand16Code00E3_PM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	if (reg_0x01_16 == 0) {
		context.index += addr;
	}
}
//In
void handlerCommand16Code00E4P66_PM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand16Code00E4_PM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand16Code00E5P66_PM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//In
void handlerCommand16Code00E5_PM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Out
void handlerCommand16Code00E6P66_PM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand16Code00E6_PM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand16Code00E7P66_PM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Out
void handlerCommand16Code00E7_PM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Call
void handlerCommand16Code00E8P66_PM() {
	LOG("%s","Call");
	uint16_t* sp = register16u(BR_SP);
	*sp -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index + 32 / 8 - GET_SEGMENT_POINTER(1));
	context.index += read32();
}
//Call
void handlerCommand16Code00E8_PM() {
	LOG("%s","Call");
	uint16_t* sp = register16u(BR_SP);
	*sp -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index + 16 / 8 - GET_SEGMENT_POINTER(1));
	context.index += read16();
}
//Jmp
void handlerCommand16Code00E9P66_PM() {
	LOG("%s","Jmp");
	context.index += read32();
}
//Jmp
void handlerCommand16Code00E9_PM() {
	LOG("%s","Jmp");
	context.index += read16();
}
//Jmp
void handlerCommand16Code00EB_PM() {
	LOG("%s","Jmp");
	context.index += read8();
}
//In
void handlerCommand16Code00ECP66_PM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand16Code00EC_PM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand16Code00EDP66_PM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//In
void handlerCommand16Code00ED_PM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Out
void handlerCommand16Code00EEP66_PM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand16Code00EE_PM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand16Code00EFP66_PM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Out
void handlerCommand16Code00EF_PM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//External call
void handlerCommand16Code00F1_PM() {
	LOG("%s","External call");
	uint16_t addr = read16u();
	FillFlags();
	context.functions[addr](addr);
}
//~CF
void handlerCommand16Code00F5_PM() {
	LOG("%s","~CF");
	SET_FLAG(CF, !GET_FLAG(CF));
}
//Math
void handlerCommand16Code00F6P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// TEST
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = read8();
			LazyFlagResultContainer8 = LazyFlagVarA8 & ((uint8_t)LazyFlagVarB8);
			lazyFlagType = t_TEST8;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// NOT
			*(int8_t*)target = ~(*(int8_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// NEG
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagResultContainer8 = 0 - LazyFlagVarA8;
			*(int8_t*)target = LazyFlagResultContainer8;
			lazyFlagType = t_NEG8;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			reg_AX_16u=((uint16_t)reg_AL_8u)*((uint16_t)(*(uint8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AL_8 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16));
			if (reg_AX_16 & 0xff00) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			reg_AX_16 = reg_AL_8 * (*((int8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF, reg_AL_8 == 0);
			SET_FLAG(SF, reg_AL_8 & 0x80);
			if ((reg_AX_16 & 0xff80)==0xff80 || (reg_AX_16 & 0xff80)==0x0000) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t val= *(uint8_t*)(target);
			uint16_t quo = reg_AX_16u / val;
			uint8_t rem = (uint8_t)(reg_AX_16 % val);
			uint8_t quo8 = (uint8_t)(quo&0xff);
			reg_AH_8u=rem;
			reg_AL_8u=quo8;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem]^parity_lookup[quo8]);
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			int16_t val= *(int8_t*)(target);
			int16_t quo= ((int16_t)reg_AX_16) / val;
			int8_t rem=(int8_t)((int16_t)reg_AX_16 % val);
			int8_t quo8s=(int8_t)(quo&0xff);
			reg_AH_8=(uint8_t)rem;
			reg_AL_8=(uint8_t)quo8s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem&0xff]^parity_lookup[quo8s&0xff]^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code00F6_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// TEST
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = read8();
			LazyFlagResultContainer8 = LazyFlagVarA8 & ((uint8_t)LazyFlagVarB8);
			lazyFlagType = t_TEST8;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// NOT
			*(int8_t*)target = ~(*(int8_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// NEG
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagResultContainer8 = 0 - LazyFlagVarA8;
			*(int8_t*)target = LazyFlagResultContainer8;
			lazyFlagType = t_NEG8;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			reg_AX_16u=((uint16_t)reg_AL_8u)*((uint16_t)(*(uint8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AL_8 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16));
			if (reg_AX_16 & 0xff00) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			reg_AX_16 = reg_AL_8 * (*((int8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF, reg_AL_8 == 0);
			SET_FLAG(SF, reg_AL_8 & 0x80);
			if ((reg_AX_16 & 0xff80)==0xff80 || (reg_AX_16 & 0xff80)==0x0000) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			uint8_t val= *(uint8_t*)(target);
			uint16_t quo = reg_AX_16u / val;
			uint8_t rem = (uint8_t)(reg_AX_16 % val);
			uint8_t quo8 = (uint8_t)(quo&0xff);
			reg_AH_8u=rem;
			reg_AL_8u=quo8;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem]^parity_lookup[quo8]);
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			int16_t val= *(int8_t*)(target);
			int16_t quo= ((int16_t)reg_AX_16) / val;
			int8_t rem=(int8_t)((int16_t)reg_AX_16 % val);
			int8_t quo8s=(int8_t)(quo&0xff);
			reg_AH_8=(uint8_t)rem;
			reg_AL_8=(uint8_t)quo8s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem&0xff]^parity_lookup[quo8s&0xff]^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code00F7P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			// TEST
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = read32();
			LazyFlagResultContainer32 = LazyFlagVarA32 & ((uint32_t)LazyFlagVarB32);
			lazyFlagType = t_TEST32;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			// NOT
			*(int32_t*)target = ~(*(int32_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			// NEG
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagResultContainer32 = 0 - LazyFlagVarA32;
			*(int32_t*)target = LazyFlagResultContainer32;
			lazyFlagType = t_NEG32;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint64_t tempu=((uint64_t)reg_AX_32u)*((uint64_t)(*(uint32_t*)(target)));
			reg_AX_32=(uint32_t)(tempu);
			reg_DX_32=(uint32_t)(tempu >> 32);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_32 == 0);
			SET_FLAG(PF,PARITY32(reg_AX_32)^PARITY32(reg_DX_32));
			if (reg_DX_32) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			int64_t temps=((int64_t)(reg_AX_32))*((int64_t)(*(int32_t*)(target)));
			reg_AX_32=(uint32_t)(temps);
			reg_DX_32=(uint32_t)(temps >> 32);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_32 == 0);
			SET_FLAG(SF,reg_AX_32 & 0x80000000);
			if ((reg_AX_32==0xffffffff) && (reg_AX_32 & 0x80000000) ) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else if ( (reg_AX_32==0x00000000) && (reg_AX_32< 0x80000000) ) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint32_t val= *(uint32_t*)(target);
			uint64_t num=(((uint64_t)reg_DX_32u)<<32) | reg_AX_32u;
			uint64_t quo=num/val;
			uint32_t rem=(uint32_t)(num % val);
			uint32_t quo32=(uint32_t)(quo&0xffffffff);
			reg_DX_32u=rem;
			reg_AX_32u=quo32;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo32&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY32(rem)^PARITY32(quo32));
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			int64_t val=*(int32_t*)(target);
			int64_t num=(int64_t)((((uint64_t)reg_DX_32)<<(uint64_t)32)|(uint64_t)reg_AX_32);
			int64_t quo=num/val;
			int32_t rem=(int32_t)(num % val);
			int32_t quo32s=(int32_t)(quo&0xffffffff);
			reg_DX_32u=(uint32_t)rem;
			reg_AX_32u=(uint32_t)quo32s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo32s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY32((uint32_t)rem&0xffffffffu)^PARITY32((uint32_t)quo32s&0xffffffffu)^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code00F7_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			// TEST
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = read16();
			LazyFlagResultContainer16 = LazyFlagVarA16 & ((uint16_t)LazyFlagVarB16);
			lazyFlagType = t_TEST16;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			// NOT
			*(int16_t*)target = ~(*(int16_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			// NEG
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagResultContainer16 = 0 - LazyFlagVarA16;
			*(int16_t*)target = LazyFlagResultContainer16;
			lazyFlagType = t_NEG16;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint32_t tempu=((uint32_t)reg_AX_16u)*(uint32_t)(*(uint16_t*)(target));
			reg_AX_16=(uint16_t)(tempu);
			reg_DX_16=(uint16_t)(tempu >> 16);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_16 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16)^PARITY16(reg_DX_16));
			if (reg_DX_16) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			int32_t temps=reg_AX_16 * (*((int16_t*)target));
			reg_AX_16=(uint16_t)(temps);
			reg_DX_16=(uint16_t)(temps >> 16);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_16 == 0);
			SET_FLAG(SF,reg_AX_16 & 0x8000);
			if ((((uint32_t)temps & 0xffff8000)==0xffff8000 || ((uint32_t)temps & 0xffff8000)==0x0000)) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t val= *(uint16_t*)(target);
			uint32_t num=((uint32_t)reg_DX_16u<<16) | reg_AX_16u;
			uint32_t quo=num/val;
			uint16_t rem=(uint16_t)(num % val);
			uint16_t quo16=(uint16_t)(quo&0xffff);
			reg_DX_16u=rem;
			reg_AX_16u=quo16;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo16&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY16(rem)^PARITY16(quo16));
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			int32_t val=*(int16_t*)(target);
			int32_t num=(int32_t)(((uint32_t)reg_DX_16<<16u)|(unsigned int)reg_AX_16);
			int32_t quo=num/val;
			int16_t rem=(int16_t)(num % val);
			int16_t quo16s=(int16_t)(quo&0xffff);
			reg_DX_16u=(uint16_t)rem;
			reg_AX_16u=(uint16_t)quo16s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo16s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY16(rem&0xffff)^PARITY16(quo16s&0xffff)^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Flag CF set false
void handlerCommand16Code00F8_PM() {
	LOG("%s","Flag CF set false");
	SET_FLAG(CF, 0);
}
//Flag CF set true
void handlerCommand16Code00F9_PM() {
	LOG("%s","Flag CF set true");
	SET_FLAG(CF, 1);
}
//Flag IF set false
void handlerCommand16Code00FA_PM() {
	LOG("%s","Flag IF set false");
	SET_FLAG(IF, 0);
}
//Flag IF set true
void handlerCommand16Code00FB_PM() {
	LOG("%s","Flag IF set true");
	SET_FLAG(IF, 1);
}
//Flag DF set false
void handlerCommand16Code00FC_PM() {
	LOG("%s","Flag DF set false");
	SET_FLAG(DF, 0);
}
//Flag DF set true
void handlerCommand16Code00FD_PM() {
	LOG("%s","Flag DF set true");
	SET_FLAG(DF, 1);
}
//Inc/Dec
void handlerCommand16Code00FE_PM() {
	LOG("%s","Inc/Dec");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			(*(uint8_t*)target) += 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_INC8;
		}
		break;
		case 0x01: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			(*(uint8_t*)target) -= 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_DEC8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand16Code00FFP66P67_PM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			(*(uint32_t*)target)++;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_INC32;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			(*(uint32_t*)target)--;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_DEC32;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint16_t* sp = register16u(BR_SP);
			*sp -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint16_t newIP = *(uint16_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 16 / 8);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int32_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *(uint16_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand16Code00FFP67_PM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			(*(uint16_t*)target)++;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_INC16;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			(*(uint16_t*)target)--;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_DEC16;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t* sp = register16u(BR_SP);
			*sp -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t newIP = *(uint16_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 16 / 8);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int16_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *(uint16_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand16Code00FFP66_PM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			(*(uint32_t*)target)++;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_INC32;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			(*(uint32_t*)target)--;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_DEC32;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint16_t* sp = register16u(BR_SP);
			*sp -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			uint16_t newIP = *(uint16_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 16 / 8);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int32_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
			SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *(uint16_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand16Code00FF_PM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			(*(uint16_t*)target)++;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_INC16;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			(*(uint16_t*)target)--;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_DEC16;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t* sp = register16u(BR_SP);
			*sp -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint16_t newIP = *(uint16_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 16 / 8);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = SR_VALUE(SR_CS);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = ((uint16_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int16_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *(uint16_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//???
void handlerCommand16Code0101_PM() {
	LOG("%s","???");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			*(uint16_t*)target = 0x0019;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//J(cond)
void handlerCommand16Code0180_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x00 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0181_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x01 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0182_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x02 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0183_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x03 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0184_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x04 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0185_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x05 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0186_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x06 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0187_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x07 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0188_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x08 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code0189_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x09 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018A_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0A {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018B_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0B {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018C_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0C {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018D_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0D {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018E_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0E {
		context.index += address;
	}
}
//J(cond)
void handlerCommand16Code018F_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int16_t address = read16();
	if COND0x0F {
		context.index += address;
	}
}
//Math
void handlerCommand16Code0190P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x00;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x00 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0190_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x00;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x00 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0191P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x01;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x01 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0191_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x01;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x01 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0192P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x02;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x02 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0192_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x02;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x02 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0193P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x03;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x03 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0193_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x03;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x03 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0194P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x04;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x04 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0194_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x04;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x04 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0195P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x05;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x05 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0195_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x05;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x05 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0196P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x06;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x06 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0196_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x06;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x06 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0197P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x07;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x07 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0197_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x07;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x07 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0198P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x08;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x08 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0198_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x08;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x08 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0199P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x09;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x09 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code0199_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x09;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x09 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019AP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0A;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0A ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019A_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0A;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0A ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019BP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0B;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0B ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019B_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0B;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0B ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019CP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0C;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0C ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019C_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0C;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0C ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019DP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0D;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0D ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019D_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0D;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0D ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019EP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0E;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0E ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019E_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0E;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0E ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019FP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0F;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0F ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand16Code019F_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0F;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM16For8(mrmByte);
			// SET(cond)
			*target = COND0x0F ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//BT
void handlerCommand16Code01A3P66_PM() {
	LOG("%s","BT");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BT
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
}
//BT
void handlerCommand16Code01A3_PM() {
	LOG("%s","BT");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BT
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
}
//BTS
void handlerCommand16Code01ABP66_PM() {
	LOG("%s","BTS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTS
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
}
//BTS
void handlerCommand16Code01AB_PM() {
	LOG("%s","BTS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTS
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
}
//Mul
void handlerCommand16Code01AFP66_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = *(int32_t*)source;
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Mul
void handlerCommand16Code01AF_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = *(int16_t*)source;
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Load SR_SS
void handlerCommand16Code01B2_PM() {
	LOG("%s","Load SR_SS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_SS, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//BTR
void handlerCommand16Code01B3P66_PM() {
	LOG("%s","BTR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTR
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
}
//BTR
void handlerCommand16Code01B3_PM() {
	LOG("%s","BTR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTR
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
}
//Load SR_FS
void handlerCommand16Code01B4_PM() {
	LOG("%s","Load SR_FS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_FS, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//Load SR_GS
void handlerCommand16Code01B5_PM() {
	LOG("%s","Load SR_GS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_GS, *(uint16_t*)(target + 2));
	*(uint16_t*)source = *(uint16_t*)(target);
}
//MOVZX
void handlerCommand16Code01B6P66_PM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	*target = (uint32_t)*source;
}
//MOVZX
void handlerCommand16Code01B6_PM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint16_t* target = (uint16_t*)readRegisterMRM16(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	*target = (uint16_t)*source;
}
//MOVZX
void handlerCommand16Code01B7P66_PM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint16_t* source = (uint16_t*)readAddressMRM32For16(mrmByte);
	*target = (uint32_t)*source;
}
//MOVZX
void handlerCommand16Code01B7_PM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint16_t* source = (uint16_t*)readAddressMRM32For16(mrmByte);
	*target = (uint32_t)*source;
}
//Bit scan
void handlerCommand16Code01BAP66_PM() {
	LOG("%s","Bit scan");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BT
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTS
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTR
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTC
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			if (value) {
				(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
			} else {
				(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Bit scan
void handlerCommand16Code01BA_PM() {
	LOG("%s","Bit scan");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BT
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTS
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTR
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
			uint8_t shift = read8u();
			// BTC
			FillFlags();
			uint16_t mask = 1 << shift;
			uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			if (value) {
				(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
			} else {
				(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//BTC
void handlerCommand16Code01BBP66_PM() {
	LOG("%s","BTC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTC
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	if (value) {
		(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
	} else {
		(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
	}
}
//BTC
void handlerCommand16Code01BB_PM() {
	LOG("%s","BTC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint16_t shift = *(uint16_t*)source;
	// BTC
	FillFlags();
	uint16_t mask = 1 << shift;
	uint8_t value = ((*(uint16_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	if (value) {
		(*(uint16_t*)target) = (*(uint16_t*)target) & (~mask);
	} else {
		(*(uint16_t*)target) = (*(uint16_t*)target) | mask;
	}
}
//BFC
void handlerCommand16Code01BCP66_PM() {
	LOG("%s","BFC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	FillFlags();
	uint32_t value = *(uint32_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint32_t mask = 1;
	uint32_t len = 0;
	while ((mask & value) && (len < 32)) {
		value = value >> 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint32_t*)target = len;
}
//BFC
void handlerCommand16Code01BC_PM() {
	LOG("%s","BFC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	FillFlags();
	uint16_t value = *(uint16_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint16_t mask = 1;
	uint16_t len = 0;
	while ((mask & value) && (len < 16)) {
		value = value >> 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint16_t*)target = len;
}
//BSR
void handlerCommand16Code01BDP66_PM() {
	LOG("%s","BSR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	FillFlags();
	uint32_t value = *(uint32_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint32_t mask = 1 << (32 - 1);
	uint32_t len = 0;
	while ((mask & value) && (len < 32)) {
		value = value << 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint32_t*)target = len;
}
//BSR
void handlerCommand16Code01BD_PM() {
	LOG("%s","BSR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM16For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	FillFlags();
	uint16_t value = *(uint16_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint16_t mask = 1 << (16 - 1);
	uint16_t len = 0;
	while ((mask & value) && (len < 16)) {
		value = value << 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint16_t*)target = len;
}
//MOVSX
void handlerCommand16Code01BEP66_PM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int32_t* target = (int32_t*)readRegisterMRM32(mrmByte);
	int8_t* source = (int8_t*)readAddressMRM32For8(mrmByte);
	*target = (int32_t)*source;
}
//MOVSX
void handlerCommand16Code01BE_PM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int16_t* target = (int16_t*)readRegisterMRM16(mrmByte);
	int8_t* source = (int8_t*)readAddressMRM32For8(mrmByte);
	*target = (int16_t)*source;
}
//MOVSX
void handlerCommand16Code01BF_PM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int32_t* target = (int32_t*)readRegisterMRM32(mrmByte);
	int16_t* source = (int16_t*)readAddressMRM32For16(mrmByte);
	*target = (int32_t)*source;
}
//Swap
void handlerCommand16Code01C8_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01C9_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CA_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CB_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CC_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CD_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CE_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand16Code01CF_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//ADD
void handlerCommand32Code0000P66_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0000_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0001P66_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_ADD16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand32Code0001_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_ADD32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand32Code0002P66_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0002_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_ADD8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0003P66_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_ADD16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand32Code0003_PM() {
	LOG("%s","ADD");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_ADD32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADD
void handlerCommand32Code0004P66_PM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_ADD8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0004_PM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_ADD8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADD
void handlerCommand32Code0005P66_PM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_ADD16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//ADD
void handlerCommand32Code0005_PM() {
	LOG("%s","ADD");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_ADD32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//Push
void handlerCommand32Code0006_PM() {
	LOG("%s","Push");
	uint8_t rg = 0x00;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(rg);
}
//Push
void handlerCommand32Code000E_PM() {
	LOG("%s","Push");
	uint8_t rg = 0x01;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(rg);
}
//Push
void handlerCommand32Code0016_PM() {
	LOG("%s","Push");
	uint8_t rg = 0x02;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(rg);
}
//Push
void handlerCommand32Code001E_PM() {
	LOG("%s","Push");
	uint8_t rg = 0x03;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(rg);
}
//Pop
void handlerCommand32Code0007_PM() {
	LOG("%s","Pop");
	uint8_t rg = 0x00;
	    SET_VALUE_IN_SEGMENT_P(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	    reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code000F_PM() {
	LOG("%s","Pop");
	uint8_t rg = 0x01;
	// 0f???
}
//Pop
void handlerCommand32Code0017_PM() {
	LOG("%s","Pop");
	uint8_t rg = 0x02;
	    SET_VALUE_IN_SEGMENT_P(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	    reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code001F_PM() {
	LOG("%s","Pop");
	uint8_t rg = 0x03;
	    SET_VALUE_IN_SEGMENT_P(rg, *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	    reg_SP_32u += 16 / 8;
}
//OR
void handlerCommand32Code0008P66_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code0008_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code0009P66_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_OR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand32Code0009_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_OR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand32Code000AP66_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code000A_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_OR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code000BP66_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_OR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand32Code000B_PM() {
	LOG("%s","OR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_OR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//OR
void handlerCommand32Code000CP66_PM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_OR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code000C_PM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_OR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//OR
void handlerCommand32Code000DP66_PM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_OR16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//OR
void handlerCommand32Code000D_PM() {
	LOG("%s","OR");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_OR32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand32Code0010P66_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0010_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0011P66_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
	lazyFlagType = t_ADC16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand32Code0011_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
	lazyFlagType = t_ADC32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand32Code0012P66_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0012_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
	lazyFlagType = t_ADC8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0013P66_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
	lazyFlagType = t_ADC16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand32Code0013_PM() {
	LOG("%s","ADC");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
	lazyFlagType = t_ADC32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//ADC
void handlerCommand32Code0014P66_PM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) + oldcf;
	lazyFlagType = t_ADC8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0014_PM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8)) + oldcf;
	lazyFlagType = t_ADC8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//ADC
void handlerCommand32Code0015P66_PM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16)) + oldcf;
	lazyFlagType = t_ADC16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//ADC
void handlerCommand32Code0015_PM() {
	LOG("%s","ADC");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32)) + oldcf;
	lazyFlagType = t_ADC32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand32Code0018P66_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code0018_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code0019P66_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
	lazyFlagType = t_SBB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand32Code0019_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
	lazyFlagType = t_SBB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand32Code001AP66_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code001A_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
	lazyFlagType = t_SBB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code001BP66_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
	lazyFlagType = t_SBB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand32Code001B_PM() {
	LOG("%s","SBB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
	lazyFlagType = t_SBB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SBB
void handlerCommand32Code001CP66_PM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) - oldcf;
	lazyFlagType = t_SBB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code001C_PM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) - oldcf;
	lazyFlagType = t_SBB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SBB
void handlerCommand32Code001DP66_PM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) - oldcf;
	lazyFlagType = t_SBB16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//SBB
void handlerCommand32Code001D_PM() {
	LOG("%s","SBB");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	FillFlags();
	oldcf = GET_FLAG(CF);
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) - oldcf;
	lazyFlagType = t_SBB32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand32Code0020P66_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0020_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0021P66_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_AND16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand32Code0021_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_AND32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand32Code0022P66_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0022_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_AND8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0023P66_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_AND16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand32Code0023_PM() {
	LOG("%s","AND");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_AND32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//AND
void handlerCommand32Code0024P66_PM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_AND8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0024_PM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_AND8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//AND
void handlerCommand32Code0025P66_PM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_AND16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//AND
void handlerCommand32Code0025_PM() {
	LOG("%s","AND");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_AND32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand32Code0028P66_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code0028_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code0029P66_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_SUB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand32Code0029_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_SUB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand32Code002AP66_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code002A_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_SUB8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code002BP66_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_SUB16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand32Code002B_PM() {
	LOG("%s","SUB");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_SUB32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//SUB
void handlerCommand32Code002CP66_PM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_SUB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code002C_PM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_SUB8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//SUB
void handlerCommand32Code002DP66_PM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_SUB16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//SUB
void handlerCommand32Code002D_PM() {
	LOG("%s","SUB");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_SUB32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand32Code0030P66_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0030_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0031P66_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_XOR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand32Code0031_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_XOR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand32Code0032P66_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0032_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_XOR8;
	*(int8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0033P66_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_XOR16;
	*(int16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand32Code0033_PM() {
	LOG("%s","XOR");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_XOR32;
	*(int32_t*)target = LazyFlagResultContainer32;
}
//XOR
void handlerCommand32Code0034P66_PM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_XOR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0034_PM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_XOR8;
	*(uint8_t*)target = LazyFlagResultContainer8;
}
//XOR
void handlerCommand32Code0035P66_PM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_XOR16;
	*(uint16_t*)target = LazyFlagResultContainer16;
}
//XOR
void handlerCommand32Code0035_PM() {
	LOG("%s","XOR");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_XOR32;
	*(uint32_t*)target = LazyFlagResultContainer32;
}
//CMP
void handlerCommand32Code0038P66_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code0038_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code0039P66_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand32Code0039_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand32Code003AP66_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code003A_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code003BP66_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand32Code003B_PM() {
	LOG("%s","CMP");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_CMP32;
}
//CMP
void handlerCommand32Code003CP66_PM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code003C_PM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_CMP8;
}
//CMP
void handlerCommand32Code003DP66_PM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_CMP16;
}
//CMP
void handlerCommand32Code003D_PM() {
	LOG("%s","CMP");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_CMP32;
}
//Inc
void handlerCommand32Code0040P66_PM() {
	LOG("%s","Inc");
	reg_0x00_16u += 1;
	LazyFlagResultContainer16 = reg_0x00_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0040_PM() {
	LOG("%s","Inc");
	reg_0x00_32u += 1;
	LazyFlagResultContainer32 = reg_0x00_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0041P66_PM() {
	LOG("%s","Inc");
	reg_0x01_16u += 1;
	LazyFlagResultContainer16 = reg_0x01_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0041_PM() {
	LOG("%s","Inc");
	reg_0x01_32u += 1;
	LazyFlagResultContainer32 = reg_0x01_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0042P66_PM() {
	LOG("%s","Inc");
	reg_0x02_16u += 1;
	LazyFlagResultContainer16 = reg_0x02_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0042_PM() {
	LOG("%s","Inc");
	reg_0x02_32u += 1;
	LazyFlagResultContainer32 = reg_0x02_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0043P66_PM() {
	LOG("%s","Inc");
	reg_0x03_16u += 1;
	LazyFlagResultContainer16 = reg_0x03_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0043_PM() {
	LOG("%s","Inc");
	reg_0x03_32u += 1;
	LazyFlagResultContainer32 = reg_0x03_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0044P66_PM() {
	LOG("%s","Inc");
	reg_0x04_16u += 1;
	LazyFlagResultContainer16 = reg_0x04_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0044_PM() {
	LOG("%s","Inc");
	reg_0x04_32u += 1;
	LazyFlagResultContainer32 = reg_0x04_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0045P66_PM() {
	LOG("%s","Inc");
	reg_0x05_16u += 1;
	LazyFlagResultContainer16 = reg_0x05_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0045_PM() {
	LOG("%s","Inc");
	reg_0x05_32u += 1;
	LazyFlagResultContainer32 = reg_0x05_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0046P66_PM() {
	LOG("%s","Inc");
	reg_0x06_16u += 1;
	LazyFlagResultContainer16 = reg_0x06_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0046_PM() {
	LOG("%s","Inc");
	reg_0x06_32u += 1;
	LazyFlagResultContainer32 = reg_0x06_32u;
	lazyFlagType = t_INC32;
}
//Inc
void handlerCommand32Code0047P66_PM() {
	LOG("%s","Inc");
	reg_0x07_16u += 1;
	LazyFlagResultContainer16 = reg_0x07_16u;
	lazyFlagType = t_INC16;
}
//Inc
void handlerCommand32Code0047_PM() {
	LOG("%s","Inc");
	reg_0x07_32u += 1;
	LazyFlagResultContainer32 = reg_0x07_32u;
	lazyFlagType = t_INC32;
}
//Dec
void handlerCommand32Code0048P66_PM() {
	LOG("%s","Dec");
	reg_0x00_16u -= 1;
	LazyFlagResultContainer16 = reg_0x00_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code0048_PM() {
	LOG("%s","Dec");
	reg_0x00_32u -= 1;
	LazyFlagResultContainer32 = reg_0x00_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code0049P66_PM() {
	LOG("%s","Dec");
	reg_0x01_16u -= 1;
	LazyFlagResultContainer16 = reg_0x01_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code0049_PM() {
	LOG("%s","Dec");
	reg_0x01_32u -= 1;
	LazyFlagResultContainer32 = reg_0x01_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004AP66_PM() {
	LOG("%s","Dec");
	reg_0x02_16u -= 1;
	LazyFlagResultContainer16 = reg_0x02_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004A_PM() {
	LOG("%s","Dec");
	reg_0x02_32u -= 1;
	LazyFlagResultContainer32 = reg_0x02_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004BP66_PM() {
	LOG("%s","Dec");
	reg_0x03_16u -= 1;
	LazyFlagResultContainer16 = reg_0x03_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004B_PM() {
	LOG("%s","Dec");
	reg_0x03_32u -= 1;
	LazyFlagResultContainer32 = reg_0x03_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004CP66_PM() {
	LOG("%s","Dec");
	reg_0x04_16u -= 1;
	LazyFlagResultContainer16 = reg_0x04_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004C_PM() {
	LOG("%s","Dec");
	reg_0x04_32u -= 1;
	LazyFlagResultContainer32 = reg_0x04_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004DP66_PM() {
	LOG("%s","Dec");
	reg_0x05_16u -= 1;
	LazyFlagResultContainer16 = reg_0x05_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004D_PM() {
	LOG("%s","Dec");
	reg_0x05_32u -= 1;
	LazyFlagResultContainer32 = reg_0x05_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004EP66_PM() {
	LOG("%s","Dec");
	reg_0x06_16u -= 1;
	LazyFlagResultContainer16 = reg_0x06_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004E_PM() {
	LOG("%s","Dec");
	reg_0x06_32u -= 1;
	LazyFlagResultContainer32 = reg_0x06_32u;
	lazyFlagType = t_DEC32;
}
//Dec
void handlerCommand32Code004FP66_PM() {
	LOG("%s","Dec");
	reg_0x07_16u -= 1;
	LazyFlagResultContainer16 = reg_0x07_16u;
	lazyFlagType = t_DEC16;
}
//Dec
void handlerCommand32Code004F_PM() {
	LOG("%s","Dec");
	reg_0x07_32u -= 1;
	LazyFlagResultContainer32 = reg_0x07_32u;
	lazyFlagType = t_DEC32;
}
//Push
void handlerCommand32Code0050P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint16_t value = reg_0x00_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0050P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0050P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint16_t value = reg_0x00_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0050_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0051P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint16_t value = reg_0x01_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0051P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0051P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint16_t value = reg_0x01_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0051_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0052P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint16_t value = reg_0x02_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0052P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0052P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint16_t value = reg_0x02_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0052_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0053P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint16_t value = reg_0x03_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0053P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0053P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint16_t value = reg_0x03_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0053_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0054P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint16_t value = reg_0x04_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0054P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0054P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint16_t value = reg_0x04_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0054_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0055P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint16_t value = reg_0x05_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0055P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0055P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint16_t value = reg_0x05_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0055_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0056P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint16_t value = reg_0x06_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0056P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0056P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint16_t value = reg_0x06_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0056_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0057P66P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint16_t value = reg_0x07_16u;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0057P67_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = value;
}
//Push
void handlerCommand32Code0057P66_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint16_t value = reg_0x07_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Push
void handlerCommand32Code0057_PM() {
	LOG("%s","Push");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = value;
}
//Pop
void handlerCommand32Code0058P66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code0058P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code0058P66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code0058_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x00;
	reg_0x00_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code0059P66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code0059P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code0059P66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code0059_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x01;
	reg_0x01_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005AP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005AP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005AP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005A_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x02;
	reg_0x02_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005BP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005BP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005BP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005B_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x03;
	reg_0x03_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005CP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005CP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005CP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005C_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x04;
	reg_0x04_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005DP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005DP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005DP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005D_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x05;
	reg_0x05_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005EP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005EP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005EP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005E_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x06;
	reg_0x06_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Pop
void handlerCommand32Code005FP66P67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Pop
void handlerCommand32Code005FP67_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Pop
void handlerCommand32Code005FP66_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Pop
void handlerCommand32Code005F_PM() {
	LOG("%s","Pop");
	uint8_t reg = 0x07;
	reg_0x07_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//PUSHA
void handlerCommand32Code0060P66_PM() {
	LOG("%s","PUSHA");
	uint16_t tmp = reg_SP_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_AX_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_CX_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_DX_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BX_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = tmp;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SI_16u;
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_DI_16u;
}
//PUSHA
void handlerCommand32Code0060_PM() {
	LOG("%s","PUSHA");
	uint32_t tmp = reg_SP_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_AX_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_CX_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_DX_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BX_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = tmp;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SI_32u;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_DI_32u;
}
//POPA
void handlerCommand32Code0061P66_PM() {
	LOG("%s","POPA");
	reg_DI_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_SI_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_BP_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_SP_32u += 16 / 8;
	reg_BX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_DX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_CX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
	reg_AX_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//POPA
void handlerCommand32Code0061_PM() {
	LOG("%s","POPA");
	reg_DI_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_SI_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_BP_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_SP_32u += 32 / 8;
	reg_BX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_DX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_CX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
	reg_AX_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Push
void handlerCommand32Code0068P66P67_PM() {
	LOG("%s","Push");
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = read16u();
}
//Push
void handlerCommand32Code0068P67_PM() {
	LOG("%s","Push");
	reg_SP_16u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = read32u();
}
//Push
void handlerCommand32Code0068P66_PM() {
	LOG("%s","Push");
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = read16u();
}
//Push
void handlerCommand32Code0068_PM() {
	LOG("%s","Push");
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = read32u();
}
//Mul
void handlerCommand32Code0069P66_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = read16();
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Mul
void handlerCommand32Code0069_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = read32();
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Push
void handlerCommand32Code006AP66P67_PM() {
	LOG("%s","Push");
	reg_SP_16u -= 16 / 8;
	*(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = (int16_t)read8();
}
//Push
void handlerCommand32Code006AP67_PM() {
	LOG("%s","Push");
	reg_SP_16u -= 32 / 8;
	*(int32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = (int32_t)read8();
}
//Push
void handlerCommand32Code006AP66_PM() {
	LOG("%s","Push");
	reg_SP_32u -= 16 / 8;
	*(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = (int16_t)read8();
}
//Push
void handlerCommand32Code006A_PM() {
	LOG("%s","Push");
	reg_SP_32u -= 32 / 8;
	*(int32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = (int32_t)read8();
}
//Mul
void handlerCommand32Code006B_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = (int32_t)read8();
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//J(cond)
void handlerCommand32Code0070_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x00 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0071_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x01 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0072_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x02 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0073_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x03 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0074_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x04 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0075_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x05 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0076_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x06 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0077_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x07 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0078_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x08 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0079_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x09 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007A_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0A {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007B_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0B {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007C_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0C {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007D_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0D {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007E_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0E {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code007F_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int8_t address = read8();
	if COND0x0F {
		context.index += address;
	}
}
//Math
void handlerCommand32Code0080P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0080_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) | ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) + ((uint8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) ^ ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((uint8_t)read8u());
			LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) - ((uint8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0081P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_ADD16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) | ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_OR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) + ((uint16_t)LazyFlagVarB16) + oldcf;
			lazyFlagType = t_ADC16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) - oldcf;
			lazyFlagType = t_SBB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_AND16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_SUB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) ^ ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_XOR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((uint16_t)read16u());
			LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) - ((uint16_t)LazyFlagVarB16) ;
			lazyFlagType = t_CMP16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0081_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_ADD32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) | ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_OR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) + ((uint32_t)LazyFlagVarB32) + oldcf;
			lazyFlagType = t_ADC32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) - oldcf;
			lazyFlagType = t_SBB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_AND32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_SUB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) ^ ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_XOR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((uint32_t)read32u());
			LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) - ((uint32_t)LazyFlagVarB32) ;
			lazyFlagType = t_CMP32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0082_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) + ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_ADD8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) | ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_OR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) + ((int8_t)LazyFlagVarB8) + oldcf;
			lazyFlagType = t_ADC8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) - oldcf;
			lazyFlagType = t_SBB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) & ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_AND8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_SUB8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) ^ ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_XOR8;
			*(int8_t*)target = LazyFlagResultContainer8;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = ((int8_t)read8());
			LazyFlagResultContainer8 = ((int8_t)LazyFlagVarA8) - ((int8_t)LazyFlagVarB8) ;
			lazyFlagType = t_CMP8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0083P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) + ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_ADD16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) | ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_OR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) + ((int16_t)LazyFlagVarB16) + oldcf;
			lazyFlagType = t_ADC16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) - oldcf;
			lazyFlagType = t_SBB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) & ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_AND16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_SUB16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) ^ ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_XOR16;
			*(int16_t*)target = LazyFlagResultContainer16;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = ((int16_t)read8());
			LazyFlagResultContainer16 = ((int16_t)LazyFlagVarA16) - ((int16_t)LazyFlagVarB16) ;
			lazyFlagType = t_CMP16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0083_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) + ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_ADD32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) | ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_OR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) + ((int32_t)LazyFlagVarB32) + oldcf;
			lazyFlagType = t_ADC32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			FillFlags();
			oldcf = GET_FLAG(CF);
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) - oldcf;
			lazyFlagType = t_SBB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) & ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_AND32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_SUB32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) ^ ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_XOR32;
			*(int32_t*)target = LazyFlagResultContainer32;
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = ((int32_t)read8());
			LazyFlagResultContainer32 = ((int32_t)LazyFlagVarA32) - ((int32_t)LazyFlagVarB32) ;
			lazyFlagType = t_CMP32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//TEST
void handlerCommand32Code0084P66_PM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand32Code0084_PM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	LazyFlagVarA8 = *(int8_t*)target;
	LazyFlagVarB8 = *(int8_t*)source;
	LazyFlagResultContainer8 = ((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand32Code0085P66_PM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	LazyFlagVarA16 = *(int16_t*)target;
	LazyFlagVarB16 = *(int16_t*)source;
	LazyFlagResultContainer16 = ((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16) ;
	lazyFlagType = t_TEST16;
}
//TEST
void handlerCommand32Code0085_PM() {
	LOG("%s","TEST");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	LazyFlagVarA32 = *(int32_t*)target;
	LazyFlagVarB32 = *(int32_t*)source;
	LazyFlagResultContainer32 = ((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32) ;
	lazyFlagType = t_TEST32;
}
//XCHG
void handlerCommand32Code0086P66_PM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t tmp = *(uint32_t*)target;
	*(uint32_t*)target = *(uint32_t*)source;
	*(uint32_t*)source = tmp;
}
//XCHG
void handlerCommand32Code0086_PM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t tmp = *(uint32_t*)target;
	*(uint32_t*)target = *(uint32_t*)source;
	*(uint32_t*)source = tmp;
}
//XCHG
void handlerCommand32Code0087P66_PM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t tmp = *(uint32_t*)target;
	*(uint32_t*)target = *(uint32_t*)source;
	*(uint32_t*)source = tmp;
}
//XCHG
void handlerCommand32Code0087_PM() {
	LOG("%s","XCHG");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t tmp = *(uint32_t*)target;
	*(uint32_t*)target = *(uint32_t*)source;
	*(uint32_t*)source = tmp;
}
//Move
void handlerCommand32Code0088P66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code0088_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code0089P66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code0089_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code008AP66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code008A_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM8(mrmByte);
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code008BP66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM16(mrmByte);
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code008B_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code008C_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t sr = readMiddle3Bit(mrmByte);
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readSegmentRegisterMRM;
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code008E_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t sr = readMiddle3Bit(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* target = (uint8_t*)readSegmentRegisterMRM;
	*(uint16_t*)target = *(uint16_t*)source;
	recalculatePointerSegmentRegisterMRM_P
}
//Lea
void handlerCommand32Code008DP66P67_PM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint32_t target = effectiveAddressMRM32For32(mrmByte);
	*((uint16_t*)source) = (uint16_t)(target & 0xFFFF);
}
//Lea
void handlerCommand32Code008DP67_PM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t target = effectiveAddressMRM32For32(mrmByte);
	*((uint32_t*)source) = (uint32_t)(target & 0xFFFFFFFF);
}
//Lea
void handlerCommand32Code008DP66_PM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	uint32_t target = effectiveAddressMRM32For32(mrmByte);
	*((uint16_t*)source) = (uint16_t)(target & 0xFFFF);
}
//Lea
void handlerCommand32Code008D_PM() {
	LOG("%s","Lea");
	uint8_t mrmByte = read8u();
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t target = effectiveAddressMRM32For32(mrmByte);
	*((uint32_t*)source) = (uint32_t)(target & 0xFFFFFFFF);
}
//Pop
void handlerCommand32Code008FP66P67_PM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			*(uint16_t*)target = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
			reg_SP_16u += 16 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand32Code008FP67_PM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			*(uint32_t*)target = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
			reg_SP_16u += 32 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand32Code008FP66_PM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			*(uint16_t*)target = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
			reg_SP_32u += 16 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Pop
void handlerCommand32Code008F_PM() {
	LOG("%s","Pop");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			*(uint32_t*)target = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
			reg_SP_32u += 32 / 8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//XCHG
void handlerCommand32Code0090P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x00;
	// NOP
}
//XCHG
void handlerCommand32Code0090_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x00;
	// NOP
}
//XCHG
void handlerCommand32Code0091P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x01;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x01_32u;
	reg_0x01_32u = tmp;
}
//XCHG
void handlerCommand32Code0091_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x01;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x01_32u;
	reg_0x01_32u = tmp;
}
//XCHG
void handlerCommand32Code0092P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x02;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x02_32u;
	reg_0x02_32u = tmp;
}
//XCHG
void handlerCommand32Code0092_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x02;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x02_32u;
	reg_0x02_32u = tmp;
}
//XCHG
void handlerCommand32Code0093P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x03;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x03_32u;
	reg_0x03_32u = tmp;
}
//XCHG
void handlerCommand32Code0093_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x03;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x03_32u;
	reg_0x03_32u = tmp;
}
//XCHG
void handlerCommand32Code0094P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x04;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x04_32u;
	reg_0x04_32u = tmp;
}
//XCHG
void handlerCommand32Code0094_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x04;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x04_32u;
	reg_0x04_32u = tmp;
}
//XCHG
void handlerCommand32Code0095P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x05;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x05_32u;
	reg_0x05_32u = tmp;
}
//XCHG
void handlerCommand32Code0095_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x05;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x05_32u;
	reg_0x05_32u = tmp;
}
//XCHG
void handlerCommand32Code0096P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x06;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x06_32u;
	reg_0x06_32u = tmp;
}
//XCHG
void handlerCommand32Code0096_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x06;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x06_32u;
	reg_0x06_32u = tmp;
}
//XCHG
void handlerCommand32Code0097P66_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x07;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x07_32u;
	reg_0x07_32u = tmp;
}
//XCHG
void handlerCommand32Code0097_PM() {
	LOG("%s","XCHG");
	uint8_t reg = 0x07;
	uint32_t tmp = reg_AX_32u;
	reg_AX_32u = reg_0x07_32u;
	reg_0x07_32u = tmp;
}
//CBW
void handlerCommand32Code0098P66_PM() {
	LOG("%s","CBW");
	reg_AX_16 = reg_AL_8;
}
//CBW
void handlerCommand32Code0098_PM() {
	LOG("%s","CBW");
	reg_AX_32 = reg_AX_16;
}
//CBW
void handlerCommand32Code0099P66_PM() {
	LOG("%s","CBW");
	if (reg_AX_16 & 0x8000) reg_DX_16=0xffff;else reg_DX_16=0;
}
//CBW
void handlerCommand32Code0099_PM() {
	LOG("%s","CBW");
	if (reg_AX_32 & 0x80000000) reg_DX_32=0xffffffff; else reg_DX_32=0;
}
//Call
void handlerCommand32Code009A_PM() {
	LOG("%s","Call");
	uint32_t newIP = read32u();
	uint16_t newCS = read16u();
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
	SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
	context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
}
//PUSHF
void handlerCommand32Code009CP66_PM() {
	LOG("%s","PUSHF");
	FillFlags();
	reg_SP_32u -= 16 / 8;
	EncodeFlagsRegister();
	uint32_t value = reg_flags & 0xFCFFFF;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *((uint16_t*)&value);
}
//PUSHF
void handlerCommand32Code009C_PM() {
	LOG("%s","PUSHF");
	FillFlags();
	reg_SP_32u -= 32 / 8;
	EncodeFlagsRegister();
	uint32_t value = reg_flags & 0xFCFFFF;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *((uint32_t*)&value);
}
//POPF
void handlerCommand32Code009DP66_PM() {
	LOG("%s","POPF");
	lazyFlagType = t_UNKNOWN;
	*(uint16_t*)(&reg_flags) = (*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	reg_SP_32u += 16 / 8;
	DecodeFlagsRegister16();
}
//POPF
void handlerCommand32Code009D_PM() {
	LOG("%s","POPF");
	lazyFlagType = t_UNKNOWN;
	*(uint32_t*)(&reg_flags) = (*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u));
	reg_SP_32u += 32 / 8;
	DecodeFlagsRegister32();
}
//Move
void handlerCommand32Code00A0P66P67_PM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A0P66_PM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A0P67_PM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A0_PM() {
	LOG("%s","Move");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	uint8_t* source = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A1P66P67_PM() {
	LOG("%s","Move");
	uint16_t* target = (uint16_t*)register16u(BR_AX);
	uint16_t* source = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code00A1P66_PM() {
	LOG("%s","Move");
	uint16_t* target = (uint16_t*)register16u(BR_AX);
	uint16_t* source = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code00A1P67_PM() {
	LOG("%s","Move");
	uint32_t* target = (uint32_t*)register32u(BR_AX);
	uint32_t* source = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code00A1_PM() {
	LOG("%s","Move");
	uint32_t* target = (uint32_t*)register32u(BR_AX);
	uint32_t* source = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code00A2P66P67_PM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A2P66_PM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A2P67_PM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A2_PM() {
	LOG("%s","Move");
	uint8_t* source = (uint8_t*)register8u(BR_AX);
	uint8_t* target = (uint8_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint8_t*)target = *(uint8_t*)source;
}
//Move
void handlerCommand32Code00A3P66P67_PM() {
	LOG("%s","Move");
	uint16_t* source = (uint16_t*)register16u(BR_AX);
	uint16_t* target = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code00A3P66_PM() {
	LOG("%s","Move");
	uint16_t* source = (uint16_t*)register16u(BR_AX);
	uint16_t* target = (uint16_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint16_t*)target = *(uint16_t*)source;
}
//Move
void handlerCommand32Code00A3P67_PM() {
	LOG("%s","Move");
	uint32_t* source = (uint32_t*)register32u(BR_AX);
	uint32_t* target = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read16());
	*(uint32_t*)target = *(uint32_t*)source;
}
//Move
void handlerCommand32Code00A3_PM() {
	LOG("%s","Move");
	uint32_t* source = (uint32_t*)register32u(BR_AX);
	uint32_t* target = (uint32_t*)(GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS) + read32());
	*(uint32_t*)target = *(uint32_t*)source;
}
//MOVS
void handlerCommand32Code00A4P66P67_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A4P66_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A4P67_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A4_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A5P66P67_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A5P66_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A5P67_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
		}
	}
}
//MOVS
void handlerCommand32Code00A5_PM() {
	LOG("%s","MOVS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A6P66P67_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A6P66_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A6P67_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_16u) - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;reg_SI_16u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A6_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = *(uint8_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = *(uint8_t*)(sourceSegment + reg_SI_32u) - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;reg_SI_32u += 8 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A7P66P67_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u -= 16 / 8;reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_16u) - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u += 16 / 8;reg_SI_16u += 16 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A7P66_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u -= 16 / 8;reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = *(uint16_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = *(uint16_t*)(sourceSegment + reg_SI_32u) - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u += 16 / 8;reg_SI_32u += 16 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A7P67_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u -= 32 / 8;reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_16u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_16u) - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u += 32 / 8;reg_SI_16u += 32 / 8;
		}
	}
}
//CMPS
void handlerCommand32Code00A7_PM() {
	LOG("%s","CMPS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u -= 32 / 8;reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = *(uint32_t*)(sourceSegment + reg_SI_32u);
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = *(uint32_t*)(sourceSegment + reg_SI_32u) - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u += 32 / 8;reg_SI_32u += 32 / 8;
		}
	}
}
//TEST
void handlerCommand32Code00A8P66_PM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand32Code00A8_PM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register8u(BR_AX);
	LazyFlagVarA8 = *(uint8_t*)target;
	LazyFlagVarB8 = read8u();
	LazyFlagResultContainer8 = (((uint8_t)LazyFlagVarA8) & ((uint8_t)LazyFlagVarB8)) ;
	lazyFlagType = t_TEST8;
}
//TEST
void handlerCommand32Code00A9P66_PM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register16u(BR_AX);
	LazyFlagVarA16 = *(uint16_t*)target;
	LazyFlagVarB16 = read16u();
	LazyFlagResultContainer16 = (((uint16_t)LazyFlagVarA16) & ((uint16_t)LazyFlagVarB16)) ;
	lazyFlagType = t_TEST16;
}
//TEST
void handlerCommand32Code00A9_PM() {
	LOG("%s","TEST");
	uint8_t* target = (uint8_t*)register32u(BR_AX);
	LazyFlagVarA32 = *(uint32_t*)target;
	LazyFlagVarB32 = read32u();
	LazyFlagResultContainer32 = (((uint32_t)LazyFlagVarA32) & ((uint32_t)LazyFlagVarB32)) ;
	lazyFlagType = t_TEST32;
}
//STOS
void handlerCommand32Code00AAP66P67_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00AAP66_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00AAP67_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_16u) = reg_0x00_8u;
			reg_DI_16u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00AA_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint8_t*)(targetSegment + reg_DI_32u) = reg_0x00_8u;
			reg_DI_32u += 8 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00ABP66P67_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
			reg_DI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_16u) = reg_0x00_16u;
			reg_DI_16u += 16 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00ABP66_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
			reg_DI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint16_t*)(targetSegment + reg_DI_32u) = reg_0x00_16u;
			reg_DI_32u += 16 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00ABP67_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
			reg_DI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_16u) = reg_0x00_32u;
			reg_DI_16u += 32 / 8;
		}
	}
}
//STOS
void handlerCommand32Code00AB_PM() {
	LOG("%s","STOS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
			reg_DI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			*(uint32_t*)(targetSegment + reg_DI_32u) = reg_0x00_32u;
			reg_DI_32u += 32 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ACP66P67_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ACP66_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ACP67_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 8 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00AC_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 8 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_8u = *(uint8_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 8 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ADP66P67_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 16 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 16 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ADP66_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 16 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_16u = *(uint16_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 16 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00ADP67_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u -= 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_16 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
				reg_SI_16u += 32 / 8;
				reg_CX_16u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_16u);
			reg_SI_16u += 32 / 8;
		}
	}
}
//LOADS
void handlerCommand32Code00AD_PM() {
	LOG("%s","LOADS");
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u -= 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix != 0) {
			while (reg_CX_32 != 0) {
				reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
				reg_SI_32u += 32 / 8;
				reg_CX_32u -= 1;
			}
		} else {
			reg_0x00_32u = *(uint32_t*)(sourceSegment + reg_SI_32u);
			reg_SI_32u += 32 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AEP66P67_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AEP66_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AEP67_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u -= 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_16u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP8;
				reg_DI_16u += 8 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP8;
			reg_DI_16u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AE_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u -= 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u -= 8 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) == reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint8_t*)(targetSegment + reg_DI_32u) != reg_0x00_8u;
				LazyFlagVarA8 = reg_0x00_8u;
				LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP8;
				reg_DI_32u += 8 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA8 = reg_0x00_8u;
			LazyFlagVarB8 = *(uint8_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer8 = reg_0x00_8u - *(uint8_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP8;
			reg_DI_32u += 8 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AFP66P67_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u -= 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_16u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP16;
				reg_DI_16u += 16 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP16;
			reg_DI_16u += 16 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AFP66_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u -= 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u -= 16 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) == reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint16_t*)(targetSegment + reg_DI_32u) != reg_0x00_16u;
				LazyFlagVarA16 = reg_0x00_16u;
				LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP16;
				reg_DI_32u += 16 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA16 = reg_0x00_16u;
			LazyFlagVarB16 = *(uint16_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer16 = reg_0x00_16u - *(uint16_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP16;
			reg_DI_32u += 16 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AFP67_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u -= 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_16 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_16u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
				lazyFlagType = t_CMP32;
				reg_DI_16u += 32 / 8;
				reg_CX_16u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_16u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_16u);
			lazyFlagType = t_CMP32;
			reg_DI_16u += 32 / 8;
		}
	}
}
//SCAS
void handlerCommand32Code00AF_PM() {
	LOG("%s","SCAS");
	lazyFlagType = t_UNKNOWN;
	uint8_t* sourceSegment = GET_SEGMENT_POINTER_WITH_REPLACE(SR_DS);
	uint8_t* targetSegment = GET_SEGMENT_POINTER(SR_ES);
	if (GET_FLAG(DF)) {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u -= 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u -= 32 / 8;
		}
	} else {
		if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF2) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) == reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 == 1));  return; }
			}
		} else if (context.lastCommandInfo.prefixInfo.commandPrefix == 0xF3) {
			while (reg_CX_32 != 0) {
				uint8_t result = *(uint32_t*)(targetSegment + reg_DI_32u) != reg_0x00_32u;
				LazyFlagVarA32 = reg_0x00_32u;
				LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
				LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
				lazyFlagType = t_CMP32;
				reg_DI_32u += 32 / 8;
				reg_CX_32u -= 1;
				if (result) { SET_FLAG(ZF, (1 != 1));  return; }
			}
		} else {
			LazyFlagVarA32 = reg_0x00_32u;
			LazyFlagVarB32 = *(uint32_t*)(targetSegment + reg_DI_32u);
			LazyFlagResultContainer32 = reg_0x00_32u - *(uint32_t*)(targetSegment + reg_DI_32u);
			lazyFlagType = t_CMP32;
			reg_DI_32u += 32 / 8;
		}
	}
}
//Move
void handlerCommand32Code00B0P66_PM() {
	LOG("%s","Move");
	reg_0x00_8u = read8u();
}
//Move
void handlerCommand32Code00B0_PM() {
	LOG("%s","Move");
	reg_0x00_8u = read8u();
}
//Move
void handlerCommand32Code00B1P66_PM() {
	LOG("%s","Move");
	reg_0x01_8u = read8u();
}
//Move
void handlerCommand32Code00B1_PM() {
	LOG("%s","Move");
	reg_0x01_8u = read8u();
}
//Move
void handlerCommand32Code00B2P66_PM() {
	LOG("%s","Move");
	reg_0x02_8u = read8u();
}
//Move
void handlerCommand32Code00B2_PM() {
	LOG("%s","Move");
	reg_0x02_8u = read8u();
}
//Move
void handlerCommand32Code00B3P66_PM() {
	LOG("%s","Move");
	reg_0x03_8u = read8u();
}
//Move
void handlerCommand32Code00B3_PM() {
	LOG("%s","Move");
	reg_0x03_8u = read8u();
}
//Move
void handlerCommand32Code00B4P66_PM() {
	LOG("%s","Move");
	reg_0x04_8u = read8u();
}
//Move
void handlerCommand32Code00B4_PM() {
	LOG("%s","Move");
	reg_0x04_8u = read8u();
}
//Move
void handlerCommand32Code00B5P66_PM() {
	LOG("%s","Move");
	reg_0x05_8u = read8u();
}
//Move
void handlerCommand32Code00B5_PM() {
	LOG("%s","Move");
	reg_0x05_8u = read8u();
}
//Move
void handlerCommand32Code00B6P66_PM() {
	LOG("%s","Move");
	reg_0x06_8u = read8u();
}
//Move
void handlerCommand32Code00B6_PM() {
	LOG("%s","Move");
	reg_0x06_8u = read8u();
}
//Move
void handlerCommand32Code00B7P66_PM() {
	LOG("%s","Move");
	reg_0x07_8u = read8u();
}
//Move
void handlerCommand32Code00B7_PM() {
	LOG("%s","Move");
	reg_0x07_8u = read8u();
}
//Move
void handlerCommand32Code00B8P66_PM() {
	LOG("%s","Move");
	reg_0x00_16u = read16u();
}
//Move
void handlerCommand32Code00B8_PM() {
	LOG("%s","Move");
	reg_0x00_32u = read32u();
}
//Move
void handlerCommand32Code00B9P66_PM() {
	LOG("%s","Move");
	reg_0x01_16u = read16u();
}
//Move
void handlerCommand32Code00B9_PM() {
	LOG("%s","Move");
	reg_0x01_32u = read32u();
}
//Move
void handlerCommand32Code00BAP66_PM() {
	LOG("%s","Move");
	reg_0x02_16u = read16u();
}
//Move
void handlerCommand32Code00BA_PM() {
	LOG("%s","Move");
	reg_0x02_32u = read32u();
}
//Move
void handlerCommand32Code00BBP66_PM() {
	LOG("%s","Move");
	reg_0x03_16u = read16u();
}
//Move
void handlerCommand32Code00BB_PM() {
	LOG("%s","Move");
	reg_0x03_32u = read32u();
}
//Move
void handlerCommand32Code00BCP66_PM() {
	LOG("%s","Move");
	reg_0x04_16u = read16u();
}
//Move
void handlerCommand32Code00BC_PM() {
	LOG("%s","Move");
	reg_0x04_32u = read32u();
}
//Move
void handlerCommand32Code00BDP66_PM() {
	LOG("%s","Move");
	reg_0x05_16u = read16u();
}
//Move
void handlerCommand32Code00BD_PM() {
	LOG("%s","Move");
	reg_0x05_32u = read32u();
}
//Move
void handlerCommand32Code00BEP66_PM() {
	LOG("%s","Move");
	reg_0x06_16u = read16u();
}
//Move
void handlerCommand32Code00BE_PM() {
	LOG("%s","Move");
	reg_0x06_32u = read32u();
}
//Move
void handlerCommand32Code00BFP66_PM() {
	LOG("%s","Move");
	reg_0x07_16u = read16u();
}
//Move
void handlerCommand32Code00BF_PM() {
	LOG("%s","Move");
	reg_0x07_32u = read32u();
}
//Move bits
void handlerCommand32Code00C0P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00C0_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00C1P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00C1_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = read8u() & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ret
void handlerCommand32Code00C2_PM() {
	LOG("%s","Ret");
	uint16_t stackValue = read16u();
	uint32_t* sp = register32u(BR_SP);
	context.index = GET_SEGMENT_POINTER(1) + *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (32 / 8);
	*sp += (stackValue * (32 / 16));
}
//Ret
void handlerCommand32Code00C3_PM() {
	LOG("%s","Ret");
	uint32_t* sp = register32u(BR_SP);
	context.index = GET_SEGMENT_POINTER(1) + *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (32 / 8);
}
//Load SR_ES
void handlerCommand32Code00C4_PM() {
	LOG("%s","Load SR_ES");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_ES, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//Load SR_DS
void handlerCommand32Code00C5_PM() {
	LOG("%s","Load SR_DS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_DS, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//Move
void handlerCommand32Code00C6P66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint8_t*)target = read8u();
}
//Move
void handlerCommand32Code00C6_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint8_t*)target = read8u();
}
//Move
void handlerCommand32Code00C7P66_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint16_t*)target = read16u();
}
//Move
void handlerCommand32Code00C7_PM() {
	LOG("%s","Move");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	*(uint32_t*)target = read32u();
}
//Enter
void handlerCommand32Code00C8P66P67_PM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	uint16_t tmp = reg_SP_16u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_16u = reg_BP_16u - 16 / 8;
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
		}
		reg_SP_16u -= 16 / 8;
		*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SP_16u;
	}
	reg_BP_16u = tmp;
	reg_SP_16u = reg_BP_16u - size;
}
//Enter
void handlerCommand32Code00C8P67_PM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_16u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
	uint16_t tmp = reg_SP_16u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_16u = reg_BP_16u - 32 / 8;
			reg_SP_16u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_BP_16u;
		}
		reg_SP_16u -= 16 / 8;
		*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = reg_SP_16u;
	}
	reg_BP_16u = tmp;
	reg_SP_16u = reg_BP_16u - size;
}
//Enter
void handlerCommand32Code00C8P66_PM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	uint32_t tmp = reg_SP_32u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_32u = reg_BP_32u - 16 / 8;
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
		}
		reg_SP_32u -= 32 / 8;
		*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SP_32u;
	}
	reg_BP_32u = tmp;
	reg_SP_32u = reg_BP_32u - size;
}
//Enter
void handlerCommand32Code00C8_PM() {
	LOG("%s","Enter");
	uint16_t size = read16u();
	uint8_t levels = read8u() % 32;
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
	uint32_t tmp = reg_SP_32u;
	if (levels > 0) {
		for (int i = 1; i < levels; ++i) {
			reg_BP_32u = reg_BP_32u - 32 / 8;
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_BP_32u;
		}
		reg_SP_32u -= 32 / 8;
		*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = reg_SP_32u;
	}
	reg_BP_32u = tmp;
	reg_SP_32u = reg_BP_32u - size;
}
//Leave
void handlerCommand32Code00C9P66P67_PM() {
	LOG("%s","Leave");
	reg_SP_16u = reg_BP_16u;
	reg_BP_16u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 16 / 8;
}
//Leave
void handlerCommand32Code00C9P67_PM() {
	LOG("%s","Leave");
	reg_SP_16u = reg_BP_16u;
	reg_BP_16u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u);
	reg_SP_16u += 32 / 8;
}
//Leave
void handlerCommand32Code00C9P66_PM() {
	LOG("%s","Leave");
	reg_SP_32u = reg_BP_32u;
	reg_BP_32u = *(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 16 / 8;
}
//Leave
void handlerCommand32Code00C9_PM() {
	LOG("%s","Leave");
	reg_SP_32u = reg_BP_32u;
	reg_BP_32u = *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u);
	reg_SP_32u += 32 / 8;
}
//Ret
void handlerCommand32Code00CA_PM() {
	LOG("%s","Ret");
	uint16_t stackValue = read16u();
	uint32_t* sp = register32u(BR_SP);
	SET_VALUE_IN_SEGMENT_P(1, *(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp + 32 / 8));
	context.index = GET_SEGMENT_POINTER(1) + *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (32 / 8 + 2);
	*sp += (stackValue * (32 / 16));
}
//Ret
void handlerCommand32Code00CB_PM() {
	LOG("%s","Ret");
	uint32_t* sp = register32u(BR_SP);
	SET_VALUE_IN_SEGMENT_P(1, *(int16_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp + 32 / 8));
	context.index = GET_SEGMENT_POINTER(1) + *(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp);
	*sp += (32 / 8 + 2);
}
//Int
void handlerCommand32Code00CD_PM() {
	LOG("%s","Int");
	uint8_t *target = GET_REAL_MOD_MEMORY_POINTER(0) + (read8u() * (2 + 2));
	reg_SP_32u -= 16 / 8;
	*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
	reg_SP_32u -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
	SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
	context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
}
//Move bits
void handlerCommand32Code00D0P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D0_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D1P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D1_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = 1;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D2P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D2_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % 8 + 8 - 1)) & 0x80);
			tmp = tmp << (value % 8);
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint16_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> 1;
			uint8_t mask = GET_FLAG(CF);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) |= mask;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			SET_FLAG(CF, (tmp << (value % (8 + 1) + 8)) & 0x80);
			tmp = tmp << ((value % (8 + 1)));
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			uint8_t tmp = 0;
			*(uint8_t*)(((uint8_t*)&tmp)) = (*(uint8_t*)target);
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint8_t*)(((uint8_t*)&tmp) + (8 / 8)) = (*(uint8_t*)target);
			tmp = tmp >> ((value % (8 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = *(uint8_t*)((uint8_t*)&tmp + (8 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint8_t*)target) = (*(uint8_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 0x80);
			(*(uint8_t*)target) = (*(uint8_t*)target) << 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint8_t*)target) & 0x80) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE8;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint8_t*)target) & 0x80) };
			(*(uint8_t*)target) = (*(uint8_t*)target) >> (value % 8 - 1);
			SET_FLAG(CF, (*(uint8_t*)target) & 1);
			(*(uint8_t*)target) = (*(uint8_t*)target) >> 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int8_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint8_t*)(((uint8_t*)&tmp) + 4) = (*(uint8_t*)target);
			tmp = tmp >> (value % 8 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint8_t*)target) = (*(uint8_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_VALUE8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D3P66_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % 16 + 16 - 1)) & 0x8000);
			tmp = tmp << (value % 16);
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint32_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> 1;
			uint16_t mask = GET_FLAG(CF);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) |= mask;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			SET_FLAG(CF, (tmp << (value % (16 + 1) + 16)) & 0x8000);
			tmp = tmp << ((value % (16 + 1)));
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			uint16_t tmp = 0;
			*(uint16_t*)(((uint8_t*)&tmp)) = (*(uint16_t*)target);
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint16_t*)(((uint8_t*)&tmp) + (16 / 8)) = (*(uint16_t*)target);
			tmp = tmp >> ((value % (16 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = *(uint16_t*)((uint8_t*)&tmp + (16 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint16_t*)target) = (*(uint16_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 0x8000);
			(*(uint16_t*)target) = (*(uint16_t*)target) << 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint16_t*)target) & 0x8000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE16;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint16_t*)target) & 0x8000) };
			(*(uint16_t*)target) = (*(uint16_t*)target) >> (value % 16 - 1);
			SET_FLAG(CF, (*(uint16_t*)target) & 1);
			(*(uint16_t*)target) = (*(uint16_t*)target) >> 1;
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int16_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint16_t*)(((uint8_t*)&tmp) + 4) = (*(uint16_t*)target);
			tmp = tmp >> (value % 16 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint16_t*)target) = (*(uint16_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer16 = (*(uint16_t*)target);
			lazyFlagType = t_VALUE16;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Move bits
void handlerCommand32Code00D3_PM() {
	LOG("%s","Move bits");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % 32 + 32 - 1)) & 0x80000000);
			tmp = tmp << (value % 32);
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp)));
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 1: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp + 4)));
		}
		break;
		case 2: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			uint64_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> 1;
			uint32_t mask = GET_FLAG(CF);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) |= mask;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			SET_FLAG(CF, (tmp << (value % (32 + 1) + 32)) & 0x80000000);
			tmp = tmp << ((value % (32 + 1)));
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
		}
		break;
		case 3: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			FillFlags();
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			uint32_t tmp = 0;
			*(uint32_t*)(((uint8_t*)&tmp)) = (*(uint32_t*)target);
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = GET_FLAG(CF);
			tmp = tmp << 1;
			*(uint32_t*)(((uint8_t*)&tmp) + (32 / 8)) = (*(uint32_t*)target);
			tmp = tmp >> ((value % (32 + 1)) - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = *(uint32_t*)((uint8_t*)&tmp + (32 / 8));
		}
		break;
		case 4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			(*(uint32_t*)target) = (*(uint32_t*)target) << (value - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 0x80000000);
			(*(uint32_t*)target) = (*(uint32_t*)target) << 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			if (value == 1) { SET_FLAG(OF, (((*(uint32_t*)target) & 0x80000000) ? 1 : 0) ^ CF); }
			lazyFlagType = t_VALUE32;
		}
		break;
		case 5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			if (value == 1) { SET_FLAG(OF, (*(uint32_t*)target) & 0x80000000) };
			(*(uint32_t*)target) = (*(uint32_t*)target) >> (value % 32 - 1);
			SET_FLAG(CF, (*(uint32_t*)target) & 1);
			(*(uint32_t*)target) = (*(uint32_t*)target) >> 1;
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		case 7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t value = reg_CL_8u & 0x1F;
			if (value == 0) { return; }
			uint64_t tmp = ((*(int32_t*)target) < 0) ? 0xFFFFFFFFFFFFFFFF : 0;
			*(uint32_t*)(((uint8_t*)&tmp) + 4) = (*(uint32_t*)target);
			tmp = tmp >> (value % 32 - 1);
			SET_FLAG(CF, tmp & 1);
			tmp = tmp >> 1;
			(*(uint32_t*)target) = (*(uint32_t*)(((uint8_t*)&tmp) + 4));
			SET_FLAG(OF, 0);
			LazyFlagResultContainer32 = (*(uint32_t*)target);
			lazyFlagType = t_VALUE32;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00D8_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 000, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 000, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 000, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 000, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 000, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 000, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 000, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00D9_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 001, OPB 000
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* source = valueB;
				*target = *source;
			} else {
				// OPA 001, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 001, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 001, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				float* valueB = (float*)readAddressMRM32For8(mrmByte);
				float* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				fpuRegControll = *(uint16_t*)readAddressMRM32For16(mrmByte);
			} else {
				fpuRegControll = *(uint16_t*)readAddressMRM32For16(mrmByte);
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM32For16(mrmByte) = fpuRegControll;
			} else {
				*(uint16_t*)readAddressMRM32For16(mrmByte) = fpuRegControll;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DA_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 010, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DB_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 011, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int32_t* valueB = (int32_t*)readAddressMRM32For8(mrmByte);
				int32_t* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				fpuStackIndex = 7;
				fpuRegControll = 0x37F;
				fpuRegStatus = 0;
				fpuRegTag = 0xFFFF;
				fpuRegPointer = 0;
				fpuRegInstructionPointer = 0;
				fpuRegInstructionOpcode = 0;
			} else {
				fpuStackIndex = 7;
				fpuRegControll = 0x37F;
				fpuRegStatus = 0;
				fpuRegTag = 0xFFFF;
				fpuRegPointer = 0;
				fpuRegInstructionPointer = 0;
				fpuRegInstructionOpcode = 0;
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM32For16(mrmByte) = fpuRegControll;
			} else {
				*(uint16_t*)readAddressMRM32For16(mrmByte) = fpuRegControll;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DC_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 100, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 100, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 100, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 100, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 100, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 100, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 100, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DD_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 101, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = (double*)readAddressMRM32For8(mrmByte);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegStatus;
			} else {
				*(uint16_t*)readAddressMRM16For16(mrmByte) = fpuRegStatus;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DE_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			} else {
				// OPA 110, OPB 000
				// FPU Add
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) + ((double)*valueB));
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			} else {
				// OPA 110, OPB 001
				// FPU Mul
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) * ((double)*valueB));
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			} else {
				// OPA 110, OPB 100
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) - ((double)*valueB));
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			} else {
				// OPA 110, OPB 101
				// FPU Sub
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueB) + ((double)*valueA));
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			} else {
				// OPA 110, OPB 110
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueA) / ((double)*valueB));
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// OPA 110, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				double* valueB = fpuStack + fpuStackIndex + (mrmByte & 7);
				double* target = valueB;
				fpuStackIndex += 1;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			} else {
				// OPA 110, OPB 111
				// FPU Div
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = (double)(((double)*valueB) / ((double)*valueA));
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//FPU
void handlerCommand32Code00DF_PM() {
	LOG("%s","FPU");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 000
				// FPU Move
				fpuStackIndex -= 1;
				double* valueA = fpuStack + fpuStackIndex;
				double* target = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* source = valueB;
				*target = *source;
			}
		}
		break;
		case 0x01: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x02: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 010
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* target = valueB;
				*target = *source;
			}
		}
		break;
		case 0x03: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// OPA 111, OPB 011
				// FPU Move
				double* valueA = fpuStack + fpuStackIndex;
				double* source = valueA;
				int16_t* valueB = (int16_t*)readAddressMRM32For8(mrmByte);
				int16_t* target = valueB;
				fpuStackIndex += 1;
				*target = *source;
			}
		}
		break;
		case 0x04: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x05: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x06: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		case 0x07: {
			if ((mrmByte >> 6 & 3) == 3) {
				// NON FUNCTION
				mCommandFunctionEmpty();
			} else {
				// NON FUNCTION
				mCommandFunctionEmpty();
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Loop
void handlerCommand32Code00E0_PM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_32 -= 1;
	FillFlags();
	if (reg_0x01_32 != 0 && GET_FLAG(ZF) == 0) {
		context.index += addr;
	}
}
//Loop
void handlerCommand32Code00E1_PM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_32 -= 1;
	FillFlags();
	if (reg_0x01_32 != 0 && GET_FLAG(ZF) == 1) {
		context.index += addr;
	}
}
//Loop
void handlerCommand32Code00E2_PM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	reg_0x01_32 -= 1;
	if (reg_0x01_32 != 0) {
		context.index += addr;
	}
}
//Loop
void handlerCommand32Code00E3_PM() {
	LOG("%s","Loop");
	int8_t addr = read8();
	if (reg_0x01_32 == 0) {
		context.index += addr;
	}
}
//In
void handlerCommand32Code00E4P66_PM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand32Code00E4_PM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand32Code00E5P66_PM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//In
void handlerCommand32Code00E5_PM() {
	LOG("%s","In");
	uint8_t port = read8u();
	context.ports[port].input(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Out
void handlerCommand32Code00E6P66_PM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand32Code00E6_PM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand32Code00E7P66_PM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Out
void handlerCommand32Code00E7_PM() {
	LOG("%s","Out");
	uint8_t port = read8u();
	context.ports[port].output(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Call
void handlerCommand32Code00E8P66_PM() {
	LOG("%s","Call");
	uint32_t* sp = register32u(BR_SP);
	*sp -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index + 16 / 8 - GET_SEGMENT_POINTER(1));
	context.index += read16();
}
//Call
void handlerCommand32Code00E8_PM() {
	LOG("%s","Call");
	uint32_t* sp = register32u(BR_SP);
	*sp -= 32 / 8;
	*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index + 32 / 8 - GET_SEGMENT_POINTER(1));
	context.index += read32();
}
//Jmp
void handlerCommand32Code00E9P66_PM() {
	LOG("%s","Jmp");
	context.index += read16();
}
//Jmp
void handlerCommand32Code00E9_PM() {
	LOG("%s","Jmp");
	context.index += read32();
}
//Jmp
void handlerCommand32Code00EB_PM() {
	LOG("%s","Jmp");
	context.index += read8();
}
//In
void handlerCommand32Code00ECP66_PM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand32Code00EC_PM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//In
void handlerCommand32Code00EDP66_PM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//In
void handlerCommand32Code00ED_PM() {
	LOG("%s","In");
	uint16_t port = *regDXu;
	context.ports[port].input(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//Out
void handlerCommand32Code00EEP66_PM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand32Code00EE_PM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register8u(0x00), 8 / 4);
}
//Out
void handlerCommand32Code00EFP66_PM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register16u(0x00), 16 / 4);
}
//Out
void handlerCommand32Code00EF_PM() {
	LOG("%s","Out");
	uint16_t port = *regDXu;
	context.ports[port].output(port, (uint8_t*)register32u(0x00), 32 / 4);
}
//External call
void handlerCommand32Code00F1_PM() {
	LOG("%s","External call");
	uint16_t addr = read16u();
	FillFlags();
	context.functions[addr](addr);
}
//~CF
void handlerCommand32Code00F5_PM() {
	LOG("%s","~CF");
	SET_FLAG(CF, !GET_FLAG(CF));
}
//Math
void handlerCommand32Code00F6P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// TEST
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = read8();
			LazyFlagResultContainer8 = LazyFlagVarA8 & ((uint8_t)LazyFlagVarB8);
			lazyFlagType = t_TEST8;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// NOT
			*(int8_t*)target = ~(*(int8_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// NEG
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagResultContainer8 = 0 - LazyFlagVarA8;
			*(int8_t*)target = LazyFlagResultContainer8;
			lazyFlagType = t_NEG8;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			reg_AX_16u=((uint16_t)reg_AL_8u)*((uint16_t)(*(uint8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AL_8 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16));
			if (reg_AX_16 & 0xff00) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			reg_AX_16 = reg_AL_8 * (*((int8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF, reg_AL_8 == 0);
			SET_FLAG(SF, reg_AL_8 & 0x80);
			if ((reg_AX_16 & 0xff80)==0xff80 || (reg_AX_16 & 0xff80)==0x0000) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t val= *(uint8_t*)(target);
			uint16_t quo = reg_AX_16u / val;
			uint8_t rem = (uint8_t)(reg_AX_16 % val);
			uint8_t quo8 = (uint8_t)(quo&0xff);
			reg_AH_8u=rem;
			reg_AL_8u=quo8;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem]^parity_lookup[quo8]);
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			int16_t val= *(int8_t*)(target);
			int16_t quo= ((int16_t)reg_AX_16) / val;
			int8_t rem=(int8_t)((int16_t)reg_AX_16 % val);
			int8_t quo8s=(int8_t)(quo&0xff);
			reg_AH_8=(uint8_t)rem;
			reg_AL_8=(uint8_t)quo8s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem&0xff]^parity_lookup[quo8s&0xff]^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code00F6_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// TEST
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagVarB8 = read8();
			LazyFlagResultContainer8 = LazyFlagVarA8 & ((uint8_t)LazyFlagVarB8);
			lazyFlagType = t_TEST8;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// NOT
			*(int8_t*)target = ~(*(int8_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// NEG
			LazyFlagVarA8 = *(int8_t*)target;
			LazyFlagResultContainer8 = 0 - LazyFlagVarA8;
			*(int8_t*)target = LazyFlagResultContainer8;
			lazyFlagType = t_NEG8;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			reg_AX_16u=((uint16_t)reg_AL_8u)*((uint16_t)(*(uint8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AL_8 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16));
			if (reg_AX_16 & 0xff00) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			reg_AX_16 = reg_AL_8 * (*((int8_t*)target));
			FillFlagsNoCFOF();
			SET_FLAG(ZF, reg_AL_8 == 0);
			SET_FLAG(SF, reg_AL_8 & 0x80);
			if ((reg_AX_16 & 0xff80)==0xff80 || (reg_AX_16 & 0xff80)==0x0000) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			uint8_t val= *(uint8_t*)(target);
			uint16_t quo = reg_AX_16u / val;
			uint8_t rem = (uint8_t)(reg_AX_16 % val);
			uint8_t quo8 = (uint8_t)(quo&0xff);
			reg_AH_8u=rem;
			reg_AL_8u=quo8;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem]^parity_lookup[quo8]);
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			int16_t val= *(int8_t*)(target);
			int16_t quo= ((int16_t)reg_AX_16) / val;
			int8_t rem=(int8_t)((int16_t)reg_AX_16 % val);
			int8_t quo8s=(int8_t)(quo&0xff);
			reg_AH_8=(uint8_t)rem;
			reg_AL_8=(uint8_t)quo8s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo8s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,parity_lookup[rem&0xff]^parity_lookup[quo8s&0xff]^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code00F7P66_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			// TEST
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagVarB16 = read16();
			LazyFlagResultContainer16 = LazyFlagVarA16 & ((uint16_t)LazyFlagVarB16);
			lazyFlagType = t_TEST16;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			// NOT
			*(int16_t*)target = ~(*(int16_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			// NEG
			LazyFlagVarA16 = *(int16_t*)target;
			LazyFlagResultContainer16 = 0 - LazyFlagVarA16;
			*(int16_t*)target = LazyFlagResultContainer16;
			lazyFlagType = t_NEG16;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t tempu=((uint32_t)reg_AX_16u)*(uint32_t)(*(uint16_t*)(target));
			reg_AX_16=(uint16_t)(tempu);
			reg_DX_16=(uint16_t)(tempu >> 16);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_16 == 0);
			SET_FLAG(PF,PARITY16(reg_AX_16)^PARITY16(reg_DX_16));
			if (reg_DX_16) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			int32_t temps=reg_AX_16 * (*((int16_t*)target));
			reg_AX_16=(uint16_t)(temps);
			reg_DX_16=(uint16_t)(temps >> 16);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_16 == 0);
			SET_FLAG(SF,reg_AX_16 & 0x8000);
			if ((((uint32_t)temps & 0xffff8000)==0xffff8000 || ((uint32_t)temps & 0xffff8000)==0x0000)) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint16_t val= *(uint16_t*)(target);
			uint32_t num=((uint32_t)reg_DX_16u<<16) | reg_AX_16u;
			uint32_t quo=num/val;
			uint16_t rem=(uint16_t)(num % val);
			uint16_t quo16=(uint16_t)(quo&0xffff);
			reg_DX_16u=rem;
			reg_AX_16u=quo16;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo16&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY16(rem)^PARITY16(quo16));
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			int32_t val=*(int16_t*)(target);
			int32_t num=(int32_t)(((uint32_t)reg_DX_16<<16u)|(unsigned int)reg_AX_16);
			int32_t quo=num/val;
			int16_t rem=(int16_t)(num % val);
			int16_t quo16s=(int16_t)(quo&0xffff);
			reg_DX_16u=(uint16_t)rem;
			reg_AX_16u=(uint16_t)quo16s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo16s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY16(rem&0xffff)^PARITY16(quo16s&0xffff)^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code00F7_PM() {
	LOG("%s","Math");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			// TEST
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagVarB32 = read32();
			LazyFlagResultContainer32 = LazyFlagVarA32 & ((uint32_t)LazyFlagVarB32);
			lazyFlagType = t_TEST32;
		}
		break;
		case 0x02: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			// NOT
			*(int32_t*)target = ~(*(int32_t*)target);
		}
		break;
		case 0x03: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			// NEG
			LazyFlagVarA32 = *(int32_t*)target;
			LazyFlagResultContainer32 = 0 - LazyFlagVarA32;
			*(int32_t*)target = LazyFlagResultContainer32;
			lazyFlagType = t_NEG32;
		}
		break;
		case 0x04: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint64_t tempu=((uint64_t)reg_AX_32u)*((uint64_t)(*(uint32_t*)(target)));
			reg_AX_32=(uint32_t)(tempu);
			reg_DX_32=(uint32_t)(tempu >> 32);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_32 == 0);
			SET_FLAG(PF,PARITY32(reg_AX_32)^PARITY32(reg_DX_32));
			if (reg_DX_32) {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			} else {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			}
		}
		break;
		case 0x05: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			int64_t temps=((int64_t)(reg_AX_32))*((int64_t)(*(int32_t*)(target)));
			reg_AX_32=(uint32_t)(temps);
			reg_DX_32=(uint32_t)(temps >> 32);
			FillFlagsNoCFOF();
			SET_FLAG(ZF,reg_AX_32 == 0);
			SET_FLAG(SF,reg_AX_32 & 0x80000000);
			if ((reg_AX_32==0xffffffff) && (reg_AX_32 & 0x80000000) ) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else if ( (reg_AX_32==0x00000000) && (reg_AX_32< 0x80000000) ) {
				SET_FLAG(CF,0);SET_FLAG(OF,0);
			} else {
				SET_FLAG(CF,1);SET_FLAG(OF,1);
			}
		}
		break;
		case 0x06: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t val= *(uint32_t*)(target);
			uint64_t num=(((uint64_t)reg_DX_32u)<<32) | reg_AX_32u;
			uint64_t quo=num/val;
			uint32_t rem=(uint32_t)(num % val);
			uint32_t quo32=(uint32_t)(quo&0xffffffff);
			reg_DX_32u=rem;
			reg_AX_32u=quo32;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo32&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY32(rem)^PARITY32(quo32));
		}
		break;
		case 0x07: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			int64_t val=*(int32_t*)(target);
			int64_t num=(int64_t)((((uint64_t)reg_DX_32)<<(uint64_t)32)|(uint64_t)reg_AX_32);
			int64_t quo=num/val;
			int32_t rem=(int32_t)(num % val);
			int32_t quo32s=(int32_t)(quo&0xffffffff);
			reg_DX_32u=(uint32_t)rem;
			reg_AX_32u=(uint32_t)quo32s;
			FillFlags();
			SET_FLAG(ZF,(rem==0)&&((quo32s&1)!=0));
			SET_FLAG(CF,((rem&3) >= 1 && (rem&3) <= 2));
			SET_FLAG(PF,PARITY32((uint32_t)rem&0xffffffffu)^PARITY32((uint32_t)quo32s&0xffffffffu)^GET_FLAG(PF));
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Flag CF set false
void handlerCommand32Code00F8_PM() {
	LOG("%s","Flag CF set false");
	SET_FLAG(CF, 0);
}
//Flag CF set true
void handlerCommand32Code00F9_PM() {
	LOG("%s","Flag CF set true");
	SET_FLAG(CF, 1);
}
//Flag IF set false
void handlerCommand32Code00FA_PM() {
	LOG("%s","Flag IF set false");
	SET_FLAG(IF, 0);
}
//Flag IF set true
void handlerCommand32Code00FB_PM() {
	LOG("%s","Flag IF set true");
	SET_FLAG(IF, 1);
}
//Flag DF set false
void handlerCommand32Code00FC_PM() {
	LOG("%s","Flag DF set false");
	SET_FLAG(DF, 0);
}
//Flag DF set true
void handlerCommand32Code00FD_PM() {
	LOG("%s","Flag DF set true");
	SET_FLAG(DF, 1);
}
//Inc/Dec
void handlerCommand32Code00FE_PM() {
	LOG("%s","Inc/Dec");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			(*(uint8_t*)target) += 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_INC8;
		}
		break;
		case 0x01: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			(*(uint8_t*)target) -= 1;
			LazyFlagResultContainer8 = (*(uint8_t*)target);
			lazyFlagType = t_DEC8;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand32Code00FFP66P67_PM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			(*(uint16_t*)target)++;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_INC16;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			(*(uint16_t*)target)--;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_DEC16;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t* sp = register32u(BR_SP);
			*sp -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t newIP = *(uint32_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 32 / 8);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int16_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			reg_SP_16u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *(uint32_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand32Code00FFP67_PM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			(*(uint32_t*)target)++;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_INC32;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			(*(uint32_t*)target)--;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_DEC32;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t* sp = register32u(BR_SP);
			*sp -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t newIP = *(uint32_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 32 / 8);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int32_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			reg_SP_16u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_16u) = *(uint32_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand32Code00FFP66_PM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			(*(uint16_t*)target)++;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_INC16;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			(*(uint16_t*)target)--;
			LazyFlagResultContainer16 = *(uint16_t*)target;
			lazyFlagType = t_DEC16;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t* sp = register32u(BR_SP);
			*sp -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			uint32_t newIP = *(uint32_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 32 / 8);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int16_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint16_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *(uint32_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Ofther
void handlerCommand32Code00FF_PM() {
	LOG("%s","Ofther");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			// INC
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			(*(uint32_t*)target)++;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_INC32;
		}
		break;
		case 0x01: {
			// DEC
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			(*(uint32_t*)target)--;
			LazyFlagResultContainer32 = *(uint32_t*)target;
			lazyFlagType = t_DEC32;
		}
		break;
		case 0x2: {
			// Call
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t* sp = register32u(BR_SP);
			*sp -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + *sp) = (uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)target));
		}
		break;
		case 0x3: {
			// Call far
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint32_t newIP = *(uint32_t*)target;
			uint16_t newCS = *(uint16_t*)(target + 32 / 8);
			reg_SP_32u -= 16 / 8;
			*(uint16_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = SR_VALUE(SR_CS);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = ((uint32_t)(context.index - GET_SEGMENT_POINTER(SR_CS)));
			SET_VALUE_IN_SEGMENT_P(SR_CS, newCS);
			context.index = GET_SEGMENT_POINTER(SR_CS) + newIP;
		}
		break;
		case 0x4: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((int32_t*)target));
		}
		break;
		case 0x5: {
			// JMP
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			SET_VALUE_IN_SEGMENT_P(SR_CS, (*((uint16_t*)(target + 2))));
			context.index = GET_SEGMENT_POINTER(SR_CS) + (*((uint32_t*)(target)));
		}
		break;
		case 0x6: {
			// PUSH
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			reg_SP_32u -= 32 / 8;
			*(uint32_t*)(GET_SEGMENT_POINTER(SR_SS) + reg_SP_32u) = *(uint32_t*)target;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//???
void handlerCommand32Code0101_PM() {
	LOG("%s","???");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
			*(uint16_t*)target = 0x0019;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//J(cond)
void handlerCommand32Code0180_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x00 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0181_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x01 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0182_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x02 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0183_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x03 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0184_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x04 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0185_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x05 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0186_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x06 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0187_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x07 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0188_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x08 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code0189_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x09 {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018A_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0A {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018B_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0B {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018C_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0C {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018D_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0D {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018E_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0E {
		context.index += address;
	}
}
//J(cond)
void handlerCommand32Code018F_PM() {
	LOG("%s","J(cond)");
	FillFlags();
	int32_t address = read32();
	if COND0x0F {
		context.index += address;
	}
}
//Math
void handlerCommand32Code0190P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x00;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x00 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0190_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x00;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x00 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0191P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x01;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x01 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0191_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x01;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x01 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0192P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x02;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x02 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0192_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x02;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x02 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0193P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x03;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x03 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0193_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x03;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x03 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0194P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x04;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x04 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0194_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x04;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x04 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0195P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x05;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x05 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0195_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x05;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x05 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0196P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x06;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x06 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0196_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x06;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x06 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0197P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x07;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x07 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0197_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x07;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x07 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0198P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x08;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x08 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0198_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x08;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x08 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0199P66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x09;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x09 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code0199_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x09;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x09 ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019AP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0A;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0A ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019A_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0A;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0A ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019BP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0B;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0B ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019B_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0B;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0B ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019CP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0C;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0C ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019C_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0C;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0C ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019DP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0D;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0D ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019D_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0D;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0D ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019EP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0E;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0E ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019E_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0E;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0E ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019FP66_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0F;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0F ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Math
void handlerCommand32Code019F_PM() {
	LOG("%s","Math");
	uint8_t cond = 0x0F;
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x00: {
			uint8_t* target = (uint8_t*)readAddressMRM32For8(mrmByte);
			// SET(cond)
			*target = COND0x0F ? 1 : 0;
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//BT
void handlerCommand32Code01A3P66_PM() {
	LOG("%s","BT");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BT
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
}
//BT
void handlerCommand32Code01A3_PM() {
	LOG("%s","BT");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BT
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
}
//BTS
void handlerCommand32Code01ABP66_PM() {
	LOG("%s","BTS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTS
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
}
//BTS
void handlerCommand32Code01AB_PM() {
	LOG("%s","BTS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTS
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
}
//Mul
void handlerCommand32Code01AFP66_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	int16_t source1 = *(int16_t*)source;
	int16_t source2 = *(int16_t*)target;
	target = source;
	int32_t tmp = (int32_t)source1 * (int32_t)source2;
	int16_t value = source1 * source2;
	*((int16_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Mul
void handlerCommand32Code01AF_PM() {
	LOG("%s","Mul");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	int32_t source1 = *(int32_t*)source;
	int32_t source2 = *(int32_t*)target;
	target = source;
	int64_t tmp = (int64_t)source1 * (int64_t)source2;
	int32_t value = source1 * source2;
	*((int32_t*)target) = value;
	SET_FLAG(ZF, value == 0);
	SET_FLAG(CF, value != tmp);
	SET_FLAG(OF, value != tmp);
	lazyFlagType = t_MUL;
}
//Load SR_SS
void handlerCommand32Code01B2_PM() {
	LOG("%s","Load SR_SS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_SS, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//BTR
void handlerCommand32Code01B3P66_PM() {
	LOG("%s","BTR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTR
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
}
//BTR
void handlerCommand32Code01B3_PM() {
	LOG("%s","BTR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTR
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
}
//Load SR_FS
void handlerCommand32Code01B4_PM() {
	LOG("%s","Load SR_FS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_FS, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//Load SR_GS
void handlerCommand32Code01B5_PM() {
	LOG("%s","Load SR_GS");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	SET_VALUE_IN_SEGMENT_P(SR_GS, *(uint16_t*)(target + 2));
	*(uint32_t*)source = *(uint32_t*)(target);
}
//MOVZX
void handlerCommand32Code01B6P66_PM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint16_t* target = (uint16_t*)readRegisterMRM16(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	*target = (uint16_t)*source;
}
//MOVZX
void handlerCommand32Code01B6_PM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint8_t* source = (uint8_t*)readAddressMRM32For8(mrmByte);
	*target = (uint32_t)*source;
}
//MOVZX
void handlerCommand32Code01B7P66_PM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint16_t* source = (uint16_t*)readAddressMRM32For16(mrmByte);
	*target = (uint32_t)*source;
}
//MOVZX
void handlerCommand32Code01B7_PM() {
	LOG("%s","MOVZX");
	uint8_t mrmByte = read8u();
	uint32_t* target = (uint32_t*)readRegisterMRM32(mrmByte);
	uint16_t* source = (uint16_t*)readAddressMRM32For16(mrmByte);
	*target = (uint32_t)*source;
}
//Bit scan
void handlerCommand32Code01BAP66_PM() {
	LOG("%s","Bit scan");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BT
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTS
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTR
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTC
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			if (value) {
				(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
			} else {
				(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//Bit scan
void handlerCommand32Code01BA_PM() {
	LOG("%s","Bit scan");
	uint8_t mrmByte = read8u();
	uint8_t nnn = readMiddle3Bit(mrmByte);
	switch (nnn) {
		case 0x4: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BT
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
		}
		break;
		case 0x5: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTS
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
		}
		break;
		case 0x6: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTR
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
		}
		break;
		case 0x7: {
			uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
			uint8_t shift = read8u();
			// BTC
			FillFlags();
			uint32_t mask = 1 << shift;
			uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
			SET_FLAG(CF, value);
			if (value) {
				(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
			} else {
				(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
			}
		}
		break;
		default:
		mCommandFunctionEmpty();
	}
}
//BTC
void handlerCommand32Code01BBP66_PM() {
	LOG("%s","BTC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTC
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	if (value) {
		(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
	} else {
		(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
	}
}
//BTC
void handlerCommand32Code01BB_PM() {
	LOG("%s","BTC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	uint32_t shift = *(uint32_t*)source;
	// BTC
	FillFlags();
	uint32_t mask = 1 << shift;
	uint8_t value = ((*(uint32_t*)target) & mask) ? 1 : 0;
	SET_FLAG(CF, value);
	if (value) {
		(*(uint32_t*)target) = (*(uint32_t*)target) & (~mask);
	} else {
		(*(uint32_t*)target) = (*(uint32_t*)target) | mask;
	}
}
//BFC
void handlerCommand32Code01BCP66_PM() {
	LOG("%s","BFC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	FillFlags();
	uint16_t value = *(uint16_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint16_t mask = 1;
	uint16_t len = 0;
	while ((mask & value) && (len < 16)) {
		value = value >> 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint16_t*)target = len;
}
//BFC
void handlerCommand32Code01BC_PM() {
	LOG("%s","BFC");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	FillFlags();
	uint32_t value = *(uint32_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint32_t mask = 1;
	uint32_t len = 0;
	while ((mask & value) && (len < 32)) {
		value = value >> 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint32_t*)target = len;
}
//BSR
void handlerCommand32Code01BDP66_PM() {
	LOG("%s","BSR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For16(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM16(mrmByte);
	FillFlags();
	uint16_t value = *(uint16_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint16_t mask = 1 << (16 - 1);
	uint16_t len = 0;
	while ((mask & value) && (len < 16)) {
		value = value << 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint16_t*)target = len;
}
//BSR
void handlerCommand32Code01BD_PM() {
	LOG("%s","BSR");
	uint8_t mrmByte = read8u();
	uint8_t* target = (uint8_t*)readAddressMRM32For32(mrmByte);
	uint8_t* source = (uint8_t*)readRegisterMRM32(mrmByte);
	FillFlags();
	uint32_t value = *(uint32_t*)source;
	if (value == 0) { SET_FLAG(ZF, 0); return; }
	uint32_t mask = 1 << (32 - 1);
	uint32_t len = 0;
	while ((mask & value) && (len < 32)) {
		value = value << 1;
		len++;
	}
	SET_FLAG(ZF, 1);
	*(uint32_t*)target = len;
}
//MOVSX
void handlerCommand32Code01BEP66_PM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int16_t* target = (int16_t*)readRegisterMRM16(mrmByte);
	int8_t* source = (int8_t*)readAddressMRM32For8(mrmByte);
	*target = (int16_t)*source;
}
//MOVSX
void handlerCommand32Code01BE_PM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int32_t* target = (int32_t*)readRegisterMRM32(mrmByte);
	int8_t* source = (int8_t*)readAddressMRM32For8(mrmByte);
	*target = (int32_t)*source;
}
//MOVSX
void handlerCommand32Code01BF_PM() {
	LOG("%s","MOVSX");
	uint8_t mrmByte = read8u();
	int32_t* target = (int32_t*)readRegisterMRM32(mrmByte);
	int16_t* source = (int16_t*)readAddressMRM32For16(mrmByte);
	*target = (int32_t)*source;
}
//Swap
void handlerCommand32Code01C8_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x00;
	uint32_t value = reg_0x00_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01C9_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x01;
	uint32_t value = reg_0x01_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CA_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x02;
	uint32_t value = reg_0x02_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CB_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x03;
	uint32_t value = reg_0x03_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CC_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x04;
	uint32_t value = reg_0x04_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CD_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x05;
	uint32_t value = reg_0x05_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CE_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x06;
	uint32_t value = reg_0x06_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
//Swap
void handlerCommand32Code01CF_PM() {
	LOG("%s","Swap");
	uint8_t reg = 0x07;
	uint32_t value = reg_0x07_32u;
	uint8_t b1 = value & 0x000000FF;
	uint8_t b2 = value >> 8 & 0x000000FF;
	uint8_t b3 = value >> 16 & 0x000000FF;
	uint8_t b4 = value >> 24 & 0x000000FF;
	value = 0;
	value |= (((uint32_t)b1) << 24) & 0xFF000000;
	value |= (((uint32_t)b3) << 16) & 0x00FF0000;
	value |= (((uint32_t)b2) << 8)  & 0x0000FF00;
	value |= ((uint32_t)b4)      & 0x000000FF;
}
 

 void installCommandFunction16RM() {
	for(int i = 0; i < 256 * 8; i++) {
		commandFunctions[i] = mCommandFunctionEmpty;
	}
	commandFunctions[0] = handlerCommand16Code0000_RM;
	commandFunctions[0 | 0x0400] = handlerCommand16Code0000P66_RM;
	commandFunctions[1] = handlerCommand16Code0001_RM;
	commandFunctions[1 | 0x0400] = handlerCommand16Code0001P66_RM;
	commandFunctions[2] = handlerCommand16Code0002_RM;
	commandFunctions[2 | 0x0400] = handlerCommand16Code0002P66_RM;
	commandFunctions[3] = handlerCommand16Code0003_RM;
	commandFunctions[3 | 0x0400] = handlerCommand16Code0003P66_RM;
	commandFunctions[4] = handlerCommand16Code0004_RM;
	commandFunctions[4 | 0x0400] = handlerCommand16Code0004P66_RM;
	commandFunctions[5] = handlerCommand16Code0005_RM;
	commandFunctions[5 | 0x0400] = handlerCommand16Code0005P66_RM;
	commandFunctions[6] = handlerCommand16Code0006_RM;
	commandFunctions[14] = handlerCommand16Code000E_RM;
	commandFunctions[22] = handlerCommand16Code0016_RM;
	commandFunctions[30] = handlerCommand16Code001E_RM;
	commandFunctions[7] = handlerCommand16Code0007_RM;
	commandFunctions[15] = handlerCommand16Code000F_RM;
	commandFunctions[23] = handlerCommand16Code0017_RM;
	commandFunctions[31] = handlerCommand16Code001F_RM;
	commandFunctions[8] = handlerCommand16Code0008_RM;
	commandFunctions[8 | 0x0400] = handlerCommand16Code0008P66_RM;
	commandFunctions[9] = handlerCommand16Code0009_RM;
	commandFunctions[9 | 0x0400] = handlerCommand16Code0009P66_RM;
	commandFunctions[10] = handlerCommand16Code000A_RM;
	commandFunctions[10 | 0x0400] = handlerCommand16Code000AP66_RM;
	commandFunctions[11] = handlerCommand16Code000B_RM;
	commandFunctions[11 | 0x0400] = handlerCommand16Code000BP66_RM;
	commandFunctions[12] = handlerCommand16Code000C_RM;
	commandFunctions[12 | 0x0400] = handlerCommand16Code000CP66_RM;
	commandFunctions[13] = handlerCommand16Code000D_RM;
	commandFunctions[13 | 0x0400] = handlerCommand16Code000DP66_RM;
	commandFunctions[16] = handlerCommand16Code0010_RM;
	commandFunctions[16 | 0x0400] = handlerCommand16Code0010P66_RM;
	commandFunctions[17] = handlerCommand16Code0011_RM;
	commandFunctions[17 | 0x0400] = handlerCommand16Code0011P66_RM;
	commandFunctions[18] = handlerCommand16Code0012_RM;
	commandFunctions[18 | 0x0400] = handlerCommand16Code0012P66_RM;
	commandFunctions[19] = handlerCommand16Code0013_RM;
	commandFunctions[19 | 0x0400] = handlerCommand16Code0013P66_RM;
	commandFunctions[20] = handlerCommand16Code0014_RM;
	commandFunctions[20 | 0x0400] = handlerCommand16Code0014P66_RM;
	commandFunctions[21] = handlerCommand16Code0015_RM;
	commandFunctions[21 | 0x0400] = handlerCommand16Code0015P66_RM;
	commandFunctions[24] = handlerCommand16Code0018_RM;
	commandFunctions[24 | 0x0400] = handlerCommand16Code0018P66_RM;
	commandFunctions[25] = handlerCommand16Code0019_RM;
	commandFunctions[25 | 0x0400] = handlerCommand16Code0019P66_RM;
	commandFunctions[26] = handlerCommand16Code001A_RM;
	commandFunctions[26 | 0x0400] = handlerCommand16Code001AP66_RM;
	commandFunctions[27] = handlerCommand16Code001B_RM;
	commandFunctions[27 | 0x0400] = handlerCommand16Code001BP66_RM;
	commandFunctions[28] = handlerCommand16Code001C_RM;
	commandFunctions[28 | 0x0400] = handlerCommand16Code001CP66_RM;
	commandFunctions[29] = handlerCommand16Code001D_RM;
	commandFunctions[29 | 0x0400] = handlerCommand16Code001DP66_RM;
	commandFunctions[32] = handlerCommand16Code0020_RM;
	commandFunctions[32 | 0x0400] = handlerCommand16Code0020P66_RM;
	commandFunctions[33] = handlerCommand16Code0021_RM;
	commandFunctions[33 | 0x0400] = handlerCommand16Code0021P66_RM;
	commandFunctions[34] = handlerCommand16Code0022_RM;
	commandFunctions[34 | 0x0400] = handlerCommand16Code0022P66_RM;
	commandFunctions[35] = handlerCommand16Code0023_RM;
	commandFunctions[35 | 0x0400] = handlerCommand16Code0023P66_RM;
	commandFunctions[36] = handlerCommand16Code0024_RM;
	commandFunctions[36 | 0x0400] = handlerCommand16Code0024P66_RM;
	commandFunctions[37] = handlerCommand16Code0025_RM;
	commandFunctions[37 | 0x0400] = handlerCommand16Code0025P66_RM;
	commandFunctions[40] = handlerCommand16Code0028_RM;
	commandFunctions[40 | 0x0400] = handlerCommand16Code0028P66_RM;
	commandFunctions[41] = handlerCommand16Code0029_RM;
	commandFunctions[41 | 0x0400] = handlerCommand16Code0029P66_RM;
	commandFunctions[42] = handlerCommand16Code002A_RM;
	commandFunctions[42 | 0x0400] = handlerCommand16Code002AP66_RM;
	commandFunctions[43] = handlerCommand16Code002B_RM;
	commandFunctions[43 | 0x0400] = handlerCommand16Code002BP66_RM;
	commandFunctions[44] = handlerCommand16Code002C_RM;
	commandFunctions[44 | 0x0400] = handlerCommand16Code002CP66_RM;
	commandFunctions[45] = handlerCommand16Code002D_RM;
	commandFunctions[45 | 0x0400] = handlerCommand16Code002DP66_RM;
	commandFunctions[48] = handlerCommand16Code0030_RM;
	commandFunctions[48 | 0x0400] = handlerCommand16Code0030P66_RM;
	commandFunctions[49] = handlerCommand16Code0031_RM;
	commandFunctions[49 | 0x0400] = handlerCommand16Code0031P66_RM;
	commandFunctions[50] = handlerCommand16Code0032_RM;
	commandFunctions[50 | 0x0400] = handlerCommand16Code0032P66_RM;
	commandFunctions[51] = handlerCommand16Code0033_RM;
	commandFunctions[51 | 0x0400] = handlerCommand16Code0033P66_RM;
	commandFunctions[52] = handlerCommand16Code0034_RM;
	commandFunctions[52 | 0x0400] = handlerCommand16Code0034P66_RM;
	commandFunctions[53] = handlerCommand16Code0035_RM;
	commandFunctions[53 | 0x0400] = handlerCommand16Code0035P66_RM;
	commandFunctions[56] = handlerCommand16Code0038_RM;
	commandFunctions[56 | 0x0400] = handlerCommand16Code0038P66_RM;
	commandFunctions[57] = handlerCommand16Code0039_RM;
	commandFunctions[57 | 0x0400] = handlerCommand16Code0039P66_RM;
	commandFunctions[58] = handlerCommand16Code003A_RM;
	commandFunctions[58 | 0x0400] = handlerCommand16Code003AP66_RM;
	commandFunctions[59] = handlerCommand16Code003B_RM;
	commandFunctions[59 | 0x0400] = handlerCommand16Code003BP66_RM;
	commandFunctions[60] = handlerCommand16Code003C_RM;
	commandFunctions[60 | 0x0400] = handlerCommand16Code003CP66_RM;
	commandFunctions[61] = handlerCommand16Code003D_RM;
	commandFunctions[61 | 0x0400] = handlerCommand16Code003DP66_RM;
	commandFunctions[64] = handlerCommand16Code0040_RM;
	commandFunctions[64 | 0x0400] = handlerCommand16Code0040P66_RM;
	commandFunctions[65] = handlerCommand16Code0041_RM;
	commandFunctions[65 | 0x0400] = handlerCommand16Code0041P66_RM;
	commandFunctions[66] = handlerCommand16Code0042_RM;
	commandFunctions[66 | 0x0400] = handlerCommand16Code0042P66_RM;
	commandFunctions[67] = handlerCommand16Code0043_RM;
	commandFunctions[67 | 0x0400] = handlerCommand16Code0043P66_RM;
	commandFunctions[68] = handlerCommand16Code0044_RM;
	commandFunctions[68 | 0x0400] = handlerCommand16Code0044P66_RM;
	commandFunctions[69] = handlerCommand16Code0045_RM;
	commandFunctions[69 | 0x0400] = handlerCommand16Code0045P66_RM;
	commandFunctions[70] = handlerCommand16Code0046_RM;
	commandFunctions[70 | 0x0400] = handlerCommand16Code0046P66_RM;
	commandFunctions[71] = handlerCommand16Code0047_RM;
	commandFunctions[71 | 0x0400] = handlerCommand16Code0047P66_RM;
	commandFunctions[72] = handlerCommand16Code0048_RM;
	commandFunctions[72 | 0x0400] = handlerCommand16Code0048P66_RM;
	commandFunctions[73] = handlerCommand16Code0049_RM;
	commandFunctions[73 | 0x0400] = handlerCommand16Code0049P66_RM;
	commandFunctions[74] = handlerCommand16Code004A_RM;
	commandFunctions[74 | 0x0400] = handlerCommand16Code004AP66_RM;
	commandFunctions[75] = handlerCommand16Code004B_RM;
	commandFunctions[75 | 0x0400] = handlerCommand16Code004BP66_RM;
	commandFunctions[76] = handlerCommand16Code004C_RM;
	commandFunctions[76 | 0x0400] = handlerCommand16Code004CP66_RM;
	commandFunctions[77] = handlerCommand16Code004D_RM;
	commandFunctions[77 | 0x0400] = handlerCommand16Code004DP66_RM;
	commandFunctions[78] = handlerCommand16Code004E_RM;
	commandFunctions[78 | 0x0400] = handlerCommand16Code004EP66_RM;
	commandFunctions[79] = handlerCommand16Code004F_RM;
	commandFunctions[79 | 0x0400] = handlerCommand16Code004FP66_RM;
	commandFunctions[80] = handlerCommand16Code0050_RM;
	commandFunctions[80 | 0x0200 ] = handlerCommand16Code0050P67_RM;
	commandFunctions[80 | 0x0400] = handlerCommand16Code0050P66_RM;
	commandFunctions[80 | 0x0200 | 0x0400] = handlerCommand16Code0050P66P67_RM;
	commandFunctions[81] = handlerCommand16Code0051_RM;
	commandFunctions[81 | 0x0200 ] = handlerCommand16Code0051P67_RM;
	commandFunctions[81 | 0x0400] = handlerCommand16Code0051P66_RM;
	commandFunctions[81 | 0x0200 | 0x0400] = handlerCommand16Code0051P66P67_RM;
	commandFunctions[82] = handlerCommand16Code0052_RM;
	commandFunctions[82 | 0x0200 ] = handlerCommand16Code0052P67_RM;
	commandFunctions[82 | 0x0400] = handlerCommand16Code0052P66_RM;
	commandFunctions[82 | 0x0200 | 0x0400] = handlerCommand16Code0052P66P67_RM;
	commandFunctions[83] = handlerCommand16Code0053_RM;
	commandFunctions[83 | 0x0200 ] = handlerCommand16Code0053P67_RM;
	commandFunctions[83 | 0x0400] = handlerCommand16Code0053P66_RM;
	commandFunctions[83 | 0x0200 | 0x0400] = handlerCommand16Code0053P66P67_RM;
	commandFunctions[84] = handlerCommand16Code0054_RM;
	commandFunctions[84 | 0x0200 ] = handlerCommand16Code0054P67_RM;
	commandFunctions[84 | 0x0400] = handlerCommand16Code0054P66_RM;
	commandFunctions[84 | 0x0200 | 0x0400] = handlerCommand16Code0054P66P67_RM;
	commandFunctions[85] = handlerCommand16Code0055_RM;
	commandFunctions[85 | 0x0200 ] = handlerCommand16Code0055P67_RM;
	commandFunctions[85 | 0x0400] = handlerCommand16Code0055P66_RM;
	commandFunctions[85 | 0x0200 | 0x0400] = handlerCommand16Code0055P66P67_RM;
	commandFunctions[86] = handlerCommand16Code0056_RM;
	commandFunctions[86 | 0x0200 ] = handlerCommand16Code0056P67_RM;
	commandFunctions[86 | 0x0400] = handlerCommand16Code0056P66_RM;
	commandFunctions[86 | 0x0200 | 0x0400] = handlerCommand16Code0056P66P67_RM;
	commandFunctions[87] = handlerCommand16Code0057_RM;
	commandFunctions[87 | 0x0200 ] = handlerCommand16Code0057P67_RM;
	commandFunctions[87 | 0x0400] = handlerCommand16Code0057P66_RM;
	commandFunctions[87 | 0x0200 | 0x0400] = handlerCommand16Code0057P66P67_RM;
	commandFunctions[88] = handlerCommand16Code0058_RM;
	commandFunctions[88 | 0x0200 ] = handlerCommand16Code0058P67_RM;
	commandFunctions[88 | 0x0400] = handlerCommand16Code0058P66_RM;
	commandFunctions[88 | 0x0200 | 0x0400] = handlerCommand16Code0058P66P67_RM;
	commandFunctions[89] = handlerCommand16Code0059_RM;
	commandFunctions[89 | 0x0200 ] = handlerCommand16Code0059P67_RM;
	commandFunctions[89 | 0x0400] = handlerCommand16Code0059P66_RM;
	commandFunctions[89 | 0x0200 | 0x0400] = handlerCommand16Code0059P66P67_RM;
	commandFunctions[90] = handlerCommand16Code005A_RM;
	commandFunctions[90 | 0x0200 ] = handlerCommand16Code005AP67_RM;
	commandFunctions[90 | 0x0400] = handlerCommand16Code005AP66_RM;
	commandFunctions[90 | 0x0200 | 0x0400] = handlerCommand16Code005AP66P67_RM;
	commandFunctions[91] = handlerCommand16Code005B_RM;
	commandFunctions[91 | 0x0200 ] = handlerCommand16Code005BP67_RM;
	commandFunctions[91 | 0x0400] = handlerCommand16Code005BP66_RM;
	commandFunctions[91 | 0x0200 | 0x0400] = handlerCommand16Code005BP66P67_RM;
	commandFunctions[92] = handlerCommand16Code005C_RM;
	commandFunctions[92 | 0x0200 ] = handlerCommand16Code005CP67_RM;
	commandFunctions[92 | 0x0400] = handlerCommand16Code005CP66_RM;
	commandFunctions[92 | 0x0200 | 0x0400] = handlerCommand16Code005CP66P67_RM;
	commandFunctions[93] = handlerCommand16Code005D_RM;
	commandFunctions[93 | 0x0200 ] = handlerCommand16Code005DP67_RM;
	commandFunctions[93 | 0x0400] = handlerCommand16Code005DP66_RM;
	commandFunctions[93 | 0x0200 | 0x0400] = handlerCommand16Code005DP66P67_RM;
	commandFunctions[94] = handlerCommand16Code005E_RM;
	commandFunctions[94 | 0x0200 ] = handlerCommand16Code005EP67_RM;
	commandFunctions[94 | 0x0400] = handlerCommand16Code005EP66_RM;
	commandFunctions[94 | 0x0200 | 0x0400] = handlerCommand16Code005EP66P67_RM;
	commandFunctions[95] = handlerCommand16Code005F_RM;
	commandFunctions[95 | 0x0200 ] = handlerCommand16Code005FP67_RM;
	commandFunctions[95 | 0x0400] = handlerCommand16Code005FP66_RM;
	commandFunctions[95 | 0x0200 | 0x0400] = handlerCommand16Code005FP66P67_RM;
	commandFunctions[96] = handlerCommand16Code0060_RM;
	commandFunctions[96 | 0x0400] = handlerCommand16Code0060P66_RM;
	commandFunctions[97] = handlerCommand16Code0061_RM;
	commandFunctions[97 | 0x0400] = handlerCommand16Code0061P66_RM;
	commandFunctions[104] = handlerCommand16Code0068_RM;
	commandFunctions[104 | 0x0200 ] = handlerCommand16Code0068P67_RM;
	commandFunctions[104 | 0x0400] = handlerCommand16Code0068P66_RM;
	commandFunctions[104 | 0x0200 | 0x0400] = handlerCommand16Code0068P66P67_RM;
	commandFunctions[105] = handlerCommand16Code0069_RM;
	commandFunctions[105 | 0x0400] = handlerCommand16Code0069P66_RM;
	commandFunctions[106] = handlerCommand16Code006A_RM;
	commandFunctions[106 | 0x0200 ] = handlerCommand16Code006AP67_RM;
	commandFunctions[106 | 0x0400] = handlerCommand16Code006AP66_RM;
	commandFunctions[106 | 0x0200 | 0x0400] = handlerCommand16Code006AP66P67_RM;
	commandFunctions[107] = handlerCommand16Code006B_RM;
	commandFunctions[112] = handlerCommand16Code0070_RM;
	commandFunctions[113] = handlerCommand16Code0071_RM;
	commandFunctions[114] = handlerCommand16Code0072_RM;
	commandFunctions[115] = handlerCommand16Code0073_RM;
	commandFunctions[116] = handlerCommand16Code0074_RM;
	commandFunctions[117] = handlerCommand16Code0075_RM;
	commandFunctions[118] = handlerCommand16Code0076_RM;
	commandFunctions[119] = handlerCommand16Code0077_RM;
	commandFunctions[120] = handlerCommand16Code0078_RM;
	commandFunctions[121] = handlerCommand16Code0079_RM;
	commandFunctions[122] = handlerCommand16Code007A_RM;
	commandFunctions[123] = handlerCommand16Code007B_RM;
	commandFunctions[124] = handlerCommand16Code007C_RM;
	commandFunctions[125] = handlerCommand16Code007D_RM;
	commandFunctions[126] = handlerCommand16Code007E_RM;
	commandFunctions[127] = handlerCommand16Code007F_RM;
	commandFunctions[128] = handlerCommand16Code0080_RM;
	commandFunctions[128 | 0x0400] = handlerCommand16Code0080P66_RM;
	commandFunctions[129] = handlerCommand16Code0081_RM;
	commandFunctions[129 | 0x0400] = handlerCommand16Code0081P66_RM;
	commandFunctions[130] = handlerCommand16Code0082_RM;
	commandFunctions[131] = handlerCommand16Code0083_RM;
	commandFunctions[132] = handlerCommand16Code0084_RM;
	commandFunctions[132 | 0x0400] = handlerCommand16Code0084P66_RM;
	commandFunctions[133] = handlerCommand16Code0085_RM;
	commandFunctions[133 | 0x0400] = handlerCommand16Code0085P66_RM;
	commandFunctions[134] = handlerCommand16Code0086_RM;
	commandFunctions[134 | 0x0400] = handlerCommand16Code0086P66_RM;
	commandFunctions[135] = handlerCommand16Code0087_RM;
	commandFunctions[135 | 0x0400] = handlerCommand16Code0087P66_RM;
	commandFunctions[136] = handlerCommand16Code0088_RM;
	commandFunctions[136 | 0x0400] = handlerCommand16Code0088P66_RM;
	commandFunctions[137] = handlerCommand16Code0089_RM;
	commandFunctions[137 | 0x0400] = handlerCommand16Code0089P66_RM;
	commandFunctions[138] = handlerCommand16Code008A_RM;
	commandFunctions[138 | 0x0400] = handlerCommand16Code008AP66_RM;
	commandFunctions[139] = handlerCommand16Code008B_RM;
	commandFunctions[139 | 0x0400] = handlerCommand16Code008BP66_RM;
	commandFunctions[140] = handlerCommand16Code008C_RM;
	commandFunctions[142] = handlerCommand16Code008E_RM;
	commandFunctions[141] = handlerCommand16Code008D_RM;
	commandFunctions[141 | 0x0200 ] = handlerCommand16Code008DP67_RM;
	commandFunctions[141 | 0x0400] = handlerCommand16Code008DP66_RM;
	commandFunctions[141 | 0x0200 | 0x0400] = handlerCommand16Code008DP66P67_RM;
	commandFunctions[143] = handlerCommand16Code008F_RM;
	commandFunctions[143 | 0x0200 ] = handlerCommand16Code008FP67_RM;
	commandFunctions[143 | 0x0400] = handlerCommand16Code008FP66_RM;
	commandFunctions[143 | 0x0200 | 0x0400] = handlerCommand16Code008FP66P67_RM;
	commandFunctions[144] = handlerCommand16Code0090_RM;
	commandFunctions[144 | 0x0400] = handlerCommand16Code0090P66_RM;
	commandFunctions[145] = handlerCommand16Code0091_RM;
	commandFunctions[145 | 0x0400] = handlerCommand16Code0091P66_RM;
	commandFunctions[146] = handlerCommand16Code0092_RM;
	commandFunctions[146 | 0x0400] = handlerCommand16Code0092P66_RM;
	commandFunctions[147] = handlerCommand16Code0093_RM;
	commandFunctions[147 | 0x0400] = handlerCommand16Code0093P66_RM;
	commandFunctions[148] = handlerCommand16Code0094_RM;
	commandFunctions[148 | 0x0400] = handlerCommand16Code0094P66_RM;
	commandFunctions[149] = handlerCommand16Code0095_RM;
	commandFunctions[149 | 0x0400] = handlerCommand16Code0095P66_RM;
	commandFunctions[150] = handlerCommand16Code0096_RM;
	commandFunctions[150 | 0x0400] = handlerCommand16Code0096P66_RM;
	commandFunctions[151] = handlerCommand16Code0097_RM;
	commandFunctions[151 | 0x0400] = handlerCommand16Code0097P66_RM;
	commandFunctions[152] = handlerCommand16Code0098_RM;
	commandFunctions[152 | 0x0400] = handlerCommand16Code0098P66_RM;
	commandFunctions[153] = handlerCommand16Code0099_RM;
	commandFunctions[153 | 0x0400] = handlerCommand16Code0099P66_RM;
	commandFunctions[154] = handlerCommand16Code009A_RM;
	commandFunctions[156] = handlerCommand16Code009C_RM;
	commandFunctions[156 | 0x0400] = handlerCommand16Code009CP66_RM;
	commandFunctions[157] = handlerCommand16Code009D_RM;
	commandFunctions[157 | 0x0400] = handlerCommand16Code009DP66_RM;
	commandFunctions[160] = handlerCommand16Code00A0_RM;
	commandFunctions[160 | 0x0200 ] = handlerCommand16Code00A0P67_RM;
	commandFunctions[160 | 0x0400] = handlerCommand16Code00A0P66_RM;
	commandFunctions[160 | 0x0200 | 0x0400] = handlerCommand16Code00A0P66P67_RM;
	commandFunctions[161] = handlerCommand16Code00A1_RM;
	commandFunctions[161 | 0x0200 ] = handlerCommand16Code00A1P67_RM;
	commandFunctions[161 | 0x0400] = handlerCommand16Code00A1P66_RM;
	commandFunctions[161 | 0x0200 | 0x0400] = handlerCommand16Code00A1P66P67_RM;
	commandFunctions[162] = handlerCommand16Code00A2_RM;
	commandFunctions[162 | 0x0200 ] = handlerCommand16Code00A2P67_RM;
	commandFunctions[162 | 0x0400] = handlerCommand16Code00A2P66_RM;
	commandFunctions[162 | 0x0200 | 0x0400] = handlerCommand16Code00A2P66P67_RM;
	commandFunctions[163] = handlerCommand16Code00A3_RM;
	commandFunctions[163 | 0x0200 ] = handlerCommand16Code00A3P67_RM;
	commandFunctions[163 | 0x0400] = handlerCommand16Code00A3P66_RM;
	commandFunctions[163 | 0x0200 | 0x0400] = handlerCommand16Code00A3P66P67_RM;
	commandFunctions[164] = handlerCommand16Code00A4_RM;
	commandFunctions[164 | 0x0200 ] = handlerCommand16Code00A4P67_RM;
	commandFunctions[164 | 0x0400] = handlerCommand16Code00A4P66_RM;
	commandFunctions[164 | 0x0200 | 0x0400] = handlerCommand16Code00A4P66P67_RM;
	commandFunctions[165] = handlerCommand16Code00A5_RM;
	commandFunctions[165 | 0x0200 ] = handlerCommand16Code00A5P67_RM;
	commandFunctions[165 | 0x0400] = handlerCommand16Code00A5P66_RM;
	commandFunctions[165 | 0x0200 | 0x0400] = handlerCommand16Code00A5P66P67_RM;
	commandFunctions[166] = handlerCommand16Code00A6_RM;
	commandFunctions[166 | 0x0200 ] = handlerCommand16Code00A6P67_RM;
	commandFunctions[166 | 0x0400] = handlerCommand16Code00A6P66_RM;
	commandFunctions[166 | 0x0200 | 0x0400] = handlerCommand16Code00A6P66P67_RM;
	commandFunctions[167] = handlerCommand16Code00A7_RM;
	commandFunctions[167 | 0x0200 ] = handlerCommand16Code00A7P67_RM;
	commandFunctions[167 | 0x0400] = handlerCommand16Code00A7P66_RM;
	commandFunctions[167 | 0x0200 | 0x0400] = handlerCommand16Code00A7P66P67_RM;
	commandFunctions[168] = handlerCommand16Code00A8_RM;
	commandFunctions[168 | 0x0400] = handlerCommand16Code00A8P66_RM;
	commandFunctions[169] = handlerCommand16Code00A9_RM;
	commandFunctions[169 | 0x0400] = handlerCommand16Code00A9P66_RM;
	commandFunctions[170] = handlerCommand16Code00AA_RM;
	commandFunctions[170 | 0x0200 ] = handlerCommand16Code00AAP67_RM;
	commandFunctions[170 | 0x0400] = handlerCommand16Code00AAP66_RM;
	commandFunctions[170 | 0x0200 | 0x0400] = handlerCommand16Code00AAP66P67_RM;
	commandFunctions[171] = handlerCommand16Code00AB_RM;
	commandFunctions[171 | 0x0200 ] = handlerCommand16Code00ABP67_RM;
	commandFunctions[171 | 0x0400] = handlerCommand16Code00ABP66_RM;
	commandFunctions[171 | 0x0200 | 0x0400] = handlerCommand16Code00ABP66P67_RM;
	commandFunctions[172] = handlerCommand16Code00AC_RM;
	commandFunctions[172 | 0x0200 ] = handlerCommand16Code00ACP67_RM;
	commandFunctions[172 | 0x0400] = handlerCommand16Code00ACP66_RM;
	commandFunctions[172 | 0x0200 | 0x0400] = handlerCommand16Code00ACP66P67_RM;
	commandFunctions[173] = handlerCommand16Code00AD_RM;
	commandFunctions[173 | 0x0200 ] = handlerCommand16Code00ADP67_RM;
	commandFunctions[173 | 0x0400] = handlerCommand16Code00ADP66_RM;
	commandFunctions[173 | 0x0200 | 0x0400] = handlerCommand16Code00ADP66P67_RM;
	commandFunctions[174] = handlerCommand16Code00AE_RM;
	commandFunctions[174 | 0x0200 ] = handlerCommand16Code00AEP67_RM;
	commandFunctions[174 | 0x0400] = handlerCommand16Code00AEP66_RM;
	commandFunctions[174 | 0x0200 | 0x0400] = handlerCommand16Code00AEP66P67_RM;
	commandFunctions[175] = handlerCommand16Code00AF_RM;
	commandFunctions[175 | 0x0200 ] = handlerCommand16Code00AFP67_RM;
	commandFunctions[175 | 0x0400] = handlerCommand16Code00AFP66_RM;
	commandFunctions[175 | 0x0200 | 0x0400] = handlerCommand16Code00AFP66P67_RM;
	commandFunctions[176] = handlerCommand16Code00B0_RM;
	commandFunctions[176 | 0x0400] = handlerCommand16Code00B0P66_RM;
	commandFunctions[177] = handlerCommand16Code00B1_RM;
	commandFunctions[177 | 0x0400] = handlerCommand16Code00B1P66_RM;
	commandFunctions[178] = handlerCommand16Code00B2_RM;
	commandFunctions[178 | 0x0400] = handlerCommand16Code00B2P66_RM;
	commandFunctions[179] = handlerCommand16Code00B3_RM;
	commandFunctions[179 | 0x0400] = handlerCommand16Code00B3P66_RM;
	commandFunctions[180] = handlerCommand16Code00B4_RM;
	commandFunctions[180 | 0x0400] = handlerCommand16Code00B4P66_RM;
	commandFunctions[181] = handlerCommand16Code00B5_RM;
	commandFunctions[181 | 0x0400] = handlerCommand16Code00B5P66_RM;
	commandFunctions[182] = handlerCommand16Code00B6_RM;
	commandFunctions[182 | 0x0400] = handlerCommand16Code00B6P66_RM;
	commandFunctions[183] = handlerCommand16Code00B7_RM;
	commandFunctions[183 | 0x0400] = handlerCommand16Code00B7P66_RM;
	commandFunctions[184] = handlerCommand16Code00B8_RM;
	commandFunctions[184 | 0x0400] = handlerCommand16Code00B8P66_RM;
	commandFunctions[185] = handlerCommand16Code00B9_RM;
	commandFunctions[185 | 0x0400] = handlerCommand16Code00B9P66_RM;
	commandFunctions[186] = handlerCommand16Code00BA_RM;
	commandFunctions[186 | 0x0400] = handlerCommand16Code00BAP66_RM;
	commandFunctions[187] = handlerCommand16Code00BB_RM;
	commandFunctions[187 | 0x0400] = handlerCommand16Code00BBP66_RM;
	commandFunctions[188] = handlerCommand16Code00BC_RM;
	commandFunctions[188 | 0x0400] = handlerCommand16Code00BCP66_RM;
	commandFunctions[189] = handlerCommand16Code00BD_RM;
	commandFunctions[189 | 0x0400] = handlerCommand16Code00BDP66_RM;
	commandFunctions[190] = handlerCommand16Code00BE_RM;
	commandFunctions[190 | 0x0400] = handlerCommand16Code00BEP66_RM;
	commandFunctions[191] = handlerCommand16Code00BF_RM;
	commandFunctions[191 | 0x0400] = handlerCommand16Code00BFP66_RM;
	commandFunctions[192] = handlerCommand16Code00C0_RM;
	commandFunctions[192 | 0x0400] = handlerCommand16Code00C0P66_RM;
	commandFunctions[193] = handlerCommand16Code00C1_RM;
	commandFunctions[193 | 0x0400] = handlerCommand16Code00C1P66_RM;
	commandFunctions[194] = handlerCommand16Code00C2_RM;
	commandFunctions[195] = handlerCommand16Code00C3_RM;
	commandFunctions[196] = handlerCommand16Code00C4_RM;
	commandFunctions[197] = handlerCommand16Code00C5_RM;
	commandFunctions[198] = handlerCommand16Code00C6_RM;
	commandFunctions[198 | 0x0400] = handlerCommand16Code00C6P66_RM;
	commandFunctions[199] = handlerCommand16Code00C7_RM;
	commandFunctions[199 | 0x0400] = handlerCommand16Code00C7P66_RM;
	commandFunctions[200] = handlerCommand16Code00C8_RM;
	commandFunctions[200 | 0x0200 ] = handlerCommand16Code00C8P67_RM;
	commandFunctions[200 | 0x0400] = handlerCommand16Code00C8P66_RM;
	commandFunctions[200 | 0x0200 | 0x0400] = handlerCommand16Code00C8P66P67_RM;
	commandFunctions[201] = handlerCommand16Code00C9_RM;
	commandFunctions[201 | 0x0200 ] = handlerCommand16Code00C9P67_RM;
	commandFunctions[201 | 0x0400] = handlerCommand16Code00C9P66_RM;
	commandFunctions[201 | 0x0200 | 0x0400] = handlerCommand16Code00C9P66P67_RM;
	commandFunctions[202] = handlerCommand16Code00CA_RM;
	commandFunctions[203] = handlerCommand16Code00CB_RM;
	commandFunctions[205] = handlerCommand16Code00CD_RM;
	commandFunctions[208] = handlerCommand16Code00D0_RM;
	commandFunctions[208 | 0x0400] = handlerCommand16Code00D0P66_RM;
	commandFunctions[209] = handlerCommand16Code00D1_RM;
	commandFunctions[209 | 0x0400] = handlerCommand16Code00D1P66_RM;
	commandFunctions[210] = handlerCommand16Code00D2_RM;
	commandFunctions[210 | 0x0400] = handlerCommand16Code00D2P66_RM;
	commandFunctions[211] = handlerCommand16Code00D3_RM;
	commandFunctions[211 | 0x0400] = handlerCommand16Code00D3P66_RM;
	commandFunctions[216] = handlerCommand16Code00D8_RM;
	commandFunctions[217] = handlerCommand16Code00D9_RM;
	commandFunctions[218] = handlerCommand16Code00DA_RM;
	commandFunctions[219] = handlerCommand16Code00DB_RM;
	commandFunctions[220] = handlerCommand16Code00DC_RM;
	commandFunctions[221] = handlerCommand16Code00DD_RM;
	commandFunctions[222] = handlerCommand16Code00DE_RM;
	commandFunctions[223] = handlerCommand16Code00DF_RM;
	commandFunctions[224] = handlerCommand16Code00E0_RM;
	commandFunctions[225] = handlerCommand16Code00E1_RM;
	commandFunctions[226] = handlerCommand16Code00E2_RM;
	commandFunctions[227] = handlerCommand16Code00E3_RM;
	commandFunctions[228] = handlerCommand16Code00E4_RM;
	commandFunctions[228 | 0x0400] = handlerCommand16Code00E4P66_RM;
	commandFunctions[229] = handlerCommand16Code00E5_RM;
	commandFunctions[229 | 0x0400] = handlerCommand16Code00E5P66_RM;
	commandFunctions[230] = handlerCommand16Code00E6_RM;
	commandFunctions[230 | 0x0400] = handlerCommand16Code00E6P66_RM;
	commandFunctions[231] = handlerCommand16Code00E7_RM;
	commandFunctions[231 | 0x0400] = handlerCommand16Code00E7P66_RM;
	commandFunctions[232] = handlerCommand16Code00E8_RM;
	commandFunctions[232 | 0x0400] = handlerCommand16Code00E8P66_RM;
	commandFunctions[233] = handlerCommand16Code00E9_RM;
	commandFunctions[233 | 0x0400] = handlerCommand16Code00E9P66_RM;
	commandFunctions[235] = handlerCommand16Code00EB_RM;
	commandFunctions[236] = handlerCommand16Code00EC_RM;
	commandFunctions[236 | 0x0400] = handlerCommand16Code00ECP66_RM;
	commandFunctions[237] = handlerCommand16Code00ED_RM;
	commandFunctions[237 | 0x0400] = handlerCommand16Code00EDP66_RM;
	commandFunctions[238] = handlerCommand16Code00EE_RM;
	commandFunctions[238 | 0x0400] = handlerCommand16Code00EEP66_RM;
	commandFunctions[239] = handlerCommand16Code00EF_RM;
	commandFunctions[239 | 0x0400] = handlerCommand16Code00EFP66_RM;
	commandFunctions[241] = handlerCommand16Code00F1_RM;
	commandFunctions[245] = handlerCommand16Code00F5_RM;
	commandFunctions[246] = handlerCommand16Code00F6_RM;
	commandFunctions[246 | 0x0400] = handlerCommand16Code00F6P66_RM;
	commandFunctions[247] = handlerCommand16Code00F7_RM;
	commandFunctions[247 | 0x0400] = handlerCommand16Code00F7P66_RM;
	commandFunctions[248] = handlerCommand16Code00F8_RM;
	commandFunctions[249] = handlerCommand16Code00F9_RM;
	commandFunctions[250] = handlerCommand16Code00FA_RM;
	commandFunctions[251] = handlerCommand16Code00FB_RM;
	commandFunctions[252] = handlerCommand16Code00FC_RM;
	commandFunctions[253] = handlerCommand16Code00FD_RM;
	commandFunctions[254] = handlerCommand16Code00FE_RM;
	commandFunctions[255] = handlerCommand16Code00FF_RM;
	commandFunctions[255 | 0x0200 ] = handlerCommand16Code00FFP67_RM;
	commandFunctions[255 | 0x0400] = handlerCommand16Code00FFP66_RM;
	commandFunctions[255 | 0x0200 | 0x0400] = handlerCommand16Code00FFP66P67_RM;
	commandFunctions[257] = handlerCommand16Code0101_RM;
	commandFunctions[384] = handlerCommand16Code0180_RM;
	commandFunctions[385] = handlerCommand16Code0181_RM;
	commandFunctions[386] = handlerCommand16Code0182_RM;
	commandFunctions[387] = handlerCommand16Code0183_RM;
	commandFunctions[388] = handlerCommand16Code0184_RM;
	commandFunctions[389] = handlerCommand16Code0185_RM;
	commandFunctions[390] = handlerCommand16Code0186_RM;
	commandFunctions[391] = handlerCommand16Code0187_RM;
	commandFunctions[392] = handlerCommand16Code0188_RM;
	commandFunctions[393] = handlerCommand16Code0189_RM;
	commandFunctions[394] = handlerCommand16Code018A_RM;
	commandFunctions[395] = handlerCommand16Code018B_RM;
	commandFunctions[396] = handlerCommand16Code018C_RM;
	commandFunctions[397] = handlerCommand16Code018D_RM;
	commandFunctions[398] = handlerCommand16Code018E_RM;
	commandFunctions[399] = handlerCommand16Code018F_RM;
	commandFunctions[400] = handlerCommand16Code0190_RM;
	commandFunctions[400 | 0x0400] = handlerCommand16Code0190P66_RM;
	commandFunctions[401] = handlerCommand16Code0191_RM;
	commandFunctions[401 | 0x0400] = handlerCommand16Code0191P66_RM;
	commandFunctions[402] = handlerCommand16Code0192_RM;
	commandFunctions[402 | 0x0400] = handlerCommand16Code0192P66_RM;
	commandFunctions[403] = handlerCommand16Code0193_RM;
	commandFunctions[403 | 0x0400] = handlerCommand16Code0193P66_RM;
	commandFunctions[404] = handlerCommand16Code0194_RM;
	commandFunctions[404 | 0x0400] = handlerCommand16Code0194P66_RM;
	commandFunctions[405] = handlerCommand16Code0195_RM;
	commandFunctions[405 | 0x0400] = handlerCommand16Code0195P66_RM;
	commandFunctions[406] = handlerCommand16Code0196_RM;
	commandFunctions[406 | 0x0400] = handlerCommand16Code0196P66_RM;
	commandFunctions[407] = handlerCommand16Code0197_RM;
	commandFunctions[407 | 0x0400] = handlerCommand16Code0197P66_RM;
	commandFunctions[408] = handlerCommand16Code0198_RM;
	commandFunctions[408 | 0x0400] = handlerCommand16Code0198P66_RM;
	commandFunctions[409] = handlerCommand16Code0199_RM;
	commandFunctions[409 | 0x0400] = handlerCommand16Code0199P66_RM;
	commandFunctions[410] = handlerCommand16Code019A_RM;
	commandFunctions[410 | 0x0400] = handlerCommand16Code019AP66_RM;
	commandFunctions[411] = handlerCommand16Code019B_RM;
	commandFunctions[411 | 0x0400] = handlerCommand16Code019BP66_RM;
	commandFunctions[412] = handlerCommand16Code019C_RM;
	commandFunctions[412 | 0x0400] = handlerCommand16Code019CP66_RM;
	commandFunctions[413] = handlerCommand16Code019D_RM;
	commandFunctions[413 | 0x0400] = handlerCommand16Code019DP66_RM;
	commandFunctions[414] = handlerCommand16Code019E_RM;
	commandFunctions[414 | 0x0400] = handlerCommand16Code019EP66_RM;
	commandFunctions[415] = handlerCommand16Code019F_RM;
	commandFunctions[415 | 0x0400] = handlerCommand16Code019FP66_RM;
	commandFunctions[419] = handlerCommand16Code01A3_RM;
	commandFunctions[419 | 0x0400] = handlerCommand16Code01A3P66_RM;
	commandFunctions[427] = handlerCommand16Code01AB_RM;
	commandFunctions[427 | 0x0400] = handlerCommand16Code01ABP66_RM;
	commandFunctions[431] = handlerCommand16Code01AF_RM;
	commandFunctions[431 | 0x0400] = handlerCommand16Code01AFP66_RM;
	commandFunctions[434] = handlerCommand16Code01B2_RM;
	commandFunctions[435] = handlerCommand16Code01B3_RM;
	commandFunctions[435 | 0x0400] = handlerCommand16Code01B3P66_RM;
	commandFunctions[436] = handlerCommand16Code01B4_RM;
	commandFunctions[437] = handlerCommand16Code01B5_RM;
	commandFunctions[438] = handlerCommand16Code01B6_RM;
	commandFunctions[439] = handlerCommand16Code01B7_RM;
	commandFunctions[439 | 0x0400] = handlerCommand16Code01B7P66_RM;
	commandFunctions[442] = handlerCommand16Code01BA_RM;
	commandFunctions[442 | 0x0400] = handlerCommand16Code01BAP66_RM;
	commandFunctions[443] = handlerCommand16Code01BB_RM;
	commandFunctions[443 | 0x0400] = handlerCommand16Code01BBP66_RM;
	commandFunctions[444] = handlerCommand16Code01BC_RM;
	commandFunctions[444 | 0x0400] = handlerCommand16Code01BCP66_RM;
	commandFunctions[445] = handlerCommand16Code01BD_RM;
	commandFunctions[445 | 0x0400] = handlerCommand16Code01BDP66_RM;
	commandFunctions[446] = handlerCommand16Code01BE_RM;
	commandFunctions[447] = handlerCommand16Code01BF_RM;
	commandFunctions[456] = handlerCommand16Code01C8_RM;
	commandFunctions[457] = handlerCommand16Code01C9_RM;
	commandFunctions[458] = handlerCommand16Code01CA_RM;
	commandFunctions[459] = handlerCommand16Code01CB_RM;
	commandFunctions[460] = handlerCommand16Code01CC_RM;
	commandFunctions[461] = handlerCommand16Code01CD_RM;
	commandFunctions[462] = handlerCommand16Code01CE_RM;
	commandFunctions[463] = handlerCommand16Code01CF_RM;
}
void installCommandFunction32RM() {
	for(int i = 0; i < 256 * 8; i++) {
		commandFunctions[i] = mCommandFunctionEmpty;
	}
	commandFunctions[0] = handlerCommand32Code0000_RM;
	commandFunctions[0 | 0x0400] = handlerCommand32Code0000P66_RM;
	commandFunctions[1] = handlerCommand32Code0001_RM;
	commandFunctions[1 | 0x0400] = handlerCommand32Code0001P66_RM;
	commandFunctions[2] = handlerCommand32Code0002_RM;
	commandFunctions[2 | 0x0400] = handlerCommand32Code0002P66_RM;
	commandFunctions[3] = handlerCommand32Code0003_RM;
	commandFunctions[3 | 0x0400] = handlerCommand32Code0003P66_RM;
	commandFunctions[4] = handlerCommand32Code0004_RM;
	commandFunctions[4 | 0x0400] = handlerCommand32Code0004P66_RM;
	commandFunctions[5] = handlerCommand32Code0005_RM;
	commandFunctions[5 | 0x0400] = handlerCommand32Code0005P66_RM;
	commandFunctions[6] = handlerCommand32Code0006_RM;
	commandFunctions[14] = handlerCommand32Code000E_RM;
	commandFunctions[22] = handlerCommand32Code0016_RM;
	commandFunctions[30] = handlerCommand32Code001E_RM;
	commandFunctions[7] = handlerCommand32Code0007_RM;
	commandFunctions[15] = handlerCommand32Code000F_RM;
	commandFunctions[23] = handlerCommand32Code0017_RM;
	commandFunctions[31] = handlerCommand32Code001F_RM;
	commandFunctions[8] = handlerCommand32Code0008_RM;
	commandFunctions[8 | 0x0400] = handlerCommand32Code0008P66_RM;
	commandFunctions[9] = handlerCommand32Code0009_RM;
	commandFunctions[9 | 0x0400] = handlerCommand32Code0009P66_RM;
	commandFunctions[10] = handlerCommand32Code000A_RM;
	commandFunctions[10 | 0x0400] = handlerCommand32Code000AP66_RM;
	commandFunctions[11] = handlerCommand32Code000B_RM;
	commandFunctions[11 | 0x0400] = handlerCommand32Code000BP66_RM;
	commandFunctions[12] = handlerCommand32Code000C_RM;
	commandFunctions[12 | 0x0400] = handlerCommand32Code000CP66_RM;
	commandFunctions[13] = handlerCommand32Code000D_RM;
	commandFunctions[13 | 0x0400] = handlerCommand32Code000DP66_RM;
	commandFunctions[16] = handlerCommand32Code0010_RM;
	commandFunctions[16 | 0x0400] = handlerCommand32Code0010P66_RM;
	commandFunctions[17] = handlerCommand32Code0011_RM;
	commandFunctions[17 | 0x0400] = handlerCommand32Code0011P66_RM;
	commandFunctions[18] = handlerCommand32Code0012_RM;
	commandFunctions[18 | 0x0400] = handlerCommand32Code0012P66_RM;
	commandFunctions[19] = handlerCommand32Code0013_RM;
	commandFunctions[19 | 0x0400] = handlerCommand32Code0013P66_RM;
	commandFunctions[20] = handlerCommand32Code0014_RM;
	commandFunctions[20 | 0x0400] = handlerCommand32Code0014P66_RM;
	commandFunctions[21] = handlerCommand32Code0015_RM;
	commandFunctions[21 | 0x0400] = handlerCommand32Code0015P66_RM;
	commandFunctions[24] = handlerCommand32Code0018_RM;
	commandFunctions[24 | 0x0400] = handlerCommand32Code0018P66_RM;
	commandFunctions[25] = handlerCommand32Code0019_RM;
	commandFunctions[25 | 0x0400] = handlerCommand32Code0019P66_RM;
	commandFunctions[26] = handlerCommand32Code001A_RM;
	commandFunctions[26 | 0x0400] = handlerCommand32Code001AP66_RM;
	commandFunctions[27] = handlerCommand32Code001B_RM;
	commandFunctions[27 | 0x0400] = handlerCommand32Code001BP66_RM;
	commandFunctions[28] = handlerCommand32Code001C_RM;
	commandFunctions[28 | 0x0400] = handlerCommand32Code001CP66_RM;
	commandFunctions[29] = handlerCommand32Code001D_RM;
	commandFunctions[29 | 0x0400] = handlerCommand32Code001DP66_RM;
	commandFunctions[32] = handlerCommand32Code0020_RM;
	commandFunctions[32 | 0x0400] = handlerCommand32Code0020P66_RM;
	commandFunctions[33] = handlerCommand32Code0021_RM;
	commandFunctions[33 | 0x0400] = handlerCommand32Code0021P66_RM;
	commandFunctions[34] = handlerCommand32Code0022_RM;
	commandFunctions[34 | 0x0400] = handlerCommand32Code0022P66_RM;
	commandFunctions[35] = handlerCommand32Code0023_RM;
	commandFunctions[35 | 0x0400] = handlerCommand32Code0023P66_RM;
	commandFunctions[36] = handlerCommand32Code0024_RM;
	commandFunctions[36 | 0x0400] = handlerCommand32Code0024P66_RM;
	commandFunctions[37] = handlerCommand32Code0025_RM;
	commandFunctions[37 | 0x0400] = handlerCommand32Code0025P66_RM;
	commandFunctions[40] = handlerCommand32Code0028_RM;
	commandFunctions[40 | 0x0400] = handlerCommand32Code0028P66_RM;
	commandFunctions[41] = handlerCommand32Code0029_RM;
	commandFunctions[41 | 0x0400] = handlerCommand32Code0029P66_RM;
	commandFunctions[42] = handlerCommand32Code002A_RM;
	commandFunctions[42 | 0x0400] = handlerCommand32Code002AP66_RM;
	commandFunctions[43] = handlerCommand32Code002B_RM;
	commandFunctions[43 | 0x0400] = handlerCommand32Code002BP66_RM;
	commandFunctions[44] = handlerCommand32Code002C_RM;
	commandFunctions[44 | 0x0400] = handlerCommand32Code002CP66_RM;
	commandFunctions[45] = handlerCommand32Code002D_RM;
	commandFunctions[45 | 0x0400] = handlerCommand32Code002DP66_RM;
	commandFunctions[48] = handlerCommand32Code0030_RM;
	commandFunctions[48 | 0x0400] = handlerCommand32Code0030P66_RM;
	commandFunctions[49] = handlerCommand32Code0031_RM;
	commandFunctions[49 | 0x0400] = handlerCommand32Code0031P66_RM;
	commandFunctions[50] = handlerCommand32Code0032_RM;
	commandFunctions[50 | 0x0400] = handlerCommand32Code0032P66_RM;
	commandFunctions[51] = handlerCommand32Code0033_RM;
	commandFunctions[51 | 0x0400] = handlerCommand32Code0033P66_RM;
	commandFunctions[52] = handlerCommand32Code0034_RM;
	commandFunctions[52 | 0x0400] = handlerCommand32Code0034P66_RM;
	commandFunctions[53] = handlerCommand32Code0035_RM;
	commandFunctions[53 | 0x0400] = handlerCommand32Code0035P66_RM;
	commandFunctions[56] = handlerCommand32Code0038_RM;
	commandFunctions[56 | 0x0400] = handlerCommand32Code0038P66_RM;
	commandFunctions[57] = handlerCommand32Code0039_RM;
	commandFunctions[57 | 0x0400] = handlerCommand32Code0039P66_RM;
	commandFunctions[58] = handlerCommand32Code003A_RM;
	commandFunctions[58 | 0x0400] = handlerCommand32Code003AP66_RM;
	commandFunctions[59] = handlerCommand32Code003B_RM;
	commandFunctions[59 | 0x0400] = handlerCommand32Code003BP66_RM;
	commandFunctions[60] = handlerCommand32Code003C_RM;
	commandFunctions[60 | 0x0400] = handlerCommand32Code003CP66_RM;
	commandFunctions[61] = handlerCommand32Code003D_RM;
	commandFunctions[61 | 0x0400] = handlerCommand32Code003DP66_RM;
	commandFunctions[64] = handlerCommand32Code0040_RM;
	commandFunctions[64 | 0x0400] = handlerCommand32Code0040P66_RM;
	commandFunctions[65] = handlerCommand32Code0041_RM;
	commandFunctions[65 | 0x0400] = handlerCommand32Code0041P66_RM;
	commandFunctions[66] = handlerCommand32Code0042_RM;
	commandFunctions[66 | 0x0400] = handlerCommand32Code0042P66_RM;
	commandFunctions[67] = handlerCommand32Code0043_RM;
	commandFunctions[67 | 0x0400] = handlerCommand32Code0043P66_RM;
	commandFunctions[68] = handlerCommand32Code0044_RM;
	commandFunctions[68 | 0x0400] = handlerCommand32Code0044P66_RM;
	commandFunctions[69] = handlerCommand32Code0045_RM;
	commandFunctions[69 | 0x0400] = handlerCommand32Code0045P66_RM;
	commandFunctions[70] = handlerCommand32Code0046_RM;
	commandFunctions[70 | 0x0400] = handlerCommand32Code0046P66_RM;
	commandFunctions[71] = handlerCommand32Code0047_RM;
	commandFunctions[71 | 0x0400] = handlerCommand32Code0047P66_RM;
	commandFunctions[72] = handlerCommand32Code0048_RM;
	commandFunctions[72 | 0x0400] = handlerCommand32Code0048P66_RM;
	commandFunctions[73] = handlerCommand32Code0049_RM;
	commandFunctions[73 | 0x0400] = handlerCommand32Code0049P66_RM;
	commandFunctions[74] = handlerCommand32Code004A_RM;
	commandFunctions[74 | 0x0400] = handlerCommand32Code004AP66_RM;
	commandFunctions[75] = handlerCommand32Code004B_RM;
	commandFunctions[75 | 0x0400] = handlerCommand32Code004BP66_RM;
	commandFunctions[76] = handlerCommand32Code004C_RM;
	commandFunctions[76 | 0x0400] = handlerCommand32Code004CP66_RM;
	commandFunctions[77] = handlerCommand32Code004D_RM;
	commandFunctions[77 | 0x0400] = handlerCommand32Code004DP66_RM;
	commandFunctions[78] = handlerCommand32Code004E_RM;
	commandFunctions[78 | 0x0400] = handlerCommand32Code004EP66_RM;
	commandFunctions[79] = handlerCommand32Code004F_RM;
	commandFunctions[79 | 0x0400] = handlerCommand32Code004FP66_RM;
	commandFunctions[80] = handlerCommand32Code0050_RM;
	commandFunctions[80 | 0x0200 ] = handlerCommand32Code0050P67_RM;
	commandFunctions[80 | 0x0400] = handlerCommand32Code0050P66_RM;
	commandFunctions[80 | 0x0200 | 0x0400] = handlerCommand32Code0050P66P67_RM;
	commandFunctions[81] = handlerCommand32Code0051_RM;
	commandFunctions[81 | 0x0200 ] = handlerCommand32Code0051P67_RM;
	commandFunctions[81 | 0x0400] = handlerCommand32Code0051P66_RM;
	commandFunctions[81 | 0x0200 | 0x0400] = handlerCommand32Code0051P66P67_RM;
	commandFunctions[82] = handlerCommand32Code0052_RM;
	commandFunctions[82 | 0x0200 ] = handlerCommand32Code0052P67_RM;
	commandFunctions[82 | 0x0400] = handlerCommand32Code0052P66_RM;
	commandFunctions[82 | 0x0200 | 0x0400] = handlerCommand32Code0052P66P67_RM;
	commandFunctions[83] = handlerCommand32Code0053_RM;
	commandFunctions[83 | 0x0200 ] = handlerCommand32Code0053P67_RM;
	commandFunctions[83 | 0x0400] = handlerCommand32Code0053P66_RM;
	commandFunctions[83 | 0x0200 | 0x0400] = handlerCommand32Code0053P66P67_RM;
	commandFunctions[84] = handlerCommand32Code0054_RM;
	commandFunctions[84 | 0x0200 ] = handlerCommand32Code0054P67_RM;
	commandFunctions[84 | 0x0400] = handlerCommand32Code0054P66_RM;
	commandFunctions[84 | 0x0200 | 0x0400] = handlerCommand32Code0054P66P67_RM;
	commandFunctions[85] = handlerCommand32Code0055_RM;
	commandFunctions[85 | 0x0200 ] = handlerCommand32Code0055P67_RM;
	commandFunctions[85 | 0x0400] = handlerCommand32Code0055P66_RM;
	commandFunctions[85 | 0x0200 | 0x0400] = handlerCommand32Code0055P66P67_RM;
	commandFunctions[86] = handlerCommand32Code0056_RM;
	commandFunctions[86 | 0x0200 ] = handlerCommand32Code0056P67_RM;
	commandFunctions[86 | 0x0400] = handlerCommand32Code0056P66_RM;
	commandFunctions[86 | 0x0200 | 0x0400] = handlerCommand32Code0056P66P67_RM;
	commandFunctions[87] = handlerCommand32Code0057_RM;
	commandFunctions[87 | 0x0200 ] = handlerCommand32Code0057P67_RM;
	commandFunctions[87 | 0x0400] = handlerCommand32Code0057P66_RM;
	commandFunctions[87 | 0x0200 | 0x0400] = handlerCommand32Code0057P66P67_RM;
	commandFunctions[88] = handlerCommand32Code0058_RM;
	commandFunctions[88 | 0x0200 ] = handlerCommand32Code0058P67_RM;
	commandFunctions[88 | 0x0400] = handlerCommand32Code0058P66_RM;
	commandFunctions[88 | 0x0200 | 0x0400] = handlerCommand32Code0058P66P67_RM;
	commandFunctions[89] = handlerCommand32Code0059_RM;
	commandFunctions[89 | 0x0200 ] = handlerCommand32Code0059P67_RM;
	commandFunctions[89 | 0x0400] = handlerCommand32Code0059P66_RM;
	commandFunctions[89 | 0x0200 | 0x0400] = handlerCommand32Code0059P66P67_RM;
	commandFunctions[90] = handlerCommand32Code005A_RM;
	commandFunctions[90 | 0x0200 ] = handlerCommand32Code005AP67_RM;
	commandFunctions[90 | 0x0400] = handlerCommand32Code005AP66_RM;
	commandFunctions[90 | 0x0200 | 0x0400] = handlerCommand32Code005AP66P67_RM;
	commandFunctions[91] = handlerCommand32Code005B_RM;
	commandFunctions[91 | 0x0200 ] = handlerCommand32Code005BP67_RM;
	commandFunctions[91 | 0x0400] = handlerCommand32Code005BP66_RM;
	commandFunctions[91 | 0x0200 | 0x0400] = handlerCommand32Code005BP66P67_RM;
	commandFunctions[92] = handlerCommand32Code005C_RM;
	commandFunctions[92 | 0x0200 ] = handlerCommand32Code005CP67_RM;
	commandFunctions[92 | 0x0400] = handlerCommand32Code005CP66_RM;
	commandFunctions[92 | 0x0200 | 0x0400] = handlerCommand32Code005CP66P67_RM;
	commandFunctions[93] = handlerCommand32Code005D_RM;
	commandFunctions[93 | 0x0200 ] = handlerCommand32Code005DP67_RM;
	commandFunctions[93 | 0x0400] = handlerCommand32Code005DP66_RM;
	commandFunctions[93 | 0x0200 | 0x0400] = handlerCommand32Code005DP66P67_RM;
	commandFunctions[94] = handlerCommand32Code005E_RM;
	commandFunctions[94 | 0x0200 ] = handlerCommand32Code005EP67_RM;
	commandFunctions[94 | 0x0400] = handlerCommand32Code005EP66_RM;
	commandFunctions[94 | 0x0200 | 0x0400] = handlerCommand32Code005EP66P67_RM;
	commandFunctions[95] = handlerCommand32Code005F_RM;
	commandFunctions[95 | 0x0200 ] = handlerCommand32Code005FP67_RM;
	commandFunctions[95 | 0x0400] = handlerCommand32Code005FP66_RM;
	commandFunctions[95 | 0x0200 | 0x0400] = handlerCommand32Code005FP66P67_RM;
	commandFunctions[96] = handlerCommand32Code0060_RM;
	commandFunctions[96 | 0x0400] = handlerCommand32Code0060P66_RM;
	commandFunctions[97] = handlerCommand32Code0061_RM;
	commandFunctions[97 | 0x0400] = handlerCommand32Code0061P66_RM;
	commandFunctions[104] = handlerCommand32Code0068_RM;
	commandFunctions[104 | 0x0200 ] = handlerCommand32Code0068P67_RM;
	commandFunctions[104 | 0x0400] = handlerCommand32Code0068P66_RM;
	commandFunctions[104 | 0x0200 | 0x0400] = handlerCommand32Code0068P66P67_RM;
	commandFunctions[105] = handlerCommand32Code0069_RM;
	commandFunctions[105 | 0x0400] = handlerCommand32Code0069P66_RM;
	commandFunctions[106] = handlerCommand32Code006A_RM;
	commandFunctions[106 | 0x0200 ] = handlerCommand32Code006AP67_RM;
	commandFunctions[106 | 0x0400] = handlerCommand32Code006AP66_RM;
	commandFunctions[106 | 0x0200 | 0x0400] = handlerCommand32Code006AP66P67_RM;
	commandFunctions[107] = handlerCommand32Code006B_RM;
	commandFunctions[112] = handlerCommand32Code0070_RM;
	commandFunctions[113] = handlerCommand32Code0071_RM;
	commandFunctions[114] = handlerCommand32Code0072_RM;
	commandFunctions[115] = handlerCommand32Code0073_RM;
	commandFunctions[116] = handlerCommand32Code0074_RM;
	commandFunctions[117] = handlerCommand32Code0075_RM;
	commandFunctions[118] = handlerCommand32Code0076_RM;
	commandFunctions[119] = handlerCommand32Code0077_RM;
	commandFunctions[120] = handlerCommand32Code0078_RM;
	commandFunctions[121] = handlerCommand32Code0079_RM;
	commandFunctions[122] = handlerCommand32Code007A_RM;
	commandFunctions[123] = handlerCommand32Code007B_RM;
	commandFunctions[124] = handlerCommand32Code007C_RM;
	commandFunctions[125] = handlerCommand32Code007D_RM;
	commandFunctions[126] = handlerCommand32Code007E_RM;
	commandFunctions[127] = handlerCommand32Code007F_RM;
	commandFunctions[128] = handlerCommand32Code0080_RM;
	commandFunctions[128 | 0x0400] = handlerCommand32Code0080P66_RM;
	commandFunctions[129] = handlerCommand32Code0081_RM;
	commandFunctions[129 | 0x0400] = handlerCommand32Code0081P66_RM;
	commandFunctions[130] = handlerCommand32Code0082_RM;
	commandFunctions[131] = handlerCommand32Code0083_RM;
	commandFunctions[132] = handlerCommand32Code0084_RM;
	commandFunctions[132 | 0x0400] = handlerCommand32Code0084P66_RM;
	commandFunctions[133] = handlerCommand32Code0085_RM;
	commandFunctions[133 | 0x0400] = handlerCommand32Code0085P66_RM;
	commandFunctions[134] = handlerCommand32Code0086_RM;
	commandFunctions[134 | 0x0400] = handlerCommand32Code0086P66_RM;
	commandFunctions[135] = handlerCommand32Code0087_RM;
	commandFunctions[135 | 0x0400] = handlerCommand32Code0087P66_RM;
	commandFunctions[136] = handlerCommand32Code0088_RM;
	commandFunctions[136 | 0x0400] = handlerCommand32Code0088P66_RM;
	commandFunctions[137] = handlerCommand32Code0089_RM;
	commandFunctions[137 | 0x0400] = handlerCommand32Code0089P66_RM;
	commandFunctions[138] = handlerCommand32Code008A_RM;
	commandFunctions[138 | 0x0400] = handlerCommand32Code008AP66_RM;
	commandFunctions[139] = handlerCommand32Code008B_RM;
	commandFunctions[139 | 0x0400] = handlerCommand32Code008BP66_RM;
	commandFunctions[140] = handlerCommand32Code008C_RM;
	commandFunctions[142] = handlerCommand32Code008E_RM;
	commandFunctions[141] = handlerCommand32Code008D_RM;
	commandFunctions[141 | 0x0200 ] = handlerCommand32Code008DP67_RM;
	commandFunctions[141 | 0x0400] = handlerCommand32Code008DP66_RM;
	commandFunctions[141 | 0x0200 | 0x0400] = handlerCommand32Code008DP66P67_RM;
	commandFunctions[143] = handlerCommand32Code008F_RM;
	commandFunctions[143 | 0x0200 ] = handlerCommand32Code008FP67_RM;
	commandFunctions[143 | 0x0400] = handlerCommand32Code008FP66_RM;
	commandFunctions[143 | 0x0200 | 0x0400] = handlerCommand32Code008FP66P67_RM;
	commandFunctions[144] = handlerCommand32Code0090_RM;
	commandFunctions[144 | 0x0400] = handlerCommand32Code0090P66_RM;
	commandFunctions[145] = handlerCommand32Code0091_RM;
	commandFunctions[145 | 0x0400] = handlerCommand32Code0091P66_RM;
	commandFunctions[146] = handlerCommand32Code0092_RM;
	commandFunctions[146 | 0x0400] = handlerCommand32Code0092P66_RM;
	commandFunctions[147] = handlerCommand32Code0093_RM;
	commandFunctions[147 | 0x0400] = handlerCommand32Code0093P66_RM;
	commandFunctions[148] = handlerCommand32Code0094_RM;
	commandFunctions[148 | 0x0400] = handlerCommand32Code0094P66_RM;
	commandFunctions[149] = handlerCommand32Code0095_RM;
	commandFunctions[149 | 0x0400] = handlerCommand32Code0095P66_RM;
	commandFunctions[150] = handlerCommand32Code0096_RM;
	commandFunctions[150 | 0x0400] = handlerCommand32Code0096P66_RM;
	commandFunctions[151] = handlerCommand32Code0097_RM;
	commandFunctions[151 | 0x0400] = handlerCommand32Code0097P66_RM;
	commandFunctions[152] = handlerCommand32Code0098_RM;
	commandFunctions[152 | 0x0400] = handlerCommand32Code0098P66_RM;
	commandFunctions[153] = handlerCommand32Code0099_RM;
	commandFunctions[153 | 0x0400] = handlerCommand32Code0099P66_RM;
	commandFunctions[154] = handlerCommand32Code009A_RM;
	commandFunctions[156] = handlerCommand32Code009C_RM;
	commandFunctions[156 | 0x0400] = handlerCommand32Code009CP66_RM;
	commandFunctions[157] = handlerCommand32Code009D_RM;
	commandFunctions[157 | 0x0400] = handlerCommand32Code009DP66_RM;
	commandFunctions[160] = handlerCommand32Code00A0_RM;
	commandFunctions[160 | 0x0200 ] = handlerCommand32Code00A0P67_RM;
	commandFunctions[160 | 0x0400] = handlerCommand32Code00A0P66_RM;
	commandFunctions[160 | 0x0200 | 0x0400] = handlerCommand32Code00A0P66P67_RM;
	commandFunctions[161] = handlerCommand32Code00A1_RM;
	commandFunctions[161 | 0x0200 ] = handlerCommand32Code00A1P67_RM;
	commandFunctions[161 | 0x0400] = handlerCommand32Code00A1P66_RM;
	commandFunctions[161 | 0x0200 | 0x0400] = handlerCommand32Code00A1P66P67_RM;
	commandFunctions[162] = handlerCommand32Code00A2_RM;
	commandFunctions[162 | 0x0200 ] = handlerCommand32Code00A2P67_RM;
	commandFunctions[162 | 0x0400] = handlerCommand32Code00A2P66_RM;
	commandFunctions[162 | 0x0200 | 0x0400] = handlerCommand32Code00A2P66P67_RM;
	commandFunctions[163] = handlerCommand32Code00A3_RM;
	commandFunctions[163 | 0x0200 ] = handlerCommand32Code00A3P67_RM;
	commandFunctions[163 | 0x0400] = handlerCommand32Code00A3P66_RM;
	commandFunctions[163 | 0x0200 | 0x0400] = handlerCommand32Code00A3P66P67_RM;
	commandFunctions[164] = handlerCommand32Code00A4_RM;
	commandFunctions[164 | 0x0200 ] = handlerCommand32Code00A4P67_RM;
	commandFunctions[164 | 0x0400] = handlerCommand32Code00A4P66_RM;
	commandFunctions[164 | 0x0200 | 0x0400] = handlerCommand32Code00A4P66P67_RM;
	commandFunctions[165] = handlerCommand32Code00A5_RM;
	commandFunctions[165 | 0x0200 ] = handlerCommand32Code00A5P67_RM;
	commandFunctions[165 | 0x0400] = handlerCommand32Code00A5P66_RM;
	commandFunctions[165 | 0x0200 | 0x0400] = handlerCommand32Code00A5P66P67_RM;
	commandFunctions[166] = handlerCommand32Code00A6_RM;
	commandFunctions[166 | 0x0200 ] = handlerCommand32Code00A6P67_RM;
	commandFunctions[166 | 0x0400] = handlerCommand32Code00A6P66_RM;
	commandFunctions[166 | 0x0200 | 0x0400] = handlerCommand32Code00A6P66P67_RM;
	commandFunctions[167] = handlerCommand32Code00A7_RM;
	commandFunctions[167 | 0x0200 ] = handlerCommand32Code00A7P67_RM;
	commandFunctions[167 | 0x0400] = handlerCommand32Code00A7P66_RM;
	commandFunctions[167 | 0x0200 | 0x0400] = handlerCommand32Code00A7P66P67_RM;
	commandFunctions[168] = handlerCommand32Code00A8_RM;
	commandFunctions[168 | 0x0400] = handlerCommand32Code00A8P66_RM;
	commandFunctions[169] = handlerCommand32Code00A9_RM;
	commandFunctions[169 | 0x0400] = handlerCommand32Code00A9P66_RM;
	commandFunctions[170] = handlerCommand32Code00AA_RM;
	commandFunctions[170 | 0x0200 ] = handlerCommand32Code00AAP67_RM;
	commandFunctions[170 | 0x0400] = handlerCommand32Code00AAP66_RM;
	commandFunctions[170 | 0x0200 | 0x0400] = handlerCommand32Code00AAP66P67_RM;
	commandFunctions[171] = handlerCommand32Code00AB_RM;
	commandFunctions[171 | 0x0200 ] = handlerCommand32Code00ABP67_RM;
	commandFunctions[171 | 0x0400] = handlerCommand32Code00ABP66_RM;
	commandFunctions[171 | 0x0200 | 0x0400] = handlerCommand32Code00ABP66P67_RM;
	commandFunctions[172] = handlerCommand32Code00AC_RM;
	commandFunctions[172 | 0x0200 ] = handlerCommand32Code00ACP67_RM;
	commandFunctions[172 | 0x0400] = handlerCommand32Code00ACP66_RM;
	commandFunctions[172 | 0x0200 | 0x0400] = handlerCommand32Code00ACP66P67_RM;
	commandFunctions[173] = handlerCommand32Code00AD_RM;
	commandFunctions[173 | 0x0200 ] = handlerCommand32Code00ADP67_RM;
	commandFunctions[173 | 0x0400] = handlerCommand32Code00ADP66_RM;
	commandFunctions[173 | 0x0200 | 0x0400] = handlerCommand32Code00ADP66P67_RM;
	commandFunctions[174] = handlerCommand32Code00AE_RM;
	commandFunctions[174 | 0x0200 ] = handlerCommand32Code00AEP67_RM;
	commandFunctions[174 | 0x0400] = handlerCommand32Code00AEP66_RM;
	commandFunctions[174 | 0x0200 | 0x0400] = handlerCommand32Code00AEP66P67_RM;
	commandFunctions[175] = handlerCommand32Code00AF_RM;
	commandFunctions[175 | 0x0200 ] = handlerCommand32Code00AFP67_RM;
	commandFunctions[175 | 0x0400] = handlerCommand32Code00AFP66_RM;
	commandFunctions[175 | 0x0200 | 0x0400] = handlerCommand32Code00AFP66P67_RM;
	commandFunctions[176] = handlerCommand32Code00B0_RM;
	commandFunctions[176 | 0x0400] = handlerCommand32Code00B0P66_RM;
	commandFunctions[177] = handlerCommand32Code00B1_RM;
	commandFunctions[177 | 0x0400] = handlerCommand32Code00B1P66_RM;
	commandFunctions[178] = handlerCommand32Code00B2_RM;
	commandFunctions[178 | 0x0400] = handlerCommand32Code00B2P66_RM;
	commandFunctions[179] = handlerCommand32Code00B3_RM;
	commandFunctions[179 | 0x0400] = handlerCommand32Code00B3P66_RM;
	commandFunctions[180] = handlerCommand32Code00B4_RM;
	commandFunctions[180 | 0x0400] = handlerCommand32Code00B4P66_RM;
	commandFunctions[181] = handlerCommand32Code00B5_RM;
	commandFunctions[181 | 0x0400] = handlerCommand32Code00B5P66_RM;
	commandFunctions[182] = handlerCommand32Code00B6_RM;
	commandFunctions[182 | 0x0400] = handlerCommand32Code00B6P66_RM;
	commandFunctions[183] = handlerCommand32Code00B7_RM;
	commandFunctions[183 | 0x0400] = handlerCommand32Code00B7P66_RM;
	commandFunctions[184] = handlerCommand32Code00B8_RM;
	commandFunctions[184 | 0x0400] = handlerCommand32Code00B8P66_RM;
	commandFunctions[185] = handlerCommand32Code00B9_RM;
	commandFunctions[185 | 0x0400] = handlerCommand32Code00B9P66_RM;
	commandFunctions[186] = handlerCommand32Code00BA_RM;
	commandFunctions[186 | 0x0400] = handlerCommand32Code00BAP66_RM;
	commandFunctions[187] = handlerCommand32Code00BB_RM;
	commandFunctions[187 | 0x0400] = handlerCommand32Code00BBP66_RM;
	commandFunctions[188] = handlerCommand32Code00BC_RM;
	commandFunctions[188 | 0x0400] = handlerCommand32Code00BCP66_RM;
	commandFunctions[189] = handlerCommand32Code00BD_RM;
	commandFunctions[189 | 0x0400] = handlerCommand32Code00BDP66_RM;
	commandFunctions[190] = handlerCommand32Code00BE_RM;
	commandFunctions[190 | 0x0400] = handlerCommand32Code00BEP66_RM;
	commandFunctions[191] = handlerCommand32Code00BF_RM;
	commandFunctions[191 | 0x0400] = handlerCommand32Code00BFP66_RM;
	commandFunctions[192] = handlerCommand32Code00C0_RM;
	commandFunctions[192 | 0x0400] = handlerCommand32Code00C0P66_RM;
	commandFunctions[193] = handlerCommand32Code00C1_RM;
	commandFunctions[193 | 0x0400] = handlerCommand32Code00C1P66_RM;
	commandFunctions[194] = handlerCommand32Code00C2_RM;
	commandFunctions[195] = handlerCommand32Code00C3_RM;
	commandFunctions[196] = handlerCommand32Code00C4_RM;
	commandFunctions[197] = handlerCommand32Code00C5_RM;
	commandFunctions[198] = handlerCommand32Code00C6_RM;
	commandFunctions[198 | 0x0400] = handlerCommand32Code00C6P66_RM;
	commandFunctions[199] = handlerCommand32Code00C7_RM;
	commandFunctions[199 | 0x0400] = handlerCommand32Code00C7P66_RM;
	commandFunctions[200] = handlerCommand32Code00C8_RM;
	commandFunctions[200 | 0x0200 ] = handlerCommand32Code00C8P67_RM;
	commandFunctions[200 | 0x0400] = handlerCommand32Code00C8P66_RM;
	commandFunctions[200 | 0x0200 | 0x0400] = handlerCommand32Code00C8P66P67_RM;
	commandFunctions[201] = handlerCommand32Code00C9_RM;
	commandFunctions[201 | 0x0200 ] = handlerCommand32Code00C9P67_RM;
	commandFunctions[201 | 0x0400] = handlerCommand32Code00C9P66_RM;
	commandFunctions[201 | 0x0200 | 0x0400] = handlerCommand32Code00C9P66P67_RM;
	commandFunctions[202] = handlerCommand32Code00CA_RM;
	commandFunctions[203] = handlerCommand32Code00CB_RM;
	commandFunctions[205] = handlerCommand32Code00CD_RM;
	commandFunctions[208] = handlerCommand32Code00D0_RM;
	commandFunctions[208 | 0x0400] = handlerCommand32Code00D0P66_RM;
	commandFunctions[209] = handlerCommand32Code00D1_RM;
	commandFunctions[209 | 0x0400] = handlerCommand32Code00D1P66_RM;
	commandFunctions[210] = handlerCommand32Code00D2_RM;
	commandFunctions[210 | 0x0400] = handlerCommand32Code00D2P66_RM;
	commandFunctions[211] = handlerCommand32Code00D3_RM;
	commandFunctions[211 | 0x0400] = handlerCommand32Code00D3P66_RM;
	commandFunctions[216] = handlerCommand32Code00D8_RM;
	commandFunctions[217] = handlerCommand32Code00D9_RM;
	commandFunctions[218] = handlerCommand32Code00DA_RM;
	commandFunctions[219] = handlerCommand32Code00DB_RM;
	commandFunctions[220] = handlerCommand32Code00DC_RM;
	commandFunctions[221] = handlerCommand32Code00DD_RM;
	commandFunctions[222] = handlerCommand32Code00DE_RM;
	commandFunctions[223] = handlerCommand32Code00DF_RM;
	commandFunctions[224] = handlerCommand32Code00E0_RM;
	commandFunctions[225] = handlerCommand32Code00E1_RM;
	commandFunctions[226] = handlerCommand32Code00E2_RM;
	commandFunctions[227] = handlerCommand32Code00E3_RM;
	commandFunctions[228] = handlerCommand32Code00E4_RM;
	commandFunctions[228 | 0x0400] = handlerCommand32Code00E4P66_RM;
	commandFunctions[229] = handlerCommand32Code00E5_RM;
	commandFunctions[229 | 0x0400] = handlerCommand32Code00E5P66_RM;
	commandFunctions[230] = handlerCommand32Code00E6_RM;
	commandFunctions[230 | 0x0400] = handlerCommand32Code00E6P66_RM;
	commandFunctions[231] = handlerCommand32Code00E7_RM;
	commandFunctions[231 | 0x0400] = handlerCommand32Code00E7P66_RM;
	commandFunctions[232] = handlerCommand32Code00E8_RM;
	commandFunctions[232 | 0x0400] = handlerCommand32Code00E8P66_RM;
	commandFunctions[233] = handlerCommand32Code00E9_RM;
	commandFunctions[233 | 0x0400] = handlerCommand32Code00E9P66_RM;
	commandFunctions[235] = handlerCommand32Code00EB_RM;
	commandFunctions[236] = handlerCommand32Code00EC_RM;
	commandFunctions[236 | 0x0400] = handlerCommand32Code00ECP66_RM;
	commandFunctions[237] = handlerCommand32Code00ED_RM;
	commandFunctions[237 | 0x0400] = handlerCommand32Code00EDP66_RM;
	commandFunctions[238] = handlerCommand32Code00EE_RM;
	commandFunctions[238 | 0x0400] = handlerCommand32Code00EEP66_RM;
	commandFunctions[239] = handlerCommand32Code00EF_RM;
	commandFunctions[239 | 0x0400] = handlerCommand32Code00EFP66_RM;
	commandFunctions[241] = handlerCommand32Code00F1_RM;
	commandFunctions[245] = handlerCommand32Code00F5_RM;
	commandFunctions[246] = handlerCommand32Code00F6_RM;
	commandFunctions[246 | 0x0400] = handlerCommand32Code00F6P66_RM;
	commandFunctions[247] = handlerCommand32Code00F7_RM;
	commandFunctions[247 | 0x0400] = handlerCommand32Code00F7P66_RM;
	commandFunctions[248] = handlerCommand32Code00F8_RM;
	commandFunctions[249] = handlerCommand32Code00F9_RM;
	commandFunctions[250] = handlerCommand32Code00FA_RM;
	commandFunctions[251] = handlerCommand32Code00FB_RM;
	commandFunctions[252] = handlerCommand32Code00FC_RM;
	commandFunctions[253] = handlerCommand32Code00FD_RM;
	commandFunctions[254] = handlerCommand32Code00FE_RM;
	commandFunctions[255] = handlerCommand32Code00FF_RM;
	commandFunctions[255 | 0x0200 ] = handlerCommand32Code00FFP67_RM;
	commandFunctions[255 | 0x0400] = handlerCommand32Code00FFP66_RM;
	commandFunctions[255 | 0x0200 | 0x0400] = handlerCommand32Code00FFP66P67_RM;
	commandFunctions[257] = handlerCommand32Code0101_RM;
	commandFunctions[384] = handlerCommand32Code0180_RM;
	commandFunctions[385] = handlerCommand32Code0181_RM;
	commandFunctions[386] = handlerCommand32Code0182_RM;
	commandFunctions[387] = handlerCommand32Code0183_RM;
	commandFunctions[388] = handlerCommand32Code0184_RM;
	commandFunctions[389] = handlerCommand32Code0185_RM;
	commandFunctions[390] = handlerCommand32Code0186_RM;
	commandFunctions[391] = handlerCommand32Code0187_RM;
	commandFunctions[392] = handlerCommand32Code0188_RM;
	commandFunctions[393] = handlerCommand32Code0189_RM;
	commandFunctions[394] = handlerCommand32Code018A_RM;
	commandFunctions[395] = handlerCommand32Code018B_RM;
	commandFunctions[396] = handlerCommand32Code018C_RM;
	commandFunctions[397] = handlerCommand32Code018D_RM;
	commandFunctions[398] = handlerCommand32Code018E_RM;
	commandFunctions[399] = handlerCommand32Code018F_RM;
	commandFunctions[400] = handlerCommand32Code0190_RM;
	commandFunctions[400 | 0x0400] = handlerCommand32Code0190P66_RM;
	commandFunctions[401] = handlerCommand32Code0191_RM;
	commandFunctions[401 | 0x0400] = handlerCommand32Code0191P66_RM;
	commandFunctions[402] = handlerCommand32Code0192_RM;
	commandFunctions[402 | 0x0400] = handlerCommand32Code0192P66_RM;
	commandFunctions[403] = handlerCommand32Code0193_RM;
	commandFunctions[403 | 0x0400] = handlerCommand32Code0193P66_RM;
	commandFunctions[404] = handlerCommand32Code0194_RM;
	commandFunctions[404 | 0x0400] = handlerCommand32Code0194P66_RM;
	commandFunctions[405] = handlerCommand32Code0195_RM;
	commandFunctions[405 | 0x0400] = handlerCommand32Code0195P66_RM;
	commandFunctions[406] = handlerCommand32Code0196_RM;
	commandFunctions[406 | 0x0400] = handlerCommand32Code0196P66_RM;
	commandFunctions[407] = handlerCommand32Code0197_RM;
	commandFunctions[407 | 0x0400] = handlerCommand32Code0197P66_RM;
	commandFunctions[408] = handlerCommand32Code0198_RM;
	commandFunctions[408 | 0x0400] = handlerCommand32Code0198P66_RM;
	commandFunctions[409] = handlerCommand32Code0199_RM;
	commandFunctions[409 | 0x0400] = handlerCommand32Code0199P66_RM;
	commandFunctions[410] = handlerCommand32Code019A_RM;
	commandFunctions[410 | 0x0400] = handlerCommand32Code019AP66_RM;
	commandFunctions[411] = handlerCommand32Code019B_RM;
	commandFunctions[411 | 0x0400] = handlerCommand32Code019BP66_RM;
	commandFunctions[412] = handlerCommand32Code019C_RM;
	commandFunctions[412 | 0x0400] = handlerCommand32Code019CP66_RM;
	commandFunctions[413] = handlerCommand32Code019D_RM;
	commandFunctions[413 | 0x0400] = handlerCommand32Code019DP66_RM;
	commandFunctions[414] = handlerCommand32Code019E_RM;
	commandFunctions[414 | 0x0400] = handlerCommand32Code019EP66_RM;
	commandFunctions[415] = handlerCommand32Code019F_RM;
	commandFunctions[415 | 0x0400] = handlerCommand32Code019FP66_RM;
	commandFunctions[419] = handlerCommand32Code01A3_RM;
	commandFunctions[419 | 0x0400] = handlerCommand32Code01A3P66_RM;
	commandFunctions[427] = handlerCommand32Code01AB_RM;
	commandFunctions[427 | 0x0400] = handlerCommand32Code01ABP66_RM;
	commandFunctions[431] = handlerCommand32Code01AF_RM;
	commandFunctions[431 | 0x0400] = handlerCommand32Code01AFP66_RM;
	commandFunctions[434] = handlerCommand32Code01B2_RM;
	commandFunctions[435] = handlerCommand32Code01B3_RM;
	commandFunctions[435 | 0x0400] = handlerCommand32Code01B3P66_RM;
	commandFunctions[436] = handlerCommand32Code01B4_RM;
	commandFunctions[437] = handlerCommand32Code01B5_RM;
	commandFunctions[438] = handlerCommand32Code01B6_RM;
	commandFunctions[439] = handlerCommand32Code01B7_RM;
	commandFunctions[439 | 0x0400] = handlerCommand32Code01B7P66_RM;
	commandFunctions[442] = handlerCommand32Code01BA_RM;
	commandFunctions[442 | 0x0400] = handlerCommand32Code01BAP66_RM;
	commandFunctions[443] = handlerCommand32Code01BB_RM;
	commandFunctions[443 | 0x0400] = handlerCommand32Code01BBP66_RM;
	commandFunctions[444] = handlerCommand32Code01BC_RM;
	commandFunctions[444 | 0x0400] = handlerCommand32Code01BCP66_RM;
	commandFunctions[445] = handlerCommand32Code01BD_RM;
	commandFunctions[445 | 0x0400] = handlerCommand32Code01BDP66_RM;
	commandFunctions[446] = handlerCommand32Code01BE_RM;
	commandFunctions[447] = handlerCommand32Code01BF_RM;
	commandFunctions[456] = handlerCommand32Code01C8_RM;
	commandFunctions[457] = handlerCommand32Code01C9_RM;
	commandFunctions[458] = handlerCommand32Code01CA_RM;
	commandFunctions[459] = handlerCommand32Code01CB_RM;
	commandFunctions[460] = handlerCommand32Code01CC_RM;
	commandFunctions[461] = handlerCommand32Code01CD_RM;
	commandFunctions[462] = handlerCommand32Code01CE_RM;
	commandFunctions[463] = handlerCommand32Code01CF_RM;
}
void installCommandFunction16PM() {
	for(int i = 0; i < 256 * 8; i++) {
		commandFunctions[i] = mCommandFunctionEmpty;
	}
	commandFunctions[0] = handlerCommand16Code0000_PM;
	commandFunctions[0 | 0x0400] = handlerCommand16Code0000P66_PM;
	commandFunctions[1] = handlerCommand16Code0001_PM;
	commandFunctions[1 | 0x0400] = handlerCommand16Code0001P66_PM;
	commandFunctions[2] = handlerCommand16Code0002_PM;
	commandFunctions[2 | 0x0400] = handlerCommand16Code0002P66_PM;
	commandFunctions[3] = handlerCommand16Code0003_PM;
	commandFunctions[3 | 0x0400] = handlerCommand16Code0003P66_PM;
	commandFunctions[4] = handlerCommand16Code0004_PM;
	commandFunctions[4 | 0x0400] = handlerCommand16Code0004P66_PM;
	commandFunctions[5] = handlerCommand16Code0005_PM;
	commandFunctions[5 | 0x0400] = handlerCommand16Code0005P66_PM;
	commandFunctions[6] = handlerCommand16Code0006_PM;
	commandFunctions[14] = handlerCommand16Code000E_PM;
	commandFunctions[22] = handlerCommand16Code0016_PM;
	commandFunctions[30] = handlerCommand16Code001E_PM;
	commandFunctions[7] = handlerCommand16Code0007_PM;
	commandFunctions[15] = handlerCommand16Code000F_PM;
	commandFunctions[23] = handlerCommand16Code0017_PM;
	commandFunctions[31] = handlerCommand16Code001F_PM;
	commandFunctions[8] = handlerCommand16Code0008_PM;
	commandFunctions[8 | 0x0400] = handlerCommand16Code0008P66_PM;
	commandFunctions[9] = handlerCommand16Code0009_PM;
	commandFunctions[9 | 0x0400] = handlerCommand16Code0009P66_PM;
	commandFunctions[10] = handlerCommand16Code000A_PM;
	commandFunctions[10 | 0x0400] = handlerCommand16Code000AP66_PM;
	commandFunctions[11] = handlerCommand16Code000B_PM;
	commandFunctions[11 | 0x0400] = handlerCommand16Code000BP66_PM;
	commandFunctions[12] = handlerCommand16Code000C_PM;
	commandFunctions[12 | 0x0400] = handlerCommand16Code000CP66_PM;
	commandFunctions[13] = handlerCommand16Code000D_PM;
	commandFunctions[13 | 0x0400] = handlerCommand16Code000DP66_PM;
	commandFunctions[16] = handlerCommand16Code0010_PM;
	commandFunctions[16 | 0x0400] = handlerCommand16Code0010P66_PM;
	commandFunctions[17] = handlerCommand16Code0011_PM;
	commandFunctions[17 | 0x0400] = handlerCommand16Code0011P66_PM;
	commandFunctions[18] = handlerCommand16Code0012_PM;
	commandFunctions[18 | 0x0400] = handlerCommand16Code0012P66_PM;
	commandFunctions[19] = handlerCommand16Code0013_PM;
	commandFunctions[19 | 0x0400] = handlerCommand16Code0013P66_PM;
	commandFunctions[20] = handlerCommand16Code0014_PM;
	commandFunctions[20 | 0x0400] = handlerCommand16Code0014P66_PM;
	commandFunctions[21] = handlerCommand16Code0015_PM;
	commandFunctions[21 | 0x0400] = handlerCommand16Code0015P66_PM;
	commandFunctions[24] = handlerCommand16Code0018_PM;
	commandFunctions[24 | 0x0400] = handlerCommand16Code0018P66_PM;
	commandFunctions[25] = handlerCommand16Code0019_PM;
	commandFunctions[25 | 0x0400] = handlerCommand16Code0019P66_PM;
	commandFunctions[26] = handlerCommand16Code001A_PM;
	commandFunctions[26 | 0x0400] = handlerCommand16Code001AP66_PM;
	commandFunctions[27] = handlerCommand16Code001B_PM;
	commandFunctions[27 | 0x0400] = handlerCommand16Code001BP66_PM;
	commandFunctions[28] = handlerCommand16Code001C_PM;
	commandFunctions[28 | 0x0400] = handlerCommand16Code001CP66_PM;
	commandFunctions[29] = handlerCommand16Code001D_PM;
	commandFunctions[29 | 0x0400] = handlerCommand16Code001DP66_PM;
	commandFunctions[32] = handlerCommand16Code0020_PM;
	commandFunctions[32 | 0x0400] = handlerCommand16Code0020P66_PM;
	commandFunctions[33] = handlerCommand16Code0021_PM;
	commandFunctions[33 | 0x0400] = handlerCommand16Code0021P66_PM;
	commandFunctions[34] = handlerCommand16Code0022_PM;
	commandFunctions[34 | 0x0400] = handlerCommand16Code0022P66_PM;
	commandFunctions[35] = handlerCommand16Code0023_PM;
	commandFunctions[35 | 0x0400] = handlerCommand16Code0023P66_PM;
	commandFunctions[36] = handlerCommand16Code0024_PM;
	commandFunctions[36 | 0x0400] = handlerCommand16Code0024P66_PM;
	commandFunctions[37] = handlerCommand16Code0025_PM;
	commandFunctions[37 | 0x0400] = handlerCommand16Code0025P66_PM;
	commandFunctions[40] = handlerCommand16Code0028_PM;
	commandFunctions[40 | 0x0400] = handlerCommand16Code0028P66_PM;
	commandFunctions[41] = handlerCommand16Code0029_PM;
	commandFunctions[41 | 0x0400] = handlerCommand16Code0029P66_PM;
	commandFunctions[42] = handlerCommand16Code002A_PM;
	commandFunctions[42 | 0x0400] = handlerCommand16Code002AP66_PM;
	commandFunctions[43] = handlerCommand16Code002B_PM;
	commandFunctions[43 | 0x0400] = handlerCommand16Code002BP66_PM;
	commandFunctions[44] = handlerCommand16Code002C_PM;
	commandFunctions[44 | 0x0400] = handlerCommand16Code002CP66_PM;
	commandFunctions[45] = handlerCommand16Code002D_PM;
	commandFunctions[45 | 0x0400] = handlerCommand16Code002DP66_PM;
	commandFunctions[48] = handlerCommand16Code0030_PM;
	commandFunctions[48 | 0x0400] = handlerCommand16Code0030P66_PM;
	commandFunctions[49] = handlerCommand16Code0031_PM;
	commandFunctions[49 | 0x0400] = handlerCommand16Code0031P66_PM;
	commandFunctions[50] = handlerCommand16Code0032_PM;
	commandFunctions[50 | 0x0400] = handlerCommand16Code0032P66_PM;
	commandFunctions[51] = handlerCommand16Code0033_PM;
	commandFunctions[51 | 0x0400] = handlerCommand16Code0033P66_PM;
	commandFunctions[52] = handlerCommand16Code0034_PM;
	commandFunctions[52 | 0x0400] = handlerCommand16Code0034P66_PM;
	commandFunctions[53] = handlerCommand16Code0035_PM;
	commandFunctions[53 | 0x0400] = handlerCommand16Code0035P66_PM;
	commandFunctions[56] = handlerCommand16Code0038_PM;
	commandFunctions[56 | 0x0400] = handlerCommand16Code0038P66_PM;
	commandFunctions[57] = handlerCommand16Code0039_PM;
	commandFunctions[57 | 0x0400] = handlerCommand16Code0039P66_PM;
	commandFunctions[58] = handlerCommand16Code003A_PM;
	commandFunctions[58 | 0x0400] = handlerCommand16Code003AP66_PM;
	commandFunctions[59] = handlerCommand16Code003B_PM;
	commandFunctions[59 | 0x0400] = handlerCommand16Code003BP66_PM;
	commandFunctions[60] = handlerCommand16Code003C_PM;
	commandFunctions[60 | 0x0400] = handlerCommand16Code003CP66_PM;
	commandFunctions[61] = handlerCommand16Code003D_PM;
	commandFunctions[61 | 0x0400] = handlerCommand16Code003DP66_PM;
	commandFunctions[64] = handlerCommand16Code0040_PM;
	commandFunctions[64 | 0x0400] = handlerCommand16Code0040P66_PM;
	commandFunctions[65] = handlerCommand16Code0041_PM;
	commandFunctions[65 | 0x0400] = handlerCommand16Code0041P66_PM;
	commandFunctions[66] = handlerCommand16Code0042_PM;
	commandFunctions[66 | 0x0400] = handlerCommand16Code0042P66_PM;
	commandFunctions[67] = handlerCommand16Code0043_PM;
	commandFunctions[67 | 0x0400] = handlerCommand16Code0043P66_PM;
	commandFunctions[68] = handlerCommand16Code0044_PM;
	commandFunctions[68 | 0x0400] = handlerCommand16Code0044P66_PM;
	commandFunctions[69] = handlerCommand16Code0045_PM;
	commandFunctions[69 | 0x0400] = handlerCommand16Code0045P66_PM;
	commandFunctions[70] = handlerCommand16Code0046_PM;
	commandFunctions[70 | 0x0400] = handlerCommand16Code0046P66_PM;
	commandFunctions[71] = handlerCommand16Code0047_PM;
	commandFunctions[71 | 0x0400] = handlerCommand16Code0047P66_PM;
	commandFunctions[72] = handlerCommand16Code0048_PM;
	commandFunctions[72 | 0x0400] = handlerCommand16Code0048P66_PM;
	commandFunctions[73] = handlerCommand16Code0049_PM;
	commandFunctions[73 | 0x0400] = handlerCommand16Code0049P66_PM;
	commandFunctions[74] = handlerCommand16Code004A_PM;
	commandFunctions[74 | 0x0400] = handlerCommand16Code004AP66_PM;
	commandFunctions[75] = handlerCommand16Code004B_PM;
	commandFunctions[75 | 0x0400] = handlerCommand16Code004BP66_PM;
	commandFunctions[76] = handlerCommand16Code004C_PM;
	commandFunctions[76 | 0x0400] = handlerCommand16Code004CP66_PM;
	commandFunctions[77] = handlerCommand16Code004D_PM;
	commandFunctions[77 | 0x0400] = handlerCommand16Code004DP66_PM;
	commandFunctions[78] = handlerCommand16Code004E_PM;
	commandFunctions[78 | 0x0400] = handlerCommand16Code004EP66_PM;
	commandFunctions[79] = handlerCommand16Code004F_PM;
	commandFunctions[79 | 0x0400] = handlerCommand16Code004FP66_PM;
	commandFunctions[80] = handlerCommand16Code0050_PM;
	commandFunctions[80 | 0x0200 ] = handlerCommand16Code0050P67_PM;
	commandFunctions[80 | 0x0400] = handlerCommand16Code0050P66_PM;
	commandFunctions[80 | 0x0200 | 0x0400] = handlerCommand16Code0050P66P67_PM;
	commandFunctions[81] = handlerCommand16Code0051_PM;
	commandFunctions[81 | 0x0200 ] = handlerCommand16Code0051P67_PM;
	commandFunctions[81 | 0x0400] = handlerCommand16Code0051P66_PM;
	commandFunctions[81 | 0x0200 | 0x0400] = handlerCommand16Code0051P66P67_PM;
	commandFunctions[82] = handlerCommand16Code0052_PM;
	commandFunctions[82 | 0x0200 ] = handlerCommand16Code0052P67_PM;
	commandFunctions[82 | 0x0400] = handlerCommand16Code0052P66_PM;
	commandFunctions[82 | 0x0200 | 0x0400] = handlerCommand16Code0052P66P67_PM;
	commandFunctions[83] = handlerCommand16Code0053_PM;
	commandFunctions[83 | 0x0200 ] = handlerCommand16Code0053P67_PM;
	commandFunctions[83 | 0x0400] = handlerCommand16Code0053P66_PM;
	commandFunctions[83 | 0x0200 | 0x0400] = handlerCommand16Code0053P66P67_PM;
	commandFunctions[84] = handlerCommand16Code0054_PM;
	commandFunctions[84 | 0x0200 ] = handlerCommand16Code0054P67_PM;
	commandFunctions[84 | 0x0400] = handlerCommand16Code0054P66_PM;
	commandFunctions[84 | 0x0200 | 0x0400] = handlerCommand16Code0054P66P67_PM;
	commandFunctions[85] = handlerCommand16Code0055_PM;
	commandFunctions[85 | 0x0200 ] = handlerCommand16Code0055P67_PM;
	commandFunctions[85 | 0x0400] = handlerCommand16Code0055P66_PM;
	commandFunctions[85 | 0x0200 | 0x0400] = handlerCommand16Code0055P66P67_PM;
	commandFunctions[86] = handlerCommand16Code0056_PM;
	commandFunctions[86 | 0x0200 ] = handlerCommand16Code0056P67_PM;
	commandFunctions[86 | 0x0400] = handlerCommand16Code0056P66_PM;
	commandFunctions[86 | 0x0200 | 0x0400] = handlerCommand16Code0056P66P67_PM;
	commandFunctions[87] = handlerCommand16Code0057_PM;
	commandFunctions[87 | 0x0200 ] = handlerCommand16Code0057P67_PM;
	commandFunctions[87 | 0x0400] = handlerCommand16Code0057P66_PM;
	commandFunctions[87 | 0x0200 | 0x0400] = handlerCommand16Code0057P66P67_PM;
	commandFunctions[88] = handlerCommand16Code0058_PM;
	commandFunctions[88 | 0x0200 ] = handlerCommand16Code0058P67_PM;
	commandFunctions[88 | 0x0400] = handlerCommand16Code0058P66_PM;
	commandFunctions[88 | 0x0200 | 0x0400] = handlerCommand16Code0058P66P67_PM;
	commandFunctions[89] = handlerCommand16Code0059_PM;
	commandFunctions[89 | 0x0200 ] = handlerCommand16Code0059P67_PM;
	commandFunctions[89 | 0x0400] = handlerCommand16Code0059P66_PM;
	commandFunctions[89 | 0x0200 | 0x0400] = handlerCommand16Code0059P66P67_PM;
	commandFunctions[90] = handlerCommand16Code005A_PM;
	commandFunctions[90 | 0x0200 ] = handlerCommand16Code005AP67_PM;
	commandFunctions[90 | 0x0400] = handlerCommand16Code005AP66_PM;
	commandFunctions[90 | 0x0200 | 0x0400] = handlerCommand16Code005AP66P67_PM;
	commandFunctions[91] = handlerCommand16Code005B_PM;
	commandFunctions[91 | 0x0200 ] = handlerCommand16Code005BP67_PM;
	commandFunctions[91 | 0x0400] = handlerCommand16Code005BP66_PM;
	commandFunctions[91 | 0x0200 | 0x0400] = handlerCommand16Code005BP66P67_PM;
	commandFunctions[92] = handlerCommand16Code005C_PM;
	commandFunctions[92 | 0x0200 ] = handlerCommand16Code005CP67_PM;
	commandFunctions[92 | 0x0400] = handlerCommand16Code005CP66_PM;
	commandFunctions[92 | 0x0200 | 0x0400] = handlerCommand16Code005CP66P67_PM;
	commandFunctions[93] = handlerCommand16Code005D_PM;
	commandFunctions[93 | 0x0200 ] = handlerCommand16Code005DP67_PM;
	commandFunctions[93 | 0x0400] = handlerCommand16Code005DP66_PM;
	commandFunctions[93 | 0x0200 | 0x0400] = handlerCommand16Code005DP66P67_PM;
	commandFunctions[94] = handlerCommand16Code005E_PM;
	commandFunctions[94 | 0x0200 ] = handlerCommand16Code005EP67_PM;
	commandFunctions[94 | 0x0400] = handlerCommand16Code005EP66_PM;
	commandFunctions[94 | 0x0200 | 0x0400] = handlerCommand16Code005EP66P67_PM;
	commandFunctions[95] = handlerCommand16Code005F_PM;
	commandFunctions[95 | 0x0200 ] = handlerCommand16Code005FP67_PM;
	commandFunctions[95 | 0x0400] = handlerCommand16Code005FP66_PM;
	commandFunctions[95 | 0x0200 | 0x0400] = handlerCommand16Code005FP66P67_PM;
	commandFunctions[96] = handlerCommand16Code0060_PM;
	commandFunctions[96 | 0x0400] = handlerCommand16Code0060P66_PM;
	commandFunctions[97] = handlerCommand16Code0061_PM;
	commandFunctions[97 | 0x0400] = handlerCommand16Code0061P66_PM;
	commandFunctions[104] = handlerCommand16Code0068_PM;
	commandFunctions[104 | 0x0200 ] = handlerCommand16Code0068P67_PM;
	commandFunctions[104 | 0x0400] = handlerCommand16Code0068P66_PM;
	commandFunctions[104 | 0x0200 | 0x0400] = handlerCommand16Code0068P66P67_PM;
	commandFunctions[105] = handlerCommand16Code0069_PM;
	commandFunctions[105 | 0x0400] = handlerCommand16Code0069P66_PM;
	commandFunctions[106] = handlerCommand16Code006A_PM;
	commandFunctions[106 | 0x0200 ] = handlerCommand16Code006AP67_PM;
	commandFunctions[106 | 0x0400] = handlerCommand16Code006AP66_PM;
	commandFunctions[106 | 0x0200 | 0x0400] = handlerCommand16Code006AP66P67_PM;
	commandFunctions[107] = handlerCommand16Code006B_PM;
	commandFunctions[112] = handlerCommand16Code0070_PM;
	commandFunctions[113] = handlerCommand16Code0071_PM;
	commandFunctions[114] = handlerCommand16Code0072_PM;
	commandFunctions[115] = handlerCommand16Code0073_PM;
	commandFunctions[116] = handlerCommand16Code0074_PM;
	commandFunctions[117] = handlerCommand16Code0075_PM;
	commandFunctions[118] = handlerCommand16Code0076_PM;
	commandFunctions[119] = handlerCommand16Code0077_PM;
	commandFunctions[120] = handlerCommand16Code0078_PM;
	commandFunctions[121] = handlerCommand16Code0079_PM;
	commandFunctions[122] = handlerCommand16Code007A_PM;
	commandFunctions[123] = handlerCommand16Code007B_PM;
	commandFunctions[124] = handlerCommand16Code007C_PM;
	commandFunctions[125] = handlerCommand16Code007D_PM;
	commandFunctions[126] = handlerCommand16Code007E_PM;
	commandFunctions[127] = handlerCommand16Code007F_PM;
	commandFunctions[128] = handlerCommand16Code0080_PM;
	commandFunctions[128 | 0x0400] = handlerCommand16Code0080P66_PM;
	commandFunctions[129] = handlerCommand16Code0081_PM;
	commandFunctions[129 | 0x0400] = handlerCommand16Code0081P66_PM;
	commandFunctions[130] = handlerCommand16Code0082_PM;
	commandFunctions[131] = handlerCommand16Code0083_PM;
	commandFunctions[132] = handlerCommand16Code0084_PM;
	commandFunctions[132 | 0x0400] = handlerCommand16Code0084P66_PM;
	commandFunctions[133] = handlerCommand16Code0085_PM;
	commandFunctions[133 | 0x0400] = handlerCommand16Code0085P66_PM;
	commandFunctions[134] = handlerCommand16Code0086_PM;
	commandFunctions[134 | 0x0400] = handlerCommand16Code0086P66_PM;
	commandFunctions[135] = handlerCommand16Code0087_PM;
	commandFunctions[135 | 0x0400] = handlerCommand16Code0087P66_PM;
	commandFunctions[136] = handlerCommand16Code0088_PM;
	commandFunctions[136 | 0x0400] = handlerCommand16Code0088P66_PM;
	commandFunctions[137] = handlerCommand16Code0089_PM;
	commandFunctions[137 | 0x0400] = handlerCommand16Code0089P66_PM;
	commandFunctions[138] = handlerCommand16Code008A_PM;
	commandFunctions[138 | 0x0400] = handlerCommand16Code008AP66_PM;
	commandFunctions[139] = handlerCommand16Code008B_PM;
	commandFunctions[139 | 0x0400] = handlerCommand16Code008BP66_PM;
	commandFunctions[140] = handlerCommand16Code008C_PM;
	commandFunctions[142] = handlerCommand16Code008E_PM;
	commandFunctions[141] = handlerCommand16Code008D_PM;
	commandFunctions[141 | 0x0200 ] = handlerCommand16Code008DP67_PM;
	commandFunctions[141 | 0x0400] = handlerCommand16Code008DP66_PM;
	commandFunctions[141 | 0x0200 | 0x0400] = handlerCommand16Code008DP66P67_PM;
	commandFunctions[143] = handlerCommand16Code008F_PM;
	commandFunctions[143 | 0x0200 ] = handlerCommand16Code008FP67_PM;
	commandFunctions[143 | 0x0400] = handlerCommand16Code008FP66_PM;
	commandFunctions[143 | 0x0200 | 0x0400] = handlerCommand16Code008FP66P67_PM;
	commandFunctions[144] = handlerCommand16Code0090_PM;
	commandFunctions[144 | 0x0400] = handlerCommand16Code0090P66_PM;
	commandFunctions[145] = handlerCommand16Code0091_PM;
	commandFunctions[145 | 0x0400] = handlerCommand16Code0091P66_PM;
	commandFunctions[146] = handlerCommand16Code0092_PM;
	commandFunctions[146 | 0x0400] = handlerCommand16Code0092P66_PM;
	commandFunctions[147] = handlerCommand16Code0093_PM;
	commandFunctions[147 | 0x0400] = handlerCommand16Code0093P66_PM;
	commandFunctions[148] = handlerCommand16Code0094_PM;
	commandFunctions[148 | 0x0400] = handlerCommand16Code0094P66_PM;
	commandFunctions[149] = handlerCommand16Code0095_PM;
	commandFunctions[149 | 0x0400] = handlerCommand16Code0095P66_PM;
	commandFunctions[150] = handlerCommand16Code0096_PM;
	commandFunctions[150 | 0x0400] = handlerCommand16Code0096P66_PM;
	commandFunctions[151] = handlerCommand16Code0097_PM;
	commandFunctions[151 | 0x0400] = handlerCommand16Code0097P66_PM;
	commandFunctions[152] = handlerCommand16Code0098_PM;
	commandFunctions[152 | 0x0400] = handlerCommand16Code0098P66_PM;
	commandFunctions[153] = handlerCommand16Code0099_PM;
	commandFunctions[153 | 0x0400] = handlerCommand16Code0099P66_PM;
	commandFunctions[154] = handlerCommand16Code009A_PM;
	commandFunctions[156] = handlerCommand16Code009C_PM;
	commandFunctions[156 | 0x0400] = handlerCommand16Code009CP66_PM;
	commandFunctions[157] = handlerCommand16Code009D_PM;
	commandFunctions[157 | 0x0400] = handlerCommand16Code009DP66_PM;
	commandFunctions[160] = handlerCommand16Code00A0_PM;
	commandFunctions[160 | 0x0200 ] = handlerCommand16Code00A0P67_PM;
	commandFunctions[160 | 0x0400] = handlerCommand16Code00A0P66_PM;
	commandFunctions[160 | 0x0200 | 0x0400] = handlerCommand16Code00A0P66P67_PM;
	commandFunctions[161] = handlerCommand16Code00A1_PM;
	commandFunctions[161 | 0x0200 ] = handlerCommand16Code00A1P67_PM;
	commandFunctions[161 | 0x0400] = handlerCommand16Code00A1P66_PM;
	commandFunctions[161 | 0x0200 | 0x0400] = handlerCommand16Code00A1P66P67_PM;
	commandFunctions[162] = handlerCommand16Code00A2_PM;
	commandFunctions[162 | 0x0200 ] = handlerCommand16Code00A2P67_PM;
	commandFunctions[162 | 0x0400] = handlerCommand16Code00A2P66_PM;
	commandFunctions[162 | 0x0200 | 0x0400] = handlerCommand16Code00A2P66P67_PM;
	commandFunctions[163] = handlerCommand16Code00A3_PM;
	commandFunctions[163 | 0x0200 ] = handlerCommand16Code00A3P67_PM;
	commandFunctions[163 | 0x0400] = handlerCommand16Code00A3P66_PM;
	commandFunctions[163 | 0x0200 | 0x0400] = handlerCommand16Code00A3P66P67_PM;
	commandFunctions[164] = handlerCommand16Code00A4_PM;
	commandFunctions[164 | 0x0200 ] = handlerCommand16Code00A4P67_PM;
	commandFunctions[164 | 0x0400] = handlerCommand16Code00A4P66_PM;
	commandFunctions[164 | 0x0200 | 0x0400] = handlerCommand16Code00A4P66P67_PM;
	commandFunctions[165] = handlerCommand16Code00A5_PM;
	commandFunctions[165 | 0x0200 ] = handlerCommand16Code00A5P67_PM;
	commandFunctions[165 | 0x0400] = handlerCommand16Code00A5P66_PM;
	commandFunctions[165 | 0x0200 | 0x0400] = handlerCommand16Code00A5P66P67_PM;
	commandFunctions[166] = handlerCommand16Code00A6_PM;
	commandFunctions[166 | 0x0200 ] = handlerCommand16Code00A6P67_PM;
	commandFunctions[166 | 0x0400] = handlerCommand16Code00A6P66_PM;
	commandFunctions[166 | 0x0200 | 0x0400] = handlerCommand16Code00A6P66P67_PM;
	commandFunctions[167] = handlerCommand16Code00A7_PM;
	commandFunctions[167 | 0x0200 ] = handlerCommand16Code00A7P67_PM;
	commandFunctions[167 | 0x0400] = handlerCommand16Code00A7P66_PM;
	commandFunctions[167 | 0x0200 | 0x0400] = handlerCommand16Code00A7P66P67_PM;
	commandFunctions[168] = handlerCommand16Code00A8_PM;
	commandFunctions[168 | 0x0400] = handlerCommand16Code00A8P66_PM;
	commandFunctions[169] = handlerCommand16Code00A9_PM;
	commandFunctions[169 | 0x0400] = handlerCommand16Code00A9P66_PM;
	commandFunctions[170] = handlerCommand16Code00AA_PM;
	commandFunctions[170 | 0x0200 ] = handlerCommand16Code00AAP67_PM;
	commandFunctions[170 | 0x0400] = handlerCommand16Code00AAP66_PM;
	commandFunctions[170 | 0x0200 | 0x0400] = handlerCommand16Code00AAP66P67_PM;
	commandFunctions[171] = handlerCommand16Code00AB_PM;
	commandFunctions[171 | 0x0200 ] = handlerCommand16Code00ABP67_PM;
	commandFunctions[171 | 0x0400] = handlerCommand16Code00ABP66_PM;
	commandFunctions[171 | 0x0200 | 0x0400] = handlerCommand16Code00ABP66P67_PM;
	commandFunctions[172] = handlerCommand16Code00AC_PM;
	commandFunctions[172 | 0x0200 ] = handlerCommand16Code00ACP67_PM;
	commandFunctions[172 | 0x0400] = handlerCommand16Code00ACP66_PM;
	commandFunctions[172 | 0x0200 | 0x0400] = handlerCommand16Code00ACP66P67_PM;
	commandFunctions[173] = handlerCommand16Code00AD_PM;
	commandFunctions[173 | 0x0200 ] = handlerCommand16Code00ADP67_PM;
	commandFunctions[173 | 0x0400] = handlerCommand16Code00ADP66_PM;
	commandFunctions[173 | 0x0200 | 0x0400] = handlerCommand16Code00ADP66P67_PM;
	commandFunctions[174] = handlerCommand16Code00AE_PM;
	commandFunctions[174 | 0x0200 ] = handlerCommand16Code00AEP67_PM;
	commandFunctions[174 | 0x0400] = handlerCommand16Code00AEP66_PM;
	commandFunctions[174 | 0x0200 | 0x0400] = handlerCommand16Code00AEP66P67_PM;
	commandFunctions[175] = handlerCommand16Code00AF_PM;
	commandFunctions[175 | 0x0200 ] = handlerCommand16Code00AFP67_PM;
	commandFunctions[175 | 0x0400] = handlerCommand16Code00AFP66_PM;
	commandFunctions[175 | 0x0200 | 0x0400] = handlerCommand16Code00AFP66P67_PM;
	commandFunctions[176] = handlerCommand16Code00B0_PM;
	commandFunctions[176 | 0x0400] = handlerCommand16Code00B0P66_PM;
	commandFunctions[177] = handlerCommand16Code00B1_PM;
	commandFunctions[177 | 0x0400] = handlerCommand16Code00B1P66_PM;
	commandFunctions[178] = handlerCommand16Code00B2_PM;
	commandFunctions[178 | 0x0400] = handlerCommand16Code00B2P66_PM;
	commandFunctions[179] = handlerCommand16Code00B3_PM;
	commandFunctions[179 | 0x0400] = handlerCommand16Code00B3P66_PM;
	commandFunctions[180] = handlerCommand16Code00B4_PM;
	commandFunctions[180 | 0x0400] = handlerCommand16Code00B4P66_PM;
	commandFunctions[181] = handlerCommand16Code00B5_PM;
	commandFunctions[181 | 0x0400] = handlerCommand16Code00B5P66_PM;
	commandFunctions[182] = handlerCommand16Code00B6_PM;
	commandFunctions[182 | 0x0400] = handlerCommand16Code00B6P66_PM;
	commandFunctions[183] = handlerCommand16Code00B7_PM;
	commandFunctions[183 | 0x0400] = handlerCommand16Code00B7P66_PM;
	commandFunctions[184] = handlerCommand16Code00B8_PM;
	commandFunctions[184 | 0x0400] = handlerCommand16Code00B8P66_PM;
	commandFunctions[185] = handlerCommand16Code00B9_PM;
	commandFunctions[185 | 0x0400] = handlerCommand16Code00B9P66_PM;
	commandFunctions[186] = handlerCommand16Code00BA_PM;
	commandFunctions[186 | 0x0400] = handlerCommand16Code00BAP66_PM;
	commandFunctions[187] = handlerCommand16Code00BB_PM;
	commandFunctions[187 | 0x0400] = handlerCommand16Code00BBP66_PM;
	commandFunctions[188] = handlerCommand16Code00BC_PM;
	commandFunctions[188 | 0x0400] = handlerCommand16Code00BCP66_PM;
	commandFunctions[189] = handlerCommand16Code00BD_PM;
	commandFunctions[189 | 0x0400] = handlerCommand16Code00BDP66_PM;
	commandFunctions[190] = handlerCommand16Code00BE_PM;
	commandFunctions[190 | 0x0400] = handlerCommand16Code00BEP66_PM;
	commandFunctions[191] = handlerCommand16Code00BF_PM;
	commandFunctions[191 | 0x0400] = handlerCommand16Code00BFP66_PM;
	commandFunctions[192] = handlerCommand16Code00C0_PM;
	commandFunctions[192 | 0x0400] = handlerCommand16Code00C0P66_PM;
	commandFunctions[193] = handlerCommand16Code00C1_PM;
	commandFunctions[193 | 0x0400] = handlerCommand16Code00C1P66_PM;
	commandFunctions[194] = handlerCommand16Code00C2_PM;
	commandFunctions[195] = handlerCommand16Code00C3_PM;
	commandFunctions[196] = handlerCommand16Code00C4_PM;
	commandFunctions[197] = handlerCommand16Code00C5_PM;
	commandFunctions[198] = handlerCommand16Code00C6_PM;
	commandFunctions[198 | 0x0400] = handlerCommand16Code00C6P66_PM;
	commandFunctions[199] = handlerCommand16Code00C7_PM;
	commandFunctions[199 | 0x0400] = handlerCommand16Code00C7P66_PM;
	commandFunctions[200] = handlerCommand16Code00C8_PM;
	commandFunctions[200 | 0x0200 ] = handlerCommand16Code00C8P67_PM;
	commandFunctions[200 | 0x0400] = handlerCommand16Code00C8P66_PM;
	commandFunctions[200 | 0x0200 | 0x0400] = handlerCommand16Code00C8P66P67_PM;
	commandFunctions[201] = handlerCommand16Code00C9_PM;
	commandFunctions[201 | 0x0200 ] = handlerCommand16Code00C9P67_PM;
	commandFunctions[201 | 0x0400] = handlerCommand16Code00C9P66_PM;
	commandFunctions[201 | 0x0200 | 0x0400] = handlerCommand16Code00C9P66P67_PM;
	commandFunctions[202] = handlerCommand16Code00CA_PM;
	commandFunctions[203] = handlerCommand16Code00CB_PM;
	commandFunctions[205] = handlerCommand16Code00CD_PM;
	commandFunctions[208] = handlerCommand16Code00D0_PM;
	commandFunctions[208 | 0x0400] = handlerCommand16Code00D0P66_PM;
	commandFunctions[209] = handlerCommand16Code00D1_PM;
	commandFunctions[209 | 0x0400] = handlerCommand16Code00D1P66_PM;
	commandFunctions[210] = handlerCommand16Code00D2_PM;
	commandFunctions[210 | 0x0400] = handlerCommand16Code00D2P66_PM;
	commandFunctions[211] = handlerCommand16Code00D3_PM;
	commandFunctions[211 | 0x0400] = handlerCommand16Code00D3P66_PM;
	commandFunctions[216] = handlerCommand16Code00D8_PM;
	commandFunctions[217] = handlerCommand16Code00D9_PM;
	commandFunctions[218] = handlerCommand16Code00DA_PM;
	commandFunctions[219] = handlerCommand16Code00DB_PM;
	commandFunctions[220] = handlerCommand16Code00DC_PM;
	commandFunctions[221] = handlerCommand16Code00DD_PM;
	commandFunctions[222] = handlerCommand16Code00DE_PM;
	commandFunctions[223] = handlerCommand16Code00DF_PM;
	commandFunctions[224] = handlerCommand16Code00E0_PM;
	commandFunctions[225] = handlerCommand16Code00E1_PM;
	commandFunctions[226] = handlerCommand16Code00E2_PM;
	commandFunctions[227] = handlerCommand16Code00E3_PM;
	commandFunctions[228] = handlerCommand16Code00E4_PM;
	commandFunctions[228 | 0x0400] = handlerCommand16Code00E4P66_PM;
	commandFunctions[229] = handlerCommand16Code00E5_PM;
	commandFunctions[229 | 0x0400] = handlerCommand16Code00E5P66_PM;
	commandFunctions[230] = handlerCommand16Code00E6_PM;
	commandFunctions[230 | 0x0400] = handlerCommand16Code00E6P66_PM;
	commandFunctions[231] = handlerCommand16Code00E7_PM;
	commandFunctions[231 | 0x0400] = handlerCommand16Code00E7P66_PM;
	commandFunctions[232] = handlerCommand16Code00E8_PM;
	commandFunctions[232 | 0x0400] = handlerCommand16Code00E8P66_PM;
	commandFunctions[233] = handlerCommand16Code00E9_PM;
	commandFunctions[233 | 0x0400] = handlerCommand16Code00E9P66_PM;
	commandFunctions[235] = handlerCommand16Code00EB_PM;
	commandFunctions[236] = handlerCommand16Code00EC_PM;
	commandFunctions[236 | 0x0400] = handlerCommand16Code00ECP66_PM;
	commandFunctions[237] = handlerCommand16Code00ED_PM;
	commandFunctions[237 | 0x0400] = handlerCommand16Code00EDP66_PM;
	commandFunctions[238] = handlerCommand16Code00EE_PM;
	commandFunctions[238 | 0x0400] = handlerCommand16Code00EEP66_PM;
	commandFunctions[239] = handlerCommand16Code00EF_PM;
	commandFunctions[239 | 0x0400] = handlerCommand16Code00EFP66_PM;
	commandFunctions[241] = handlerCommand16Code00F1_PM;
	commandFunctions[245] = handlerCommand16Code00F5_PM;
	commandFunctions[246] = handlerCommand16Code00F6_PM;
	commandFunctions[246 | 0x0400] = handlerCommand16Code00F6P66_PM;
	commandFunctions[247] = handlerCommand16Code00F7_PM;
	commandFunctions[247 | 0x0400] = handlerCommand16Code00F7P66_PM;
	commandFunctions[248] = handlerCommand16Code00F8_PM;
	commandFunctions[249] = handlerCommand16Code00F9_PM;
	commandFunctions[250] = handlerCommand16Code00FA_PM;
	commandFunctions[251] = handlerCommand16Code00FB_PM;
	commandFunctions[252] = handlerCommand16Code00FC_PM;
	commandFunctions[253] = handlerCommand16Code00FD_PM;
	commandFunctions[254] = handlerCommand16Code00FE_PM;
	commandFunctions[255] = handlerCommand16Code00FF_PM;
	commandFunctions[255 | 0x0200 ] = handlerCommand16Code00FFP67_PM;
	commandFunctions[255 | 0x0400] = handlerCommand16Code00FFP66_PM;
	commandFunctions[255 | 0x0200 | 0x0400] = handlerCommand16Code00FFP66P67_PM;
	commandFunctions[257] = handlerCommand16Code0101_PM;
	commandFunctions[384] = handlerCommand16Code0180_PM;
	commandFunctions[385] = handlerCommand16Code0181_PM;
	commandFunctions[386] = handlerCommand16Code0182_PM;
	commandFunctions[387] = handlerCommand16Code0183_PM;
	commandFunctions[388] = handlerCommand16Code0184_PM;
	commandFunctions[389] = handlerCommand16Code0185_PM;
	commandFunctions[390] = handlerCommand16Code0186_PM;
	commandFunctions[391] = handlerCommand16Code0187_PM;
	commandFunctions[392] = handlerCommand16Code0188_PM;
	commandFunctions[393] = handlerCommand16Code0189_PM;
	commandFunctions[394] = handlerCommand16Code018A_PM;
	commandFunctions[395] = handlerCommand16Code018B_PM;
	commandFunctions[396] = handlerCommand16Code018C_PM;
	commandFunctions[397] = handlerCommand16Code018D_PM;
	commandFunctions[398] = handlerCommand16Code018E_PM;
	commandFunctions[399] = handlerCommand16Code018F_PM;
	commandFunctions[400] = handlerCommand16Code0190_PM;
	commandFunctions[400 | 0x0400] = handlerCommand16Code0190P66_PM;
	commandFunctions[401] = handlerCommand16Code0191_PM;
	commandFunctions[401 | 0x0400] = handlerCommand16Code0191P66_PM;
	commandFunctions[402] = handlerCommand16Code0192_PM;
	commandFunctions[402 | 0x0400] = handlerCommand16Code0192P66_PM;
	commandFunctions[403] = handlerCommand16Code0193_PM;
	commandFunctions[403 | 0x0400] = handlerCommand16Code0193P66_PM;
	commandFunctions[404] = handlerCommand16Code0194_PM;
	commandFunctions[404 | 0x0400] = handlerCommand16Code0194P66_PM;
	commandFunctions[405] = handlerCommand16Code0195_PM;
	commandFunctions[405 | 0x0400] = handlerCommand16Code0195P66_PM;
	commandFunctions[406] = handlerCommand16Code0196_PM;
	commandFunctions[406 | 0x0400] = handlerCommand16Code0196P66_PM;
	commandFunctions[407] = handlerCommand16Code0197_PM;
	commandFunctions[407 | 0x0400] = handlerCommand16Code0197P66_PM;
	commandFunctions[408] = handlerCommand16Code0198_PM;
	commandFunctions[408 | 0x0400] = handlerCommand16Code0198P66_PM;
	commandFunctions[409] = handlerCommand16Code0199_PM;
	commandFunctions[409 | 0x0400] = handlerCommand16Code0199P66_PM;
	commandFunctions[410] = handlerCommand16Code019A_PM;
	commandFunctions[410 | 0x0400] = handlerCommand16Code019AP66_PM;
	commandFunctions[411] = handlerCommand16Code019B_PM;
	commandFunctions[411 | 0x0400] = handlerCommand16Code019BP66_PM;
	commandFunctions[412] = handlerCommand16Code019C_PM;
	commandFunctions[412 | 0x0400] = handlerCommand16Code019CP66_PM;
	commandFunctions[413] = handlerCommand16Code019D_PM;
	commandFunctions[413 | 0x0400] = handlerCommand16Code019DP66_PM;
	commandFunctions[414] = handlerCommand16Code019E_PM;
	commandFunctions[414 | 0x0400] = handlerCommand16Code019EP66_PM;
	commandFunctions[415] = handlerCommand16Code019F_PM;
	commandFunctions[415 | 0x0400] = handlerCommand16Code019FP66_PM;
	commandFunctions[419] = handlerCommand16Code01A3_PM;
	commandFunctions[419 | 0x0400] = handlerCommand16Code01A3P66_PM;
	commandFunctions[427] = handlerCommand16Code01AB_PM;
	commandFunctions[427 | 0x0400] = handlerCommand16Code01ABP66_PM;
	commandFunctions[431] = handlerCommand16Code01AF_PM;
	commandFunctions[431 | 0x0400] = handlerCommand16Code01AFP66_PM;
	commandFunctions[434] = handlerCommand16Code01B2_PM;
	commandFunctions[435] = handlerCommand16Code01B3_PM;
	commandFunctions[435 | 0x0400] = handlerCommand16Code01B3P66_PM;
	commandFunctions[436] = handlerCommand16Code01B4_PM;
	commandFunctions[437] = handlerCommand16Code01B5_PM;
	commandFunctions[438] = handlerCommand16Code01B6_PM;
	commandFunctions[439] = handlerCommand16Code01B7_PM;
	commandFunctions[439 | 0x0400] = handlerCommand16Code01B7P66_PM;
	commandFunctions[442] = handlerCommand16Code01BA_PM;
	commandFunctions[442 | 0x0400] = handlerCommand16Code01BAP66_PM;
	commandFunctions[443] = handlerCommand16Code01BB_PM;
	commandFunctions[443 | 0x0400] = handlerCommand16Code01BBP66_PM;
	commandFunctions[444] = handlerCommand16Code01BC_PM;
	commandFunctions[444 | 0x0400] = handlerCommand16Code01BCP66_PM;
	commandFunctions[445] = handlerCommand16Code01BD_PM;
	commandFunctions[445 | 0x0400] = handlerCommand16Code01BDP66_PM;
	commandFunctions[446] = handlerCommand16Code01BE_PM;
	commandFunctions[447] = handlerCommand16Code01BF_PM;
	commandFunctions[456] = handlerCommand16Code01C8_PM;
	commandFunctions[457] = handlerCommand16Code01C9_PM;
	commandFunctions[458] = handlerCommand16Code01CA_PM;
	commandFunctions[459] = handlerCommand16Code01CB_PM;
	commandFunctions[460] = handlerCommand16Code01CC_PM;
	commandFunctions[461] = handlerCommand16Code01CD_PM;
	commandFunctions[462] = handlerCommand16Code01CE_PM;
	commandFunctions[463] = handlerCommand16Code01CF_PM;
}
void installCommandFunction32PM() {
	for(int i = 0; i < 256 * 8; i++) {
		commandFunctions[i] = mCommandFunctionEmpty;
	}
	commandFunctions[0] = handlerCommand32Code0000_PM;
	commandFunctions[0 | 0x0400] = handlerCommand32Code0000P66_PM;
	commandFunctions[1] = handlerCommand32Code0001_PM;
	commandFunctions[1 | 0x0400] = handlerCommand32Code0001P66_PM;
	commandFunctions[2] = handlerCommand32Code0002_PM;
	commandFunctions[2 | 0x0400] = handlerCommand32Code0002P66_PM;
	commandFunctions[3] = handlerCommand32Code0003_PM;
	commandFunctions[3 | 0x0400] = handlerCommand32Code0003P66_PM;
	commandFunctions[4] = handlerCommand32Code0004_PM;
	commandFunctions[4 | 0x0400] = handlerCommand32Code0004P66_PM;
	commandFunctions[5] = handlerCommand32Code0005_PM;
	commandFunctions[5 | 0x0400] = handlerCommand32Code0005P66_PM;
	commandFunctions[6] = handlerCommand32Code0006_PM;
	commandFunctions[14] = handlerCommand32Code000E_PM;
	commandFunctions[22] = handlerCommand32Code0016_PM;
	commandFunctions[30] = handlerCommand32Code001E_PM;
	commandFunctions[7] = handlerCommand32Code0007_PM;
	commandFunctions[15] = handlerCommand32Code000F_PM;
	commandFunctions[23] = handlerCommand32Code0017_PM;
	commandFunctions[31] = handlerCommand32Code001F_PM;
	commandFunctions[8] = handlerCommand32Code0008_PM;
	commandFunctions[8 | 0x0400] = handlerCommand32Code0008P66_PM;
	commandFunctions[9] = handlerCommand32Code0009_PM;
	commandFunctions[9 | 0x0400] = handlerCommand32Code0009P66_PM;
	commandFunctions[10] = handlerCommand32Code000A_PM;
	commandFunctions[10 | 0x0400] = handlerCommand32Code000AP66_PM;
	commandFunctions[11] = handlerCommand32Code000B_PM;
	commandFunctions[11 | 0x0400] = handlerCommand32Code000BP66_PM;
	commandFunctions[12] = handlerCommand32Code000C_PM;
	commandFunctions[12 | 0x0400] = handlerCommand32Code000CP66_PM;
	commandFunctions[13] = handlerCommand32Code000D_PM;
	commandFunctions[13 | 0x0400] = handlerCommand32Code000DP66_PM;
	commandFunctions[16] = handlerCommand32Code0010_PM;
	commandFunctions[16 | 0x0400] = handlerCommand32Code0010P66_PM;
	commandFunctions[17] = handlerCommand32Code0011_PM;
	commandFunctions[17 | 0x0400] = handlerCommand32Code0011P66_PM;
	commandFunctions[18] = handlerCommand32Code0012_PM;
	commandFunctions[18 | 0x0400] = handlerCommand32Code0012P66_PM;
	commandFunctions[19] = handlerCommand32Code0013_PM;
	commandFunctions[19 | 0x0400] = handlerCommand32Code0013P66_PM;
	commandFunctions[20] = handlerCommand32Code0014_PM;
	commandFunctions[20 | 0x0400] = handlerCommand32Code0014P66_PM;
	commandFunctions[21] = handlerCommand32Code0015_PM;
	commandFunctions[21 | 0x0400] = handlerCommand32Code0015P66_PM;
	commandFunctions[24] = handlerCommand32Code0018_PM;
	commandFunctions[24 | 0x0400] = handlerCommand32Code0018P66_PM;
	commandFunctions[25] = handlerCommand32Code0019_PM;
	commandFunctions[25 | 0x0400] = handlerCommand32Code0019P66_PM;
	commandFunctions[26] = handlerCommand32Code001A_PM;
	commandFunctions[26 | 0x0400] = handlerCommand32Code001AP66_PM;
	commandFunctions[27] = handlerCommand32Code001B_PM;
	commandFunctions[27 | 0x0400] = handlerCommand32Code001BP66_PM;
	commandFunctions[28] = handlerCommand32Code001C_PM;
	commandFunctions[28 | 0x0400] = handlerCommand32Code001CP66_PM;
	commandFunctions[29] = handlerCommand32Code001D_PM;
	commandFunctions[29 | 0x0400] = handlerCommand32Code001DP66_PM;
	commandFunctions[32] = handlerCommand32Code0020_PM;
	commandFunctions[32 | 0x0400] = handlerCommand32Code0020P66_PM;
	commandFunctions[33] = handlerCommand32Code0021_PM;
	commandFunctions[33 | 0x0400] = handlerCommand32Code0021P66_PM;
	commandFunctions[34] = handlerCommand32Code0022_PM;
	commandFunctions[34 | 0x0400] = handlerCommand32Code0022P66_PM;
	commandFunctions[35] = handlerCommand32Code0023_PM;
	commandFunctions[35 | 0x0400] = handlerCommand32Code0023P66_PM;
	commandFunctions[36] = handlerCommand32Code0024_PM;
	commandFunctions[36 | 0x0400] = handlerCommand32Code0024P66_PM;
	commandFunctions[37] = handlerCommand32Code0025_PM;
	commandFunctions[37 | 0x0400] = handlerCommand32Code0025P66_PM;
	commandFunctions[40] = handlerCommand32Code0028_PM;
	commandFunctions[40 | 0x0400] = handlerCommand32Code0028P66_PM;
	commandFunctions[41] = handlerCommand32Code0029_PM;
	commandFunctions[41 | 0x0400] = handlerCommand32Code0029P66_PM;
	commandFunctions[42] = handlerCommand32Code002A_PM;
	commandFunctions[42 | 0x0400] = handlerCommand32Code002AP66_PM;
	commandFunctions[43] = handlerCommand32Code002B_PM;
	commandFunctions[43 | 0x0400] = handlerCommand32Code002BP66_PM;
	commandFunctions[44] = handlerCommand32Code002C_PM;
	commandFunctions[44 | 0x0400] = handlerCommand32Code002CP66_PM;
	commandFunctions[45] = handlerCommand32Code002D_PM;
	commandFunctions[45 | 0x0400] = handlerCommand32Code002DP66_PM;
	commandFunctions[48] = handlerCommand32Code0030_PM;
	commandFunctions[48 | 0x0400] = handlerCommand32Code0030P66_PM;
	commandFunctions[49] = handlerCommand32Code0031_PM;
	commandFunctions[49 | 0x0400] = handlerCommand32Code0031P66_PM;
	commandFunctions[50] = handlerCommand32Code0032_PM;
	commandFunctions[50 | 0x0400] = handlerCommand32Code0032P66_PM;
	commandFunctions[51] = handlerCommand32Code0033_PM;
	commandFunctions[51 | 0x0400] = handlerCommand32Code0033P66_PM;
	commandFunctions[52] = handlerCommand32Code0034_PM;
	commandFunctions[52 | 0x0400] = handlerCommand32Code0034P66_PM;
	commandFunctions[53] = handlerCommand32Code0035_PM;
	commandFunctions[53 | 0x0400] = handlerCommand32Code0035P66_PM;
	commandFunctions[56] = handlerCommand32Code0038_PM;
	commandFunctions[56 | 0x0400] = handlerCommand32Code0038P66_PM;
	commandFunctions[57] = handlerCommand32Code0039_PM;
	commandFunctions[57 | 0x0400] = handlerCommand32Code0039P66_PM;
	commandFunctions[58] = handlerCommand32Code003A_PM;
	commandFunctions[58 | 0x0400] = handlerCommand32Code003AP66_PM;
	commandFunctions[59] = handlerCommand32Code003B_PM;
	commandFunctions[59 | 0x0400] = handlerCommand32Code003BP66_PM;
	commandFunctions[60] = handlerCommand32Code003C_PM;
	commandFunctions[60 | 0x0400] = handlerCommand32Code003CP66_PM;
	commandFunctions[61] = handlerCommand32Code003D_PM;
	commandFunctions[61 | 0x0400] = handlerCommand32Code003DP66_PM;
	commandFunctions[64] = handlerCommand32Code0040_PM;
	commandFunctions[64 | 0x0400] = handlerCommand32Code0040P66_PM;
	commandFunctions[65] = handlerCommand32Code0041_PM;
	commandFunctions[65 | 0x0400] = handlerCommand32Code0041P66_PM;
	commandFunctions[66] = handlerCommand32Code0042_PM;
	commandFunctions[66 | 0x0400] = handlerCommand32Code0042P66_PM;
	commandFunctions[67] = handlerCommand32Code0043_PM;
	commandFunctions[67 | 0x0400] = handlerCommand32Code0043P66_PM;
	commandFunctions[68] = handlerCommand32Code0044_PM;
	commandFunctions[68 | 0x0400] = handlerCommand32Code0044P66_PM;
	commandFunctions[69] = handlerCommand32Code0045_PM;
	commandFunctions[69 | 0x0400] = handlerCommand32Code0045P66_PM;
	commandFunctions[70] = handlerCommand32Code0046_PM;
	commandFunctions[70 | 0x0400] = handlerCommand32Code0046P66_PM;
	commandFunctions[71] = handlerCommand32Code0047_PM;
	commandFunctions[71 | 0x0400] = handlerCommand32Code0047P66_PM;
	commandFunctions[72] = handlerCommand32Code0048_PM;
	commandFunctions[72 | 0x0400] = handlerCommand32Code0048P66_PM;
	commandFunctions[73] = handlerCommand32Code0049_PM;
	commandFunctions[73 | 0x0400] = handlerCommand32Code0049P66_PM;
	commandFunctions[74] = handlerCommand32Code004A_PM;
	commandFunctions[74 | 0x0400] = handlerCommand32Code004AP66_PM;
	commandFunctions[75] = handlerCommand32Code004B_PM;
	commandFunctions[75 | 0x0400] = handlerCommand32Code004BP66_PM;
	commandFunctions[76] = handlerCommand32Code004C_PM;
	commandFunctions[76 | 0x0400] = handlerCommand32Code004CP66_PM;
	commandFunctions[77] = handlerCommand32Code004D_PM;
	commandFunctions[77 | 0x0400] = handlerCommand32Code004DP66_PM;
	commandFunctions[78] = handlerCommand32Code004E_PM;
	commandFunctions[78 | 0x0400] = handlerCommand32Code004EP66_PM;
	commandFunctions[79] = handlerCommand32Code004F_PM;
	commandFunctions[79 | 0x0400] = handlerCommand32Code004FP66_PM;
	commandFunctions[80] = handlerCommand32Code0050_PM;
	commandFunctions[80 | 0x0200 ] = handlerCommand32Code0050P67_PM;
	commandFunctions[80 | 0x0400] = handlerCommand32Code0050P66_PM;
	commandFunctions[80 | 0x0200 | 0x0400] = handlerCommand32Code0050P66P67_PM;
	commandFunctions[81] = handlerCommand32Code0051_PM;
	commandFunctions[81 | 0x0200 ] = handlerCommand32Code0051P67_PM;
	commandFunctions[81 | 0x0400] = handlerCommand32Code0051P66_PM;
	commandFunctions[81 | 0x0200 | 0x0400] = handlerCommand32Code0051P66P67_PM;
	commandFunctions[82] = handlerCommand32Code0052_PM;
	commandFunctions[82 | 0x0200 ] = handlerCommand32Code0052P67_PM;
	commandFunctions[82 | 0x0400] = handlerCommand32Code0052P66_PM;
	commandFunctions[82 | 0x0200 | 0x0400] = handlerCommand32Code0052P66P67_PM;
	commandFunctions[83] = handlerCommand32Code0053_PM;
	commandFunctions[83 | 0x0200 ] = handlerCommand32Code0053P67_PM;
	commandFunctions[83 | 0x0400] = handlerCommand32Code0053P66_PM;
	commandFunctions[83 | 0x0200 | 0x0400] = handlerCommand32Code0053P66P67_PM;
	commandFunctions[84] = handlerCommand32Code0054_PM;
	commandFunctions[84 | 0x0200 ] = handlerCommand32Code0054P67_PM;
	commandFunctions[84 | 0x0400] = handlerCommand32Code0054P66_PM;
	commandFunctions[84 | 0x0200 | 0x0400] = handlerCommand32Code0054P66P67_PM;
	commandFunctions[85] = handlerCommand32Code0055_PM;
	commandFunctions[85 | 0x0200 ] = handlerCommand32Code0055P67_PM;
	commandFunctions[85 | 0x0400] = handlerCommand32Code0055P66_PM;
	commandFunctions[85 | 0x0200 | 0x0400] = handlerCommand32Code0055P66P67_PM;
	commandFunctions[86] = handlerCommand32Code0056_PM;
	commandFunctions[86 | 0x0200 ] = handlerCommand32Code0056P67_PM;
	commandFunctions[86 | 0x0400] = handlerCommand32Code0056P66_PM;
	commandFunctions[86 | 0x0200 | 0x0400] = handlerCommand32Code0056P66P67_PM;
	commandFunctions[87] = handlerCommand32Code0057_PM;
	commandFunctions[87 | 0x0200 ] = handlerCommand32Code0057P67_PM;
	commandFunctions[87 | 0x0400] = handlerCommand32Code0057P66_PM;
	commandFunctions[87 | 0x0200 | 0x0400] = handlerCommand32Code0057P66P67_PM;
	commandFunctions[88] = handlerCommand32Code0058_PM;
	commandFunctions[88 | 0x0200 ] = handlerCommand32Code0058P67_PM;
	commandFunctions[88 | 0x0400] = handlerCommand32Code0058P66_PM;
	commandFunctions[88 | 0x0200 | 0x0400] = handlerCommand32Code0058P66P67_PM;
	commandFunctions[89] = handlerCommand32Code0059_PM;
	commandFunctions[89 | 0x0200 ] = handlerCommand32Code0059P67_PM;
	commandFunctions[89 | 0x0400] = handlerCommand32Code0059P66_PM;
	commandFunctions[89 | 0x0200 | 0x0400] = handlerCommand32Code0059P66P67_PM;
	commandFunctions[90] = handlerCommand32Code005A_PM;
	commandFunctions[90 | 0x0200 ] = handlerCommand32Code005AP67_PM;
	commandFunctions[90 | 0x0400] = handlerCommand32Code005AP66_PM;
	commandFunctions[90 | 0x0200 | 0x0400] = handlerCommand32Code005AP66P67_PM;
	commandFunctions[91] = handlerCommand32Code005B_PM;
	commandFunctions[91 | 0x0200 ] = handlerCommand32Code005BP67_PM;
	commandFunctions[91 | 0x0400] = handlerCommand32Code005BP66_PM;
	commandFunctions[91 | 0x0200 | 0x0400] = handlerCommand32Code005BP66P67_PM;
	commandFunctions[92] = handlerCommand32Code005C_PM;
	commandFunctions[92 | 0x0200 ] = handlerCommand32Code005CP67_PM;
	commandFunctions[92 | 0x0400] = handlerCommand32Code005CP66_PM;
	commandFunctions[92 | 0x0200 | 0x0400] = handlerCommand32Code005CP66P67_PM;
	commandFunctions[93] = handlerCommand32Code005D_PM;
	commandFunctions[93 | 0x0200 ] = handlerCommand32Code005DP67_PM;
	commandFunctions[93 | 0x0400] = handlerCommand32Code005DP66_PM;
	commandFunctions[93 | 0x0200 | 0x0400] = handlerCommand32Code005DP66P67_PM;
	commandFunctions[94] = handlerCommand32Code005E_PM;
	commandFunctions[94 | 0x0200 ] = handlerCommand32Code005EP67_PM;
	commandFunctions[94 | 0x0400] = handlerCommand32Code005EP66_PM;
	commandFunctions[94 | 0x0200 | 0x0400] = handlerCommand32Code005EP66P67_PM;
	commandFunctions[95] = handlerCommand32Code005F_PM;
	commandFunctions[95 | 0x0200 ] = handlerCommand32Code005FP67_PM;
	commandFunctions[95 | 0x0400] = handlerCommand32Code005FP66_PM;
	commandFunctions[95 | 0x0200 | 0x0400] = handlerCommand32Code005FP66P67_PM;
	commandFunctions[96] = handlerCommand32Code0060_PM;
	commandFunctions[96 | 0x0400] = handlerCommand32Code0060P66_PM;
	commandFunctions[97] = handlerCommand32Code0061_PM;
	commandFunctions[97 | 0x0400] = handlerCommand32Code0061P66_PM;
	commandFunctions[104] = handlerCommand32Code0068_PM;
	commandFunctions[104 | 0x0200 ] = handlerCommand32Code0068P67_PM;
	commandFunctions[104 | 0x0400] = handlerCommand32Code0068P66_PM;
	commandFunctions[104 | 0x0200 | 0x0400] = handlerCommand32Code0068P66P67_PM;
	commandFunctions[105] = handlerCommand32Code0069_PM;
	commandFunctions[105 | 0x0400] = handlerCommand32Code0069P66_PM;
	commandFunctions[106] = handlerCommand32Code006A_PM;
	commandFunctions[106 | 0x0200 ] = handlerCommand32Code006AP67_PM;
	commandFunctions[106 | 0x0400] = handlerCommand32Code006AP66_PM;
	commandFunctions[106 | 0x0200 | 0x0400] = handlerCommand32Code006AP66P67_PM;
	commandFunctions[107] = handlerCommand32Code006B_PM;
	commandFunctions[112] = handlerCommand32Code0070_PM;
	commandFunctions[113] = handlerCommand32Code0071_PM;
	commandFunctions[114] = handlerCommand32Code0072_PM;
	commandFunctions[115] = handlerCommand32Code0073_PM;
	commandFunctions[116] = handlerCommand32Code0074_PM;
	commandFunctions[117] = handlerCommand32Code0075_PM;
	commandFunctions[118] = handlerCommand32Code0076_PM;
	commandFunctions[119] = handlerCommand32Code0077_PM;
	commandFunctions[120] = handlerCommand32Code0078_PM;
	commandFunctions[121] = handlerCommand32Code0079_PM;
	commandFunctions[122] = handlerCommand32Code007A_PM;
	commandFunctions[123] = handlerCommand32Code007B_PM;
	commandFunctions[124] = handlerCommand32Code007C_PM;
	commandFunctions[125] = handlerCommand32Code007D_PM;
	commandFunctions[126] = handlerCommand32Code007E_PM;
	commandFunctions[127] = handlerCommand32Code007F_PM;
	commandFunctions[128] = handlerCommand32Code0080_PM;
	commandFunctions[128 | 0x0400] = handlerCommand32Code0080P66_PM;
	commandFunctions[129] = handlerCommand32Code0081_PM;
	commandFunctions[129 | 0x0400] = handlerCommand32Code0081P66_PM;
	commandFunctions[130] = handlerCommand32Code0082_PM;
	commandFunctions[131] = handlerCommand32Code0083_PM;
	commandFunctions[132] = handlerCommand32Code0084_PM;
	commandFunctions[132 | 0x0400] = handlerCommand32Code0084P66_PM;
	commandFunctions[133] = handlerCommand32Code0085_PM;
	commandFunctions[133 | 0x0400] = handlerCommand32Code0085P66_PM;
	commandFunctions[134] = handlerCommand32Code0086_PM;
	commandFunctions[134 | 0x0400] = handlerCommand32Code0086P66_PM;
	commandFunctions[135] = handlerCommand32Code0087_PM;
	commandFunctions[135 | 0x0400] = handlerCommand32Code0087P66_PM;
	commandFunctions[136] = handlerCommand32Code0088_PM;
	commandFunctions[136 | 0x0400] = handlerCommand32Code0088P66_PM;
	commandFunctions[137] = handlerCommand32Code0089_PM;
	commandFunctions[137 | 0x0400] = handlerCommand32Code0089P66_PM;
	commandFunctions[138] = handlerCommand32Code008A_PM;
	commandFunctions[138 | 0x0400] = handlerCommand32Code008AP66_PM;
	commandFunctions[139] = handlerCommand32Code008B_PM;
	commandFunctions[139 | 0x0400] = handlerCommand32Code008BP66_PM;
	commandFunctions[140] = handlerCommand32Code008C_PM;
	commandFunctions[142] = handlerCommand32Code008E_PM;
	commandFunctions[141] = handlerCommand32Code008D_PM;
	commandFunctions[141 | 0x0200 ] = handlerCommand32Code008DP67_PM;
	commandFunctions[141 | 0x0400] = handlerCommand32Code008DP66_PM;
	commandFunctions[141 | 0x0200 | 0x0400] = handlerCommand32Code008DP66P67_PM;
	commandFunctions[143] = handlerCommand32Code008F_PM;
	commandFunctions[143 | 0x0200 ] = handlerCommand32Code008FP67_PM;
	commandFunctions[143 | 0x0400] = handlerCommand32Code008FP66_PM;
	commandFunctions[143 | 0x0200 | 0x0400] = handlerCommand32Code008FP66P67_PM;
	commandFunctions[144] = handlerCommand32Code0090_PM;
	commandFunctions[144 | 0x0400] = handlerCommand32Code0090P66_PM;
	commandFunctions[145] = handlerCommand32Code0091_PM;
	commandFunctions[145 | 0x0400] = handlerCommand32Code0091P66_PM;
	commandFunctions[146] = handlerCommand32Code0092_PM;
	commandFunctions[146 | 0x0400] = handlerCommand32Code0092P66_PM;
	commandFunctions[147] = handlerCommand32Code0093_PM;
	commandFunctions[147 | 0x0400] = handlerCommand32Code0093P66_PM;
	commandFunctions[148] = handlerCommand32Code0094_PM;
	commandFunctions[148 | 0x0400] = handlerCommand32Code0094P66_PM;
	commandFunctions[149] = handlerCommand32Code0095_PM;
	commandFunctions[149 | 0x0400] = handlerCommand32Code0095P66_PM;
	commandFunctions[150] = handlerCommand32Code0096_PM;
	commandFunctions[150 | 0x0400] = handlerCommand32Code0096P66_PM;
	commandFunctions[151] = handlerCommand32Code0097_PM;
	commandFunctions[151 | 0x0400] = handlerCommand32Code0097P66_PM;
	commandFunctions[152] = handlerCommand32Code0098_PM;
	commandFunctions[152 | 0x0400] = handlerCommand32Code0098P66_PM;
	commandFunctions[153] = handlerCommand32Code0099_PM;
	commandFunctions[153 | 0x0400] = handlerCommand32Code0099P66_PM;
	commandFunctions[154] = handlerCommand32Code009A_PM;
	commandFunctions[156] = handlerCommand32Code009C_PM;
	commandFunctions[156 | 0x0400] = handlerCommand32Code009CP66_PM;
	commandFunctions[157] = handlerCommand32Code009D_PM;
	commandFunctions[157 | 0x0400] = handlerCommand32Code009DP66_PM;
	commandFunctions[160] = handlerCommand32Code00A0_PM;
	commandFunctions[160 | 0x0200 ] = handlerCommand32Code00A0P67_PM;
	commandFunctions[160 | 0x0400] = handlerCommand32Code00A0P66_PM;
	commandFunctions[160 | 0x0200 | 0x0400] = handlerCommand32Code00A0P66P67_PM;
	commandFunctions[161] = handlerCommand32Code00A1_PM;
	commandFunctions[161 | 0x0200 ] = handlerCommand32Code00A1P67_PM;
	commandFunctions[161 | 0x0400] = handlerCommand32Code00A1P66_PM;
	commandFunctions[161 | 0x0200 | 0x0400] = handlerCommand32Code00A1P66P67_PM;
	commandFunctions[162] = handlerCommand32Code00A2_PM;
	commandFunctions[162 | 0x0200 ] = handlerCommand32Code00A2P67_PM;
	commandFunctions[162 | 0x0400] = handlerCommand32Code00A2P66_PM;
	commandFunctions[162 | 0x0200 | 0x0400] = handlerCommand32Code00A2P66P67_PM;
	commandFunctions[163] = handlerCommand32Code00A3_PM;
	commandFunctions[163 | 0x0200 ] = handlerCommand32Code00A3P67_PM;
	commandFunctions[163 | 0x0400] = handlerCommand32Code00A3P66_PM;
	commandFunctions[163 | 0x0200 | 0x0400] = handlerCommand32Code00A3P66P67_PM;
	commandFunctions[164] = handlerCommand32Code00A4_PM;
	commandFunctions[164 | 0x0200 ] = handlerCommand32Code00A4P67_PM;
	commandFunctions[164 | 0x0400] = handlerCommand32Code00A4P66_PM;
	commandFunctions[164 | 0x0200 | 0x0400] = handlerCommand32Code00A4P66P67_PM;
	commandFunctions[165] = handlerCommand32Code00A5_PM;
	commandFunctions[165 | 0x0200 ] = handlerCommand32Code00A5P67_PM;
	commandFunctions[165 | 0x0400] = handlerCommand32Code00A5P66_PM;
	commandFunctions[165 | 0x0200 | 0x0400] = handlerCommand32Code00A5P66P67_PM;
	commandFunctions[166] = handlerCommand32Code00A6_PM;
	commandFunctions[166 | 0x0200 ] = handlerCommand32Code00A6P67_PM;
	commandFunctions[166 | 0x0400] = handlerCommand32Code00A6P66_PM;
	commandFunctions[166 | 0x0200 | 0x0400] = handlerCommand32Code00A6P66P67_PM;
	commandFunctions[167] = handlerCommand32Code00A7_PM;
	commandFunctions[167 | 0x0200 ] = handlerCommand32Code00A7P67_PM;
	commandFunctions[167 | 0x0400] = handlerCommand32Code00A7P66_PM;
	commandFunctions[167 | 0x0200 | 0x0400] = handlerCommand32Code00A7P66P67_PM;
	commandFunctions[168] = handlerCommand32Code00A8_PM;
	commandFunctions[168 | 0x0400] = handlerCommand32Code00A8P66_PM;
	commandFunctions[169] = handlerCommand32Code00A9_PM;
	commandFunctions[169 | 0x0400] = handlerCommand32Code00A9P66_PM;
	commandFunctions[170] = handlerCommand32Code00AA_PM;
	commandFunctions[170 | 0x0200 ] = handlerCommand32Code00AAP67_PM;
	commandFunctions[170 | 0x0400] = handlerCommand32Code00AAP66_PM;
	commandFunctions[170 | 0x0200 | 0x0400] = handlerCommand32Code00AAP66P67_PM;
	commandFunctions[171] = handlerCommand32Code00AB_PM;
	commandFunctions[171 | 0x0200 ] = handlerCommand32Code00ABP67_PM;
	commandFunctions[171 | 0x0400] = handlerCommand32Code00ABP66_PM;
	commandFunctions[171 | 0x0200 | 0x0400] = handlerCommand32Code00ABP66P67_PM;
	commandFunctions[172] = handlerCommand32Code00AC_PM;
	commandFunctions[172 | 0x0200 ] = handlerCommand32Code00ACP67_PM;
	commandFunctions[172 | 0x0400] = handlerCommand32Code00ACP66_PM;
	commandFunctions[172 | 0x0200 | 0x0400] = handlerCommand32Code00ACP66P67_PM;
	commandFunctions[173] = handlerCommand32Code00AD_PM;
	commandFunctions[173 | 0x0200 ] = handlerCommand32Code00ADP67_PM;
	commandFunctions[173 | 0x0400] = handlerCommand32Code00ADP66_PM;
	commandFunctions[173 | 0x0200 | 0x0400] = handlerCommand32Code00ADP66P67_PM;
	commandFunctions[174] = handlerCommand32Code00AE_PM;
	commandFunctions[174 | 0x0200 ] = handlerCommand32Code00AEP67_PM;
	commandFunctions[174 | 0x0400] = handlerCommand32Code00AEP66_PM;
	commandFunctions[174 | 0x0200 | 0x0400] = handlerCommand32Code00AEP66P67_PM;
	commandFunctions[175] = handlerCommand32Code00AF_PM;
	commandFunctions[175 | 0x0200 ] = handlerCommand32Code00AFP67_PM;
	commandFunctions[175 | 0x0400] = handlerCommand32Code00AFP66_PM;
	commandFunctions[175 | 0x0200 | 0x0400] = handlerCommand32Code00AFP66P67_PM;
	commandFunctions[176] = handlerCommand32Code00B0_PM;
	commandFunctions[176 | 0x0400] = handlerCommand32Code00B0P66_PM;
	commandFunctions[177] = handlerCommand32Code00B1_PM;
	commandFunctions[177 | 0x0400] = handlerCommand32Code00B1P66_PM;
	commandFunctions[178] = handlerCommand32Code00B2_PM;
	commandFunctions[178 | 0x0400] = handlerCommand32Code00B2P66_PM;
	commandFunctions[179] = handlerCommand32Code00B3_PM;
	commandFunctions[179 | 0x0400] = handlerCommand32Code00B3P66_PM;
	commandFunctions[180] = handlerCommand32Code00B4_PM;
	commandFunctions[180 | 0x0400] = handlerCommand32Code00B4P66_PM;
	commandFunctions[181] = handlerCommand32Code00B5_PM;
	commandFunctions[181 | 0x0400] = handlerCommand32Code00B5P66_PM;
	commandFunctions[182] = handlerCommand32Code00B6_PM;
	commandFunctions[182 | 0x0400] = handlerCommand32Code00B6P66_PM;
	commandFunctions[183] = handlerCommand32Code00B7_PM;
	commandFunctions[183 | 0x0400] = handlerCommand32Code00B7P66_PM;
	commandFunctions[184] = handlerCommand32Code00B8_PM;
	commandFunctions[184 | 0x0400] = handlerCommand32Code00B8P66_PM;
	commandFunctions[185] = handlerCommand32Code00B9_PM;
	commandFunctions[185 | 0x0400] = handlerCommand32Code00B9P66_PM;
	commandFunctions[186] = handlerCommand32Code00BA_PM;
	commandFunctions[186 | 0x0400] = handlerCommand32Code00BAP66_PM;
	commandFunctions[187] = handlerCommand32Code00BB_PM;
	commandFunctions[187 | 0x0400] = handlerCommand32Code00BBP66_PM;
	commandFunctions[188] = handlerCommand32Code00BC_PM;
	commandFunctions[188 | 0x0400] = handlerCommand32Code00BCP66_PM;
	commandFunctions[189] = handlerCommand32Code00BD_PM;
	commandFunctions[189 | 0x0400] = handlerCommand32Code00BDP66_PM;
	commandFunctions[190] = handlerCommand32Code00BE_PM;
	commandFunctions[190 | 0x0400] = handlerCommand32Code00BEP66_PM;
	commandFunctions[191] = handlerCommand32Code00BF_PM;
	commandFunctions[191 | 0x0400] = handlerCommand32Code00BFP66_PM;
	commandFunctions[192] = handlerCommand32Code00C0_PM;
	commandFunctions[192 | 0x0400] = handlerCommand32Code00C0P66_PM;
	commandFunctions[193] = handlerCommand32Code00C1_PM;
	commandFunctions[193 | 0x0400] = handlerCommand32Code00C1P66_PM;
	commandFunctions[194] = handlerCommand32Code00C2_PM;
	commandFunctions[195] = handlerCommand32Code00C3_PM;
	commandFunctions[196] = handlerCommand32Code00C4_PM;
	commandFunctions[197] = handlerCommand32Code00C5_PM;
	commandFunctions[198] = handlerCommand32Code00C6_PM;
	commandFunctions[198 | 0x0400] = handlerCommand32Code00C6P66_PM;
	commandFunctions[199] = handlerCommand32Code00C7_PM;
	commandFunctions[199 | 0x0400] = handlerCommand32Code00C7P66_PM;
	commandFunctions[200] = handlerCommand32Code00C8_PM;
	commandFunctions[200 | 0x0200 ] = handlerCommand32Code00C8P67_PM;
	commandFunctions[200 | 0x0400] = handlerCommand32Code00C8P66_PM;
	commandFunctions[200 | 0x0200 | 0x0400] = handlerCommand32Code00C8P66P67_PM;
	commandFunctions[201] = handlerCommand32Code00C9_PM;
	commandFunctions[201 | 0x0200 ] = handlerCommand32Code00C9P67_PM;
	commandFunctions[201 | 0x0400] = handlerCommand32Code00C9P66_PM;
	commandFunctions[201 | 0x0200 | 0x0400] = handlerCommand32Code00C9P66P67_PM;
	commandFunctions[202] = handlerCommand32Code00CA_PM;
	commandFunctions[203] = handlerCommand32Code00CB_PM;
	commandFunctions[205] = handlerCommand32Code00CD_PM;
	commandFunctions[208] = handlerCommand32Code00D0_PM;
	commandFunctions[208 | 0x0400] = handlerCommand32Code00D0P66_PM;
	commandFunctions[209] = handlerCommand32Code00D1_PM;
	commandFunctions[209 | 0x0400] = handlerCommand32Code00D1P66_PM;
	commandFunctions[210] = handlerCommand32Code00D2_PM;
	commandFunctions[210 | 0x0400] = handlerCommand32Code00D2P66_PM;
	commandFunctions[211] = handlerCommand32Code00D3_PM;
	commandFunctions[211 | 0x0400] = handlerCommand32Code00D3P66_PM;
	commandFunctions[216] = handlerCommand32Code00D8_PM;
	commandFunctions[217] = handlerCommand32Code00D9_PM;
	commandFunctions[218] = handlerCommand32Code00DA_PM;
	commandFunctions[219] = handlerCommand32Code00DB_PM;
	commandFunctions[220] = handlerCommand32Code00DC_PM;
	commandFunctions[221] = handlerCommand32Code00DD_PM;
	commandFunctions[222] = handlerCommand32Code00DE_PM;
	commandFunctions[223] = handlerCommand32Code00DF_PM;
	commandFunctions[224] = handlerCommand32Code00E0_PM;
	commandFunctions[225] = handlerCommand32Code00E1_PM;
	commandFunctions[226] = handlerCommand32Code00E2_PM;
	commandFunctions[227] = handlerCommand32Code00E3_PM;
	commandFunctions[228] = handlerCommand32Code00E4_PM;
	commandFunctions[228 | 0x0400] = handlerCommand32Code00E4P66_PM;
	commandFunctions[229] = handlerCommand32Code00E5_PM;
	commandFunctions[229 | 0x0400] = handlerCommand32Code00E5P66_PM;
	commandFunctions[230] = handlerCommand32Code00E6_PM;
	commandFunctions[230 | 0x0400] = handlerCommand32Code00E6P66_PM;
	commandFunctions[231] = handlerCommand32Code00E7_PM;
	commandFunctions[231 | 0x0400] = handlerCommand32Code00E7P66_PM;
	commandFunctions[232] = handlerCommand32Code00E8_PM;
	commandFunctions[232 | 0x0400] = handlerCommand32Code00E8P66_PM;
	commandFunctions[233] = handlerCommand32Code00E9_PM;
	commandFunctions[233 | 0x0400] = handlerCommand32Code00E9P66_PM;
	commandFunctions[235] = handlerCommand32Code00EB_PM;
	commandFunctions[236] = handlerCommand32Code00EC_PM;
	commandFunctions[236 | 0x0400] = handlerCommand32Code00ECP66_PM;
	commandFunctions[237] = handlerCommand32Code00ED_PM;
	commandFunctions[237 | 0x0400] = handlerCommand32Code00EDP66_PM;
	commandFunctions[238] = handlerCommand32Code00EE_PM;
	commandFunctions[238 | 0x0400] = handlerCommand32Code00EEP66_PM;
	commandFunctions[239] = handlerCommand32Code00EF_PM;
	commandFunctions[239 | 0x0400] = handlerCommand32Code00EFP66_PM;
	commandFunctions[241] = handlerCommand32Code00F1_PM;
	commandFunctions[245] = handlerCommand32Code00F5_PM;
	commandFunctions[246] = handlerCommand32Code00F6_PM;
	commandFunctions[246 | 0x0400] = handlerCommand32Code00F6P66_PM;
	commandFunctions[247] = handlerCommand32Code00F7_PM;
	commandFunctions[247 | 0x0400] = handlerCommand32Code00F7P66_PM;
	commandFunctions[248] = handlerCommand32Code00F8_PM;
	commandFunctions[249] = handlerCommand32Code00F9_PM;
	commandFunctions[250] = handlerCommand32Code00FA_PM;
	commandFunctions[251] = handlerCommand32Code00FB_PM;
	commandFunctions[252] = handlerCommand32Code00FC_PM;
	commandFunctions[253] = handlerCommand32Code00FD_PM;
	commandFunctions[254] = handlerCommand32Code00FE_PM;
	commandFunctions[255] = handlerCommand32Code00FF_PM;
	commandFunctions[255 | 0x0200 ] = handlerCommand32Code00FFP67_PM;
	commandFunctions[255 | 0x0400] = handlerCommand32Code00FFP66_PM;
	commandFunctions[255 | 0x0200 | 0x0400] = handlerCommand32Code00FFP66P67_PM;
	commandFunctions[257] = handlerCommand32Code0101_PM;
	commandFunctions[384] = handlerCommand32Code0180_PM;
	commandFunctions[385] = handlerCommand32Code0181_PM;
	commandFunctions[386] = handlerCommand32Code0182_PM;
	commandFunctions[387] = handlerCommand32Code0183_PM;
	commandFunctions[388] = handlerCommand32Code0184_PM;
	commandFunctions[389] = handlerCommand32Code0185_PM;
	commandFunctions[390] = handlerCommand32Code0186_PM;
	commandFunctions[391] = handlerCommand32Code0187_PM;
	commandFunctions[392] = handlerCommand32Code0188_PM;
	commandFunctions[393] = handlerCommand32Code0189_PM;
	commandFunctions[394] = handlerCommand32Code018A_PM;
	commandFunctions[395] = handlerCommand32Code018B_PM;
	commandFunctions[396] = handlerCommand32Code018C_PM;
	commandFunctions[397] = handlerCommand32Code018D_PM;
	commandFunctions[398] = handlerCommand32Code018E_PM;
	commandFunctions[399] = handlerCommand32Code018F_PM;
	commandFunctions[400] = handlerCommand32Code0190_PM;
	commandFunctions[400 | 0x0400] = handlerCommand32Code0190P66_PM;
	commandFunctions[401] = handlerCommand32Code0191_PM;
	commandFunctions[401 | 0x0400] = handlerCommand32Code0191P66_PM;
	commandFunctions[402] = handlerCommand32Code0192_PM;
	commandFunctions[402 | 0x0400] = handlerCommand32Code0192P66_PM;
	commandFunctions[403] = handlerCommand32Code0193_PM;
	commandFunctions[403 | 0x0400] = handlerCommand32Code0193P66_PM;
	commandFunctions[404] = handlerCommand32Code0194_PM;
	commandFunctions[404 | 0x0400] = handlerCommand32Code0194P66_PM;
	commandFunctions[405] = handlerCommand32Code0195_PM;
	commandFunctions[405 | 0x0400] = handlerCommand32Code0195P66_PM;
	commandFunctions[406] = handlerCommand32Code0196_PM;
	commandFunctions[406 | 0x0400] = handlerCommand32Code0196P66_PM;
	commandFunctions[407] = handlerCommand32Code0197_PM;
	commandFunctions[407 | 0x0400] = handlerCommand32Code0197P66_PM;
	commandFunctions[408] = handlerCommand32Code0198_PM;
	commandFunctions[408 | 0x0400] = handlerCommand32Code0198P66_PM;
	commandFunctions[409] = handlerCommand32Code0199_PM;
	commandFunctions[409 | 0x0400] = handlerCommand32Code0199P66_PM;
	commandFunctions[410] = handlerCommand32Code019A_PM;
	commandFunctions[410 | 0x0400] = handlerCommand32Code019AP66_PM;
	commandFunctions[411] = handlerCommand32Code019B_PM;
	commandFunctions[411 | 0x0400] = handlerCommand32Code019BP66_PM;
	commandFunctions[412] = handlerCommand32Code019C_PM;
	commandFunctions[412 | 0x0400] = handlerCommand32Code019CP66_PM;
	commandFunctions[413] = handlerCommand32Code019D_PM;
	commandFunctions[413 | 0x0400] = handlerCommand32Code019DP66_PM;
	commandFunctions[414] = handlerCommand32Code019E_PM;
	commandFunctions[414 | 0x0400] = handlerCommand32Code019EP66_PM;
	commandFunctions[415] = handlerCommand32Code019F_PM;
	commandFunctions[415 | 0x0400] = handlerCommand32Code019FP66_PM;
	commandFunctions[419] = handlerCommand32Code01A3_PM;
	commandFunctions[419 | 0x0400] = handlerCommand32Code01A3P66_PM;
	commandFunctions[427] = handlerCommand32Code01AB_PM;
	commandFunctions[427 | 0x0400] = handlerCommand32Code01ABP66_PM;
	commandFunctions[431] = handlerCommand32Code01AF_PM;
	commandFunctions[431 | 0x0400] = handlerCommand32Code01AFP66_PM;
	commandFunctions[434] = handlerCommand32Code01B2_PM;
	commandFunctions[435] = handlerCommand32Code01B3_PM;
	commandFunctions[435 | 0x0400] = handlerCommand32Code01B3P66_PM;
	commandFunctions[436] = handlerCommand32Code01B4_PM;
	commandFunctions[437] = handlerCommand32Code01B5_PM;
	commandFunctions[438] = handlerCommand32Code01B6_PM;
	commandFunctions[439] = handlerCommand32Code01B7_PM;
	commandFunctions[439 | 0x0400] = handlerCommand32Code01B7P66_PM;
	commandFunctions[442] = handlerCommand32Code01BA_PM;
	commandFunctions[442 | 0x0400] = handlerCommand32Code01BAP66_PM;
	commandFunctions[443] = handlerCommand32Code01BB_PM;
	commandFunctions[443 | 0x0400] = handlerCommand32Code01BBP66_PM;
	commandFunctions[444] = handlerCommand32Code01BC_PM;
	commandFunctions[444 | 0x0400] = handlerCommand32Code01BCP66_PM;
	commandFunctions[445] = handlerCommand32Code01BD_PM;
	commandFunctions[445 | 0x0400] = handlerCommand32Code01BDP66_PM;
	commandFunctions[446] = handlerCommand32Code01BE_PM;
	commandFunctions[447] = handlerCommand32Code01BF_PM;
	commandFunctions[456] = handlerCommand32Code01C8_PM;
	commandFunctions[457] = handlerCommand32Code01C9_PM;
	commandFunctions[458] = handlerCommand32Code01CA_PM;
	commandFunctions[459] = handlerCommand32Code01CB_PM;
	commandFunctions[460] = handlerCommand32Code01CC_PM;
	commandFunctions[461] = handlerCommand32Code01CD_PM;
	commandFunctions[462] = handlerCommand32Code01CE_PM;
	commandFunctions[463] = handlerCommand32Code01CF_PM;
}
